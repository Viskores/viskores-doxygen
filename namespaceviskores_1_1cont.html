<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Viskores: viskores::cont Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Viskores
   &#160;<span id="projectnumber">0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceviskores.html">viskores</a></li><li class="navelem"><a class="el" href="namespaceviskores_1_1cont.html">cont</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">viskores::cont Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Viskores Control Environment.  
<a href="namespaceviskores_1_1cont.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceviskores_1_1cont_1_1arg"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont_1_1arg.html">arg</a></td></tr>
<tr class="memdesc:namespaceviskores_1_1cont_1_1arg"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transportation controls for Control Environment Objects. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviskores_1_1cont_1_1cuda"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont_1_1cuda.html">cuda</a></td></tr>
<tr class="memdesc:namespaceviskores_1_1cont_1_1cuda"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUDA implementation for Control Environment. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviskores_1_1cont_1_1kokkos"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont_1_1kokkos.html">kokkos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviskores_1_1cont_1_1openmp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont_1_1openmp.html">openmp</a></td></tr>
<tr class="memdesc:namespaceviskores_1_1cont_1_1openmp"><td class="mdescLeft">&#160;</td><td class="mdescRight">OPenMP implementation for Control Environment. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviskores_1_1cont_1_1serial"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont_1_1serial.html">serial</a></td></tr>
<tr class="memdesc:namespaceviskores_1_1cont_1_1serial"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial implementation for Control Environment. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceviskores_1_1cont_1_1tbb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont_1_1tbb.html">tbb</a></td></tr>
<tr class="memdesc:namespaceviskores_1_1cont_1_1tbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">TBB implementation for Control Environment. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1Algorithm.html">Algorithm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages an array-worth of data.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html">ArrayHandleBasic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic array storage for an array handle.  <a href="classviskores_1_1cont_1_1ArrayHandleBasic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBitField.html">ArrayHandleBitField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classviskores_1_1cont_1_1ArrayHandleBitField.html" title="The ArrayHandleBitField class is a boolean-valued ArrayHandle that is backed by a BitField.">ArrayHandleBitField</a> class is a boolean-valued <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> that is backed by a <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a>.  <a href="classviskores_1_1cont_1_1ArrayHandleBitField.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleCartesianProduct.html">ArrayHandleCartesianProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleCartesianProduct.html" title="ArrayHandleCartesianProduct is a specialization of ArrayHandle.">ArrayHandleCartesianProduct</a> is a specialization of <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="classviskores_1_1cont_1_1ArrayHandleCartesianProduct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleCast.html">ArrayHandleCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the values of an array to the specified type, on demand.  <a href="classviskores_1_1cont_1_1ArrayHandleCast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleCompositeVector.html">ArrayHandleCompositeVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> that combines components from other arrays.  <a href="classviskores_1_1cont_1_1ArrayHandleCompositeVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleConcatenate.html">ArrayHandleConcatenate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleConstant.html">ArrayHandleConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array handle with a constant value.  <a href="classviskores_1_1cont_1_1ArrayHandleConstant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleCounting.html">ArrayHandleCounting</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleCounting.html" title="ArrayHandleCounting is a specialization of ArrayHandle.">ArrayHandleCounting</a> is a specialization of <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="classviskores_1_1cont_1_1ArrayHandleCounting.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleDecorator.html">ArrayHandleDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fancy <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> that can be used to modify the results from one or more source <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="classviskores_1_1cont_1_1ArrayHandleDecorator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleDiscard.html">ArrayHandleDiscard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleDiscard.html" title="ArrayHandleDiscard is a write-only array that discards all data written to it.">ArrayHandleDiscard</a> is a write-only array that discards all data written to it.  <a href="classviskores_1_1cont_1_1ArrayHandleDiscard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleExtractComponent.html">ArrayHandleExtractComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fancy <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> that turns a vector array into a scalar array by slicing out a single component of each vector.  <a href="classviskores_1_1cont_1_1ArrayHandleExtractComponent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleGroupVec.html">ArrayHandleGroupVec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fancy array handle that groups values into vectors.  <a href="classviskores_1_1cont_1_1ArrayHandleGroupVec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleGroupVecVariable.html">ArrayHandleGroupVecVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fancy array handle that groups values into vectors of different sizes.  <a href="classviskores_1_1cont_1_1ArrayHandleGroupVecVariable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleImplicit.html">ArrayHandleImplicit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> that computes values on the fly.  <a href="classviskores_1_1cont_1_1ArrayHandleImplicit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleIndex.html">ArrayHandleIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implicit array handle containing the its own indices.  <a href="classviskores_1_1cont_1_1ArrayHandleIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleMultiplexer.html">ArrayHandleMultiplexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> that can behave like several other handles.  <a href="classviskores_1_1cont_1_1ArrayHandleMultiplexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleOffsetsToNumComponents.html">ArrayHandleOffsetsToNumComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> that converts an array of offsets to an array of <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code> sizes.  <a href="classviskores_1_1cont_1_1ArrayHandleOffsetsToNumComponents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html">ArrayHandlePermutation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicitly permutes the values in an array.  <a href="classviskores_1_1cont_1_1ArrayHandlePermutation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRandomStandardNormal.html">ArrayHandleRandomStandardNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> that provides a source of random numbers with a standard normal distribution.  <a href="classviskores_1_1cont_1_1ArrayHandleRandomStandardNormal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRandomUniformBits.html">ArrayHandleRandomUniformBits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> that provides a source of random bits.  <a href="classviskores_1_1cont_1_1ArrayHandleRandomUniformBits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRandomUniformReal.html">ArrayHandleRandomUniformReal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> that provides a source of random numbers with uniform distribution.  <a href="classviskores_1_1cont_1_1ArrayHandleRandomUniformReal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRecombineVec.html">ArrayHandleRecombineVec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A grouping of <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleStride.html" title="An ArrayHandle that accesses a basic array with strides and offsets.">ArrayHandleStride</a></code>s into an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> of <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a></code>s.  <a href="classviskores_1_1cont_1_1ArrayHandleRecombineVec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleReverse.html">ArrayHandleReverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the order of an array, on demand.  <a href="classviskores_1_1cont_1_1ArrayHandleReverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html">ArrayHandleRuntimeVec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fancy array handle for a basic array with runtime selected vec size.  <a href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> that for Vecs stores each component in a separate physical array.  <a href="classviskores_1_1cont_1_1ArrayHandleSOA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleStride.html">ArrayHandleStride</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> that accesses a basic array with strides and offsets.  <a href="classviskores_1_1cont_1_1ArrayHandleStride.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSwizzle.html">ArrayHandleSwizzle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swizzle the components of the values in an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>.  <a href="classviskores_1_1cont_1_1ArrayHandleSwizzle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleTransform.html">ArrayHandleTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicitly transform values of one array to another with a functor.  <a href="classviskores_1_1cont_1_1ArrayHandleTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>ArrayHandleTransform&lt; ArrayHandleType, FunctorType, internal::NullFunctorType &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleUniformPointCoordinates.html">ArrayHandleUniformPointCoordinates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleUniformPointCoordinates.html" title="ArrayHandleUniformPointCoordinates is a specialization of ArrayHandle.">ArrayHandleUniformPointCoordinates</a> is a specialization of <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="classviskores_1_1cont_1_1ArrayHandleUniformPointCoordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleView.html">ArrayHandleView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provided a windowed view into a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a></code>.  <a href="classviskores_1_1cont_1_1ArrayHandleView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleXGCCoordinates.html">ArrayHandleXGCCoordinates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleZip.html">ArrayHandleZip</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleZip.html" title="ArrayHandleZip is a specialization of ArrayHandle.">ArrayHandleZip</a> is a specialization of <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="classviskores_1_1cont_1_1ArrayHandleZip.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayPortal.html">ArrayPortal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that points to and access and array of data.  <a href="classviskores_1_1cont_1_1ArrayPortal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayPortalToIterators.html">ArrayPortalToIterators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayPortalToIterators_3_01PortalType_00_01std_1_1false__type_01_4.html">ArrayPortalToIterators&lt; PortalType, std::false_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <code><a class="el" href="classviskores_1_1cont_1_1ArrayPortal.html" title="A class that points to and access and array of data.">ArrayPortal</a></code> to STL iterators.  <a href="classviskores_1_1cont_1_1ArrayPortalToIterators_3_01PortalType_00_01std_1_1false__type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayPortalToIterators_3_01PortalType_00_01std_1_1true__type_01_4.html">ArrayPortalToIterators&lt; PortalType, std::true_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1AssignerPartitionedDataSet.html">AssignerPartitionedDataSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigner for <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html" title="Comprises a set of viskores::cont::DataSet objects.">PartitionedDataSet</a> partitions.  <a href="classviskores_1_1cont_1_1AssignerPartitionedDataSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1AtomicArray.html">AtomicArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type list containing types that can be used with an <a class="el" href="classviskores_1_1cont_1_1AtomicArray.html" title="A type list containing types that can be used with an AtomicArray.">AtomicArray</a>.  <a href="classviskores_1_1cont_1_1AtomicArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1CellLocatorBase.html">CellLocatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all <code>CellLocator</code> classes.  <a href="classviskores_1_1cont_1_1CellLocatorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1CellLocatorBoundingIntervalHierarchy.html">CellLocatorBoundingIntervalHierarchy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cell locator that performs a recursive division of space.  <a href="classviskores_1_1cont_1_1CellLocatorBoundingIntervalHierarchy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1CellLocatorGeneral.html">CellLocatorGeneral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CellLocator that works generally well for any supported cell set.  <a href="classviskores_1_1cont_1_1CellLocatorGeneral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1CellLocatorPartitioned.html">CellLocatorPartitioned</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1CellLocatorRectilinearGrid.html">CellLocatorRectilinearGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cell locator optimized for finding cells in a rectilinear grid.  <a href="classviskores_1_1cont_1_1CellLocatorRectilinearGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1CellLocatorTwoLevel.html">CellLocatorTwoLevel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A locator that uses 2 nested levels of grids.  <a href="classviskores_1_1cont_1_1CellLocatorTwoLevel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1CellLocatorUniformBins.html">CellLocatorUniformBins</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A locator that uses a uniform grid.  <a href="classviskores_1_1cont_1_1CellLocatorUniformBins.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1CellLocatorUniformGrid.html">CellLocatorUniformGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cell locator optimized for finding cells in a uniform grid.  <a href="classviskores_1_1cont_1_1CellLocatorUniformGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1CellSet.html">CellSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the topological structure of the data in a <code><a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">DataSet</a></code>.  <a href="classviskores_1_1cont_1_1CellSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1CellSetExplicit.html">CellSetExplicit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an irregular collection of cells.  <a href="classviskores_1_1cont_1_1CellSetExplicit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1CellSetExtrude.html">CellSetExtrude</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a 3-dimensional extruded mesh representation.  <a href="classviskores_1_1cont_1_1CellSetExtrude.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1CellSetPermutation.html">CellSetPermutation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearranges the cells of one cell set to create another cell set.  <a href="classviskores_1_1cont_1_1CellSetPermutation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1CellSetPermutation_3_01CellSetPermutation_3_01CellSetType_00_01Permutat26d18082dae676e0bdc6e4256f6d5c9b.html">CellSetPermutation&lt; CellSetPermutation&lt; CellSetType, PermutationArrayHandleType1 &gt;, PermutationArrayHandleType2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1CellSetSingleType.html">CellSetSingleType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An explicit cell set with all cells of the same shape.  <a href="classviskores_1_1cont_1_1CellSetSingleType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">CellSetStructured</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a 1-, 2-, or 3-dimensional structured grid of points.  <a href="classviskores_1_1cont_1_1CellSetStructured.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ColorTable.html">ColorTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color Table for coloring arbitrary fields.  <a href="classviskores_1_1cont_1_1ColorTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ColorTableSamplesRGB.html">ColorTableSamplesRGB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color Sample Table used with <a class="el" href="classviskores_1_1cont_1_1ColorTable.html" title="Color Table for coloring arbitrary fields.">viskores::cont::ColorTable</a> for fast coloring.  <a href="classviskores_1_1cont_1_1ColorTableSamplesRGB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ColorTableSamplesRGBA.html">ColorTableSamplesRGBA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color Sample Table used with <a class="el" href="classviskores_1_1cont_1_1ColorTable.html" title="Color Table for coloring arbitrary fields.">viskores::cont::ColorTable</a> for fast coloring.  <a href="classviskores_1_1cont_1_1ColorTableSamplesRGBA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html">CoordinateSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages a coordinate system for a <code><a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">DataSet</a></code>.  <a href="classviskores_1_1cont_1_1CoordinateSystem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">DataSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains and manages the geometric data structures that Viskores operates on.  <a href="classviskores_1_1cont_1_1DataSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DataSetBuilderCurvilinear.html">DataSetBuilderCurvilinear</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DataSetBuilderExplicit.html">DataSetBuilderExplicit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DataSetBuilderExplicitIterative.html">DataSetBuilderExplicitIterative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to build a <code><a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">DataSet</a></code> by iteratively adding points and cells.  <a href="classviskores_1_1cont_1_1DataSetBuilderExplicitIterative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DataSetBuilderRectilinear.html">DataSetBuilderRectilinear</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DataSetBuilderUniform.html">DataSetBuilderUniform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">DeviceAdapterAlgorithm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing device adapter algorithms.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm_3_01viskores_1_1cont_1_1DeviceAdapterTagCuda_01_4.html">DeviceAdapterAlgorithm&lt; viskores::cont::DeviceAdapterTagCuda &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm_3_01viskores_1_1cont_1_1DeviceAdapterTagKokkos_01_4.html">DeviceAdapterAlgorithm&lt; viskores::cont::DeviceAdapterTagKokkos &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm_3_01viskores_1_1cont_1_1DeviceAdapterTagOpenMP_01_4.html">DeviceAdapterAlgorithm&lt; viskores::cont::DeviceAdapterTagOpenMP &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm_3_01viskores_1_1cont_1_1DeviceAdapterTagSerial_01_4.html">DeviceAdapterAlgorithm&lt; viskores::cont::DeviceAdapterTagSerial &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm_3_01viskores_1_1cont_1_1DeviceAdapterTagTBB_01_4.html">DeviceAdapterAlgorithm&lt; viskores::cont::DeviceAdapterTagTBB &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">DeviceAdapterId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object used to specify a device.  <a href="structviskores_1_1cont_1_1DeviceAdapterId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DeviceAdapterRuntimeDetector.html">DeviceAdapterRuntimeDetector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class providing a device-specific runtime support detector.  <a href="classviskores_1_1cont_1_1DeviceAdapterRuntimeDetector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DeviceAdapterRuntimeDetector_3_01viskores_1_1cont_1_1DeviceAdapterTagCuda_01_4.html">DeviceAdapterRuntimeDetector&lt; viskores::cont::DeviceAdapterTagCuda &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class providing a CUDA runtime support detector.  <a href="classviskores_1_1cont_1_1DeviceAdapterRuntimeDetector_3_01viskores_1_1cont_1_1DeviceAdapterTagCuda_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DeviceAdapterRuntimeDetector_3_01viskores_1_1cont_1_1DeviceAdapterTagKokkos_01_4.html">DeviceAdapterRuntimeDetector&lt; viskores::cont::DeviceAdapterTagKokkos &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this machine supports Kokkos backend.  <a href="classviskores_1_1cont_1_1DeviceAdapterRuntimeDetector_3_01viskores_1_1cont_1_1DeviceAdapterTagKokkos_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DeviceAdapterRuntimeDetector_3_01viskores_1_1cont_1_1DeviceAdapterTagOpenMP_01_4.html">DeviceAdapterRuntimeDetector&lt; viskores::cont::DeviceAdapterTagOpenMP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this machine supports Serial backend.  <a href="classviskores_1_1cont_1_1DeviceAdapterRuntimeDetector_3_01viskores_1_1cont_1_1DeviceAdapterTagOpenMP_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DeviceAdapterRuntimeDetector_3_01viskores_1_1cont_1_1DeviceAdapterTagSerial_01_4.html">DeviceAdapterRuntimeDetector&lt; viskores::cont::DeviceAdapterTagSerial &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this machine supports Serial backend.  <a href="classviskores_1_1cont_1_1DeviceAdapterRuntimeDetector_3_01viskores_1_1cont_1_1DeviceAdapterTagSerial_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DeviceAdapterRuntimeDetector_3_01viskores_1_1cont_1_1DeviceAdapterTagTBB_01_4.html">DeviceAdapterRuntimeDetector&lt; viskores::cont::DeviceAdapterTagTBB &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this machine supports Serial backend.  <a href="classviskores_1_1cont_1_1DeviceAdapterRuntimeDetector_3_01viskores_1_1cont_1_1DeviceAdapterTagTBB_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTag______.html">DeviceAdapterTag___</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag specifying the interface between the control and execution environments.  <a href="structviskores_1_1cont_1_1DeviceAdapterTag______.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">DeviceAdapterTagAny</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for a device adapter used to specify that any device may be used for an operation.  <a href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagCuda.html">DeviceAdapterTagCuda</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for a device adapter that uses a CUDA capable GPU device.  <a href="structviskores_1_1cont_1_1DeviceAdapterTagCuda.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagKokkos.html">DeviceAdapterTagKokkos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for a device adapter that uses the Kokkos library to run algorithms in parallel.  <a href="structviskores_1_1cont_1_1DeviceAdapterTagKokkos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagOpenMP.html">DeviceAdapterTagOpenMP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for a device adapter that uses OpenMP compiler extensions to run algorithms on multiple threads.  <a href="structviskores_1_1cont_1_1DeviceAdapterTagOpenMP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagSerial.html">DeviceAdapterTagSerial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for a device adapter that performs all computation on the same single thread as the control environment.  <a href="structviskores_1_1cont_1_1DeviceAdapterTagSerial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagTBB.html">DeviceAdapterTagTBB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for a device adapter that uses the Intel Threading Building Blocks library to run algorithms on multiple threads.  <a href="structviskores_1_1cont_1_1DeviceAdapterTagTBB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagUndefined.html">DeviceAdapterTagUndefined</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for a device adapter used to avoid specifying a device.  <a href="structviskores_1_1cont_1_1DeviceAdapterTagUndefined.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DeviceAdapterTimerImplementation.html">DeviceAdapterTimerImplementation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class providing a device-specific timer.  <a href="classviskores_1_1cont_1_1DeviceAdapterTimerImplementation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DeviceAdapterTimerImplementation_3_01viskores_1_1cont_1_1DeviceAdapterTagCuda_01_4.html">DeviceAdapterTimerImplementation&lt; viskores::cont::DeviceAdapterTagCuda &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classviskores_1_1cont_1_1DeviceAdapterTimerImplementation.html" title="Class providing a device-specific timer.">DeviceAdapterTimerImplementation</a> for CUDA CUDA contains its own high resolution timer that are able to track how long it takes to execute async kernels.  <a href="classviskores_1_1cont_1_1DeviceAdapterTimerImplementation_3_01viskores_1_1cont_1_1DeviceAdapterTagCuda_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DeviceAdapterTimerImplementation_3_01viskores_1_1cont_1_1DeviceAdapterTagTBB_01_4.html">DeviceAdapterTimerImplementation&lt; viskores::cont::DeviceAdapterTagTBB &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TBB contains its own high resolution timer.  <a href="classviskores_1_1cont_1_1DeviceAdapterTimerImplementation_3_01viskores_1_1cont_1_1DeviceAdapterTagTBB_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTraits.html">DeviceAdapterTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTraits_3_01viskores_1_1cont_1_1DeviceAdapterTagAny_01_4.html">DeviceAdapterTraits&lt; viskores::cont::DeviceAdapterTagAny &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTraits_3_01viskores_1_1cont_1_1DeviceAdapterTagCuda_01_4.html">DeviceAdapterTraits&lt; viskores::cont::DeviceAdapterTagCuda &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTraits_3_01viskores_1_1cont_1_1DeviceAdapterTagKokkos_01_4.html">DeviceAdapterTraits&lt; viskores::cont::DeviceAdapterTagKokkos &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTraits_3_01viskores_1_1cont_1_1DeviceAdapterTagOpenMP_01_4.html">DeviceAdapterTraits&lt; viskores::cont::DeviceAdapterTagOpenMP &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTraits_3_01viskores_1_1cont_1_1DeviceAdapterTagSerial_01_4.html">DeviceAdapterTraits&lt; viskores::cont::DeviceAdapterTagSerial &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTraits_3_01viskores_1_1cont_1_1DeviceAdapterTagTBB_01_4.html">DeviceAdapterTraits&lt; viskores::cont::DeviceAdapterTagTBB &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTraits_3_01viskores_1_1cont_1_1DeviceAdapterTagUndefined_01_4.html">DeviceAdapterTraits&lt; viskores::cont::DeviceAdapterTagUndefined &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DeviceTaskTypes.html">DeviceTaskTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class providing a device-specific support for selecting the optimal Task type for a given worklet.  <a href="classviskores_1_1cont_1_1DeviceTaskTypes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DeviceTaskTypes_3_01viskores_1_1cont_1_1DeviceAdapterTagCuda_01_4.html">DeviceTaskTypes&lt; viskores::cont::DeviceAdapterTagCuda &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DeviceTaskTypes_3_01viskores_1_1cont_1_1DeviceAdapterTagKokkos_01_4.html">DeviceTaskTypes&lt; viskores::cont::DeviceAdapterTagKokkos &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DeviceTaskTypes_3_01viskores_1_1cont_1_1DeviceAdapterTagOpenMP_01_4.html">DeviceTaskTypes&lt; viskores::cont::DeviceAdapterTagOpenMP &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DeviceTaskTypes_3_01viskores_1_1cont_1_1DeviceAdapterTagSerial_01_4.html">DeviceTaskTypes&lt; viskores::cont::DeviceAdapterTagSerial &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1DeviceTaskTypes_3_01viskores_1_1cont_1_1DeviceAdapterTagTBB_01_4.html">DeviceTaskTypes&lt; viskores::cont::DeviceAdapterTagTBB &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1EnvironmentTracker.html">EnvironmentTracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintain MPI controller, if any, for distributed operation.  <a href="classviskores_1_1cont_1_1EnvironmentTracker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Error.html">Error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The superclass of all exceptions thrown by any Viskores function or method.  <a href="classviskores_1_1cont_1_1Error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ErrorBadAllocation.html">ErrorBadAllocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is thrown when Viskores attempts to manipulate memory that it should not.  <a href="classviskores_1_1cont_1_1ErrorBadAllocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ErrorBadDevice.html">ErrorBadDevice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is thrown when Viskores performs an operation that is not supported on the current device.  <a href="classviskores_1_1cont_1_1ErrorBadDevice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ErrorBadType.html">ErrorBadType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is thrown when Viskores encounters data of a type that is incompatible with the current operation.  <a href="classviskores_1_1cont_1_1ErrorBadType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ErrorBadValue.html">ErrorBadValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is thrown when a Viskores function or method encounters an invalid value that inhibits progress.  <a href="classviskores_1_1cont_1_1ErrorBadValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ErrorExecution.html">ErrorExecution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is thrown in the control environment whenever an error occurs in the execution environment.  <a href="classviskores_1_1cont_1_1ErrorExecution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ErrorFilterExecution.html">ErrorFilterExecution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is primarily intended to filters to throw in the control environment to indicate an execution failure due to misconfiguration e.g.  <a href="classviskores_1_1cont_1_1ErrorFilterExecution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ErrorInternal.html">ErrorInternal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is thrown when Viskores detects an internal state that should never be reached.  <a href="classviskores_1_1cont_1_1ErrorInternal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ErrorUserAbort.html">ErrorUserAbort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is thrown when viskores detects a request for aborting execution in the current thread.  <a href="classviskores_1_1cont_1_1ErrorUserAbort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1ExecutionAndControlObjectBase.html">ExecutionAndControlObjectBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base <code><a class="el" href="structviskores_1_1cont_1_1ExecutionAndControlObjectBase.html" title="Base ExecutionAndControlObjectBase class.">ExecutionAndControlObjectBase</a></code> class.  <a href="structviskores_1_1cont_1_1ExecutionAndControlObjectBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1ExecutionObjectBase.html">ExecutionObjectBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base <code><a class="el" href="structviskores_1_1cont_1_1ExecutionObjectBase.html" title="Base ExecutionObjectBase for execution objects to inherit from so that you can use an arbitrary objec...">ExecutionObjectBase</a></code> for execution objects to inherit from so that you can use an arbitrary object as a parameter in an execution environment function.  <a href="structviskores_1_1cont_1_1ExecutionObjectBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Field.html">Field</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classviskores_1_1cont_1_1Field.html" title="A Field encapsulates an array on some piece of the mesh, such as the points, a cell set,...">Field</a></code> encapsulates an array on some piece of the mesh, such as the points, a cell set, a point logical dimension, or the whole mesh.  <a href="classviskores_1_1cont_1_1Field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1InitializeResult.html">InitializeResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1Invoker.html">Invoker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows launching any worklet without a dispatcher.  <a href="structviskores_1_1cont_1_1Invoker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1IsArrayHandleDiscard.html">IsArrayHandleDiscard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to determine if an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> type is an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleDiscard.html" title="ArrayHandleDiscard is a write-only array that discards all data written to it.">ArrayHandleDiscard</a>.  <a href="structviskores_1_1cont_1_1IsArrayHandleDiscard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>IsArrayHandleDiscard&lt; ArrayHandle&lt; T, internal::StorageTagDiscard &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1LogCondStream.html">LogCondStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally logs a message with a stream-like interface.  <a href="structviskores_1_1cont_1_1LogCondStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">PartitionedDataSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comprises a set of <code><a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">viskores::cont::DataSet</a></code> objects.  <a href="classviskores_1_1cont_1_1PartitionedDataSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1PointLocatorBase.html">PointLocatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all <code>PointLocator</code> classes.  <a href="classviskores_1_1cont_1_1PointLocatorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1PointLocatorSparseGrid.html">PointLocatorSparseGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A locator that bins points in a sparsely stored grid.  <a href="classviskores_1_1cont_1_1PointLocatorSparseGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1RuntimeDeviceInformation.html">RuntimeDeviceInformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that can be used to determine if a given device adapter is supported on the current machine at runtime.  <a href="classviskores_1_1cont_1_1RuntimeDeviceInformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1RuntimeDeviceTracker.html">RuntimeDeviceTracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classviskores_1_1cont_1_1RuntimeDeviceTracker.html" title="RuntimeDeviceTracker is the central location for determining which device adapter will be active for ...">RuntimeDeviceTracker</a> is the central location for determining which device adapter will be active for algorithm execution.  <a href="classviskores_1_1cont_1_1RuntimeDeviceTracker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ScopedRuntimeDeviceTracker.html">ScopedRuntimeDeviceTracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to create a scoped runtime device tracker object.  <a href="classviskores_1_1cont_1_1ScopedRuntimeDeviceTracker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTag______.html">StorageTag___</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag specifying client memory allocation.  <a href="structviskores_1_1cont_1_1StorageTag______.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">StorageTagBasic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for the basic implementation of a Storage object.  <a href="structviskores_1_1cont_1_1StorageTagBasic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagCartesianProduct.html">StorageTagCartesianProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagCast.html">StorageTagCast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagCompositeVec.html">StorageTagCompositeVec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1StorageTagConcatenate.html">StorageTagConcatenate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagConstant.html">StorageTagConstant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagCounting.html">StorageTagCounting</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1StorageTagExtractComponent.html">StorageTagExtractComponent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagGroupVec.html">StorageTagGroupVec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagGroupVecVariable.html">StorageTagGroupVecVariable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagImplicit.html">StorageTagImplicit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation for read-only implicit arrays.  <a href="structviskores_1_1cont_1_1StorageTagImplicit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagIndex.html">StorageTagIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagMultiplexer.html">StorageTagMultiplexer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagOffsetsToNumComponents.html">StorageTagOffsetsToNumComponents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagPermutation.html">StorageTagPermutation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1StorageTagReverse.html">StorageTagReverse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagRuntimeVec.html">StorageTagRuntimeVec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagSOA.html">StorageTagSOA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagStride.html">StorageTagStride</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagUniformPoints.html">StorageTagUniformPoints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagView.html">StorageTagView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagXGCCoordinates.html">StorageTagXGCCoordinates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1StorageTagZip.html">StorageTagZip</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that can be used to time operations in Viskores that might be occuring in parallel.  <a href="classviskores_1_1cont_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Token.html">Token</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A token to hold the scope of an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> or other object.  <a href="classviskores_1_1cont_1_1Token.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UncertainArrayHandle.html">UncertainArrayHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> of an uncertain value type and storage.  <a href="classviskores_1_1cont_1_1UncertainArrayHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UncertainCellSet.html">UncertainCellSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classviskores_1_1cont_1_1CellSet.html" title="Defines the topological structure of the data in a DataSet.">CellSet</a></code> of an uncertain type.  <a href="classviskores_1_1cont_1_1UncertainCellSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">UnknownArrayHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> of an unknown value type and storage.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownCellSet.html">UnknownCellSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classviskores_1_1cont_1_1CellSet.html" title="Defines the topological structure of the data in a DataSet.">CellSet</a> of an unknown type.  <a href="classviskores_1_1cont_1_1UnknownCellSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afcd29978dffdb19b96a869e701d32af5"><td class="memTemplParams" colspan="2">template&lt;typename List &gt; </td></tr>
<tr class="memitem:afcd29978dffdb19b96a869e701d32af5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#afcd29978dffdb19b96a869e701d32af5">ArrayHandleMultiplexerFromList</a> = <a class="el" href="namespaceviskores.html#a830688b5428ee181f86f094c1a94fdc0">viskores::ListApply</a>&lt; <a class="el" href="structviskores_1_1List.html">List</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandleMultiplexer.html">ArrayHandleMultiplexer</a> &gt;</td></tr>
<tr class="memdesc:afcd29978dffdb19b96a869e701d32af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a<code><a class="el" href="structviskores_1_1List.html" title="A template used to hold a list of types.">viskores::List</a></code> to an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleMultiplexer.html" title="An ArrayHandle that can behave like several other handles.">ArrayHandleMultiplexer</a></code>  <a href="namespaceviskores_1_1cont.html#afcd29978dffdb19b96a869e701d32af5">More...</a><br /></td></tr>
<tr class="separator:afcd29978dffdb19b96a869e701d32af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9a73fe8766c56470a6d2c2ce88c3ba"><td class="memTemplParams" colspan="2">template&lt;typename CellSetType , typename CoordinateSystemArrayType &gt; </td></tr>
<tr class="memitem:a7e9a73fe8766c56470a6d2c2ce88c3ba"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a7e9a73fe8766c56470a6d2c2ce88c3ba">CellLocatorChooser</a> = typename detail::CellLocatorChooserImpl&lt; CellSetType, CoordinateSystemArrayType &gt;::type</td></tr>
<tr class="memdesc:a7e9a73fe8766c56470a6d2c2ce88c3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template to select an appropriate CellLocator based on <a class="el" href="classviskores_1_1cont_1_1CellSet.html" title="Defines the topological structure of the data in a DataSet.">CellSet</a> type.  <a href="namespaceviskores_1_1cont.html#a7e9a73fe8766c56470a6d2c2ce88c3ba">More...</a><br /></td></tr>
<tr class="separator:a7e9a73fe8766c56470a6d2c2ce88c3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24a2e274d8048bfdde3e431a516290e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#aa24a2e274d8048bfdde3e431a516290e">CellSetListStructured1D</a> = <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt; <a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">viskores::cont::CellSetStructured</a>&lt; 1 &gt; &gt;</td></tr>
<tr class="separator:aa24a2e274d8048bfdde3e431a516290e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f088b2de20c00423f3033fb2a8f2e51"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a5f088b2de20c00423f3033fb2a8f2e51">CellSetListStructured2D</a> = <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt; <a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">viskores::cont::CellSetStructured</a>&lt; 2 &gt; &gt;</td></tr>
<tr class="separator:a5f088b2de20c00423f3033fb2a8f2e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcfb5a1a258985358a5b956dabbf204"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a7fcfb5a1a258985358a5b956dabbf204">CellSetListStructured3D</a> = <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt; <a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">viskores::cont::CellSetStructured</a>&lt; 3 &gt; &gt;</td></tr>
<tr class="separator:a7fcfb5a1a258985358a5b956dabbf204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77eb61ad4d044bd9fe05405b5ca3abeb"><td class="memTemplParams" colspan="2">template&lt;typename ShapesStorageTag  = VISKORES_DEFAULT_STORAGE_TAG, typename ConnectivityStorageTag  = VISKORES_DEFAULT_STORAGE_TAG, typename OffsetsStorageTag  = VISKORES_DEFAULT_STORAGE_TAG&gt; </td></tr>
<tr class="memitem:a77eb61ad4d044bd9fe05405b5ca3abeb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a77eb61ad4d044bd9fe05405b5ca3abeb">CellSetListExplicit</a> = <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt; <a class="el" href="classviskores_1_1cont_1_1CellSetExplicit.html">viskores::cont::CellSetExplicit</a>&lt; ShapesStorageTag, ConnectivityStorageTag, OffsetsStorageTag &gt; &gt;</td></tr>
<tr class="separator:a77eb61ad4d044bd9fe05405b5ca3abeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862ce7135e517fd824a60d7ba7c598f1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a862ce7135e517fd824a60d7ba7c598f1">CellSetListExplicitDefault</a> = <a class="el" href="namespaceviskores_1_1cont.html#a77eb61ad4d044bd9fe05405b5ca3abeb">CellSetListExplicit</a>&lt;&gt;</td></tr>
<tr class="separator:a862ce7135e517fd824a60d7ba7c598f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a515e9971f308b69b52543163186796"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a8a515e9971f308b69b52543163186796">CellSetListCommon</a> = <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt; <a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">viskores::cont::CellSetStructured</a>&lt; 2 &gt;, <a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">viskores::cont::CellSetStructured</a>&lt; 3 &gt;, <a class="el" href="classviskores_1_1cont_1_1CellSetExplicit.html">viskores::cont::CellSetExplicit</a>&lt;&gt;, <a class="el" href="classviskores_1_1cont_1_1CellSetSingleType.html">viskores::cont::CellSetSingleType</a>&lt;&gt; &gt;</td></tr>
<tr class="separator:a8a515e9971f308b69b52543163186796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb38573900a296909c75803d3935ea2f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#afb38573900a296909c75803d3935ea2f">CellSetListStructured</a> = <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt; <a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">viskores::cont::CellSetStructured</a>&lt; 2 &gt;, <a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">viskores::cont::CellSetStructured</a>&lt; 3 &gt; &gt;</td></tr>
<tr class="separator:afb38573900a296909c75803d3935ea2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf53004900f054346dbcc50299edb76"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#afbf53004900f054346dbcc50299edb76">CellSetListUnstructured</a> = <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt; <a class="el" href="classviskores_1_1cont_1_1CellSetExplicit.html">viskores::cont::CellSetExplicit</a>&lt;&gt;, <a class="el" href="classviskores_1_1cont_1_1CellSetSingleType.html">viskores::cont::CellSetSingleType</a>&lt;&gt; &gt;</td></tr>
<tr class="separator:afbf53004900f054346dbcc50299edb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc8ffe46050ffab138889b29ed32700"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a3fc8ffe46050ffab138889b29ed32700">DeviceAdapterListCommon</a> = <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagCuda.html">viskores::cont::DeviceAdapterTagCuda</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagTBB.html">viskores::cont::DeviceAdapterTagTBB</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagOpenMP.html">viskores::cont::DeviceAdapterTagOpenMP</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagKokkos.html">viskores::cont::DeviceAdapterTagKokkos</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagSerial.html">viskores::cont::DeviceAdapterTagSerial</a> &gt;</td></tr>
<tr class="separator:a3fc8ffe46050ffab138889b29ed32700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8915670663a9ef414cf88fce2f4e6ca6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a8915670663a9ef414cf88fce2f4e6ca6">DeviceAdapterNameType</a> = std::string</td></tr>
<tr class="separator:a8915670663a9ef414cf88fce2f4e6ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f11087403367d3de5e7ee55a7aabcd5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a6f11087403367d3de5e7ee55a7aabcd5">StorageListBasic</a> = <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt; <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt;</td></tr>
<tr class="separator:a6f11087403367d3de5e7ee55a7aabcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5191156a7eb1a9aa238cb82a11833ed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ac5191156a7eb1a9aa238cb82a11833ed">StorageListCommon</a> = <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt; <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagSOA.html">viskores::cont::StorageTagSOA</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagUniformPoints.html">viskores::cont::StorageTagUniformPoints</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagCartesianProduct.html">viskores::cont::StorageTagCartesianProduct</a>&lt; <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &gt;</td></tr>
<tr class="separator:ac5191156a7eb1a9aa238cb82a11833ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a80bf92eb36c625655d6326126877b590"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590">InitializeOptions</a> { <br />
&#160;&#160;<a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590a6adf97f83acf6453d4a6a4b1070f3754">InitializeOptions::None</a> = 0x00, 
<a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590aadcac17d2654c11145294ff6a76cfc44">InitializeOptions::RequireDevice</a> = 0x01, 
<a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590ae217e6295fba24735b5cd56a6a6a4e2d">InitializeOptions::DefaultAnyDevice</a> = 0x02, 
<a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590a36f67495191bac78113863c9790e885a">InitializeOptions::AddHelp</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590aa5340dde36f103eea8d59d3441ac5811">InitializeOptions::ErrorOnBadOption</a> = 0x08, 
<a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590a755f0c94a071bf91d1993896debd05ef">InitializeOptions::ErrorOnBadArgument</a> = 0x10, 
<a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590a2e979835dd62324f5bfe217449ba4974">InitializeOptions::Strict</a> = ErrorOnBadOption | ErrorOnBadArgument | AddHelp
<br />
 }</td></tr>
<tr class="separator:a80bf92eb36c625655d6326126877b590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee7b2f9f91bc845712d68320fb17b8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8">LogLevel</a> { <br />
&#160;&#160;<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8ad15305d7a4e34e02489c74a5ef542f36">LogLevel::Off</a> = -9, 
<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8a882384ec38ce8d9582b57e70861730e4">LogLevel::Fatal</a> = -3, 
<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8a902b0d55fddef6f8d651fe1035b7d4bd">LogLevel::Error</a> = -2, 
<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8a56525ae64d370c0b448ac0d60710ef17">LogLevel::Warn</a> = -1, 
<br />
&#160;&#160;<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8a4059b0251f66a18cb56f544728796875">LogLevel::Info</a> = 0, 
<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8a96de354fa3df933535d4859d07a3ba72">LogLevel::UserFirst</a> = 1, 
<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8ab42e4589c8b234eb92ef9f0d9ee2f2fa">LogLevel::UserLast</a> = 255, 
<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8a6bae7d6f71c134004e024e761e751d15">LogLevel::DevicesEnabled</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8aed0b6558cc63345b5c2457c8147f47d6">LogLevel::Perf</a>, 
<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8a3ae11403720653bf12a816b8cfe9ed9a">LogLevel::MemCont</a>, 
<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8a71eeffb381f7882ce5b712100a533d74">LogLevel::MemExec</a>, 
<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8acaaa1eac406602906c6240fb628d1667">LogLevel::MemTransfer</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8a1bda1e66fc4e1dc1d74e8714f1e6e5c8">LogLevel::KernelLaunches</a>, 
<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8a4cd9f3996d60790cd11c04f842ebc43c">LogLevel::Cast</a>, 
<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8a99234db2faf7adc90f0defc6fae1b05e">LogLevel::UserVerboseFirst</a> = 1024, 
<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8afc3dd3deb3795e4e427df8318a71b9a9">LogLevel::UserVerboseLast</a> = 2047
<br />
 }</td></tr>
<tr class="memdesc:a24ee7b2f9f91bc845712d68320fb17b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log levels for use with the logging macros.  <a href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8">More...</a><br /></td></tr>
<tr class="separator:a24ee7b2f9f91bc845712d68320fb17b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306be5a9721d7c501244123158b5b1e1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a306be5a9721d7c501244123158b5b1e1">RuntimeDeviceTrackerMode</a> { <a class="el" href="namespaceviskores_1_1cont.html#a306be5a9721d7c501244123158b5b1e1a9eb6b78a99cdb6ffd3d40d18621d9f80">RuntimeDeviceTrackerMode::Force</a>, 
<a class="el" href="namespaceviskores_1_1cont.html#a306be5a9721d7c501244123158b5b1e1a2faec1f9f8cc7f8f40d521c4dd574f49">RuntimeDeviceTrackerMode::Enable</a>, 
<a class="el" href="namespaceviskores_1_1cont.html#a306be5a9721d7c501244123158b5b1e1abcfaccebf745acfd5e75351095a5394a">RuntimeDeviceTrackerMode::Disable</a>
 }</td></tr>
<tr class="memdesc:a306be5a9721d7c501244123158b5b1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier used to specify whether to enable or disable a particular device.  <a href="namespaceviskores_1_1cont.html#a306be5a9721d7c501244123158b5b1e1">More...</a><br /></td></tr>
<tr class="separator:a306be5a9721d7c501244123158b5b1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5b3d4f4c88b6b4edc5c0e3ff9146455c"><td class="memTemplParams" colspan="2">template&lt;typename SourceArrayType , typename DestArrayType &gt; </td></tr>
<tr class="memitem:a5b3d4f4c88b6b4edc5c0e3ff9146455c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a5b3d4f4c88b6b4edc5c0e3ff9146455c">ArrayCopy</a> (const SourceArrayType &amp;source, DestArrayType &amp;destination)</td></tr>
<tr class="memdesc:a5b3d4f4c88b6b4edc5c0e3ff9146455c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a deep copy from one array to another array.  <a href="namespaceviskores_1_1cont.html#a5b3d4f4c88b6b4edc5c0e3ff9146455c">More...</a><br /></td></tr>
<tr class="separator:a5b3d4f4c88b6b4edc5c0e3ff9146455c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab385e62169c184753af6b86840f76a5f"><td class="memTemplParams" colspan="2">template&lt;typename SourceArrayType &gt; </td></tr>
<tr class="memitem:ab385e62169c184753af6b86840f76a5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ab385e62169c184753af6b86840f76a5f">ArrayCopy</a> (const SourceArrayType &amp;source, <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;destination)</td></tr>
<tr class="memdesc:ab385e62169c184753af6b86840f76a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a deep copy from one array to another array.  <a href="namespaceviskores_1_1cont.html#ab385e62169c184753af6b86840f76a5f">More...</a><br /></td></tr>
<tr class="separator:ab385e62169c184753af6b86840f76a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a61040a75e0fbb5c32e8726434cd2f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a19a61040a75e0fbb5c32e8726434cd2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a19a61040a75e0fbb5c32e8726434cd2f">ArrayCopy</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;)</td></tr>
<tr class="separator:a19a61040a75e0fbb5c32e8726434cd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10609ea9407d6237ca1dec8669a511f3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a10609ea9407d6237ca1dec8669a511f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a10609ea9407d6237ca1dec8669a511f3">ArrayCopyShallowIfPossible</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> source, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;destination)</td></tr>
<tr class="memdesc:a10609ea9407d6237ca1dec8669a511f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies from an unknown to a known array type.  <a href="namespaceviskores_1_1cont.html#a10609ea9407d6237ca1dec8669a511f3">More...</a><br /></td></tr>
<tr class="separator:a10609ea9407d6237ca1dec8669a511f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2331ab862cd8447e45bb20f465412857"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a2331ab862cd8447e45bb20f465412857"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleStride.html">viskores::cont::ArrayHandleStride</a>&lt; typename <a class="el" href="structviskores_1_1VecTraits.html">viskores::VecTraits</a>&lt; T &gt;::BaseComponentType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a2331ab862cd8447e45bb20f465412857">ArrayExtractComponent</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;src, <a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> componentIndex, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> allowCopy=<a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3">viskores::CopyFlag::On</a>)</td></tr>
<tr class="memdesc:a2331ab862cd8447e45bb20f465412857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pulls a component out of an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>.  <a href="namespaceviskores_1_1cont.html#a2331ab862cd8447e45bb20f465412857">More...</a><br /></td></tr>
<tr class="separator:a2331ab862cd8447e45bb20f465412857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58baac161a1677d77d99945a6a7d497"><td class="memTemplParams" colspan="2">template&lt;typename T , typename StorageT &gt; </td></tr>
<tr class="memitem:ad58baac161a1677d77d99945a6a7d497"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ad58baac161a1677d77d99945a6a7d497">printSummary_ArrayHandle</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageT &gt; &amp;array, std::ostream &amp;out, bool full=false)</td></tr>
<tr class="separator:ad58baac161a1677d77d99945a6a7d497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab389153eb025c4062d6795e07b078fc1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab389153eb025c4062d6795e07b078fc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html">viskores::cont::ArrayHandleBasic</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ab389153eb025c4062d6795e07b078fc1">make_ArrayHandle</a> (const T *array, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfValues, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> copy)</td></tr>
<tr class="memdesc:ab389153eb025c4062d6795e07b078fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function for creating an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> from a standard C array.  <a href="namespaceviskores_1_1cont.html#ab389153eb025c4062d6795e07b078fc1">More...</a><br /></td></tr>
<tr class="separator:ab389153eb025c4062d6795e07b078fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362cd3b4a393fefd5c052762314afb78"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a362cd3b4a393fefd5c052762314afb78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html">viskores::cont::ArrayHandleBasic</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a362cd3b4a393fefd5c052762314afb78">make_ArrayHandleMove</a> (T *&amp;array, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfValues, viskores::cont::internal::BufferInfo::Deleter deleter=internal::SimpleArrayDeleter&lt; T &gt;, viskores::cont::internal::BufferInfo::Reallocater reallocater=internal::SimpleArrayReallocater&lt; T &gt;)</td></tr>
<tr class="memdesc:a362cd3b4a393fefd5c052762314afb78"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function to move a user-allocated array into an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>.  <a href="namespaceviskores_1_1cont.html#a362cd3b4a393fefd5c052762314afb78">More...</a><br /></td></tr>
<tr class="separator:a362cd3b4a393fefd5c052762314afb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9323ddcf2f80047725681a7bb35da537"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:a9323ddcf2f80047725681a7bb35da537"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html">viskores::cont::ArrayHandleBasic</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a9323ddcf2f80047725681a7bb35da537">make_ArrayHandle</a> (const std::vector&lt; T, Allocator &gt; &amp;array, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> copy)</td></tr>
<tr class="memdesc:a9323ddcf2f80047725681a7bb35da537"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function for creating an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> from an std::vector.  <a href="namespaceviskores_1_1cont.html#a9323ddcf2f80047725681a7bb35da537">More...</a><br /></td></tr>
<tr class="separator:a9323ddcf2f80047725681a7bb35da537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb55bb08b6669c629d0ef7ad43a3ab23"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:acb55bb08b6669c629d0ef7ad43a3ab23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html">viskores::cont::ArrayHandleBasic</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#acb55bb08b6669c629d0ef7ad43a3ab23">make_ArrayHandleMove</a> (std::vector&lt; T, Allocator &gt; &amp;&amp;array)</td></tr>
<tr class="memdesc:acb55bb08b6669c629d0ef7ad43a3ab23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move an std::vector into an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="namespaceviskores_1_1cont.html#acb55bb08b6669c629d0ef7ad43a3ab23">More...</a><br /></td></tr>
<tr class="separator:acb55bb08b6669c629d0ef7ad43a3ab23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb669e86987deeb9ee85f1ffeb434cd2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:abb669e86987deeb9ee85f1ffeb434cd2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html">viskores::cont::ArrayHandleBasic</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#abb669e86987deeb9ee85f1ffeb434cd2">make_ArrayHandle</a> (std::vector&lt; T, Allocator &gt; &amp;&amp;array, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>)</td></tr>
<tr class="memdesc:abb669e86987deeb9ee85f1ffeb434cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move an std::vector into an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="namespaceviskores_1_1cont.html#abb669e86987deeb9ee85f1ffeb434cd2">More...</a><br /></td></tr>
<tr class="separator:abb669e86987deeb9ee85f1ffeb434cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a484115b48063a7f345e7a27ea99c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a25a484115b48063a7f345e7a27ea99c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html">viskores::cont::ArrayHandleBasic</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a25a484115b48063a7f345e7a27ea99c0">make_ArrayHandle</a> (std::initializer_list&lt; T &gt; &amp;&amp;values)</td></tr>
<tr class="memdesc:a25a484115b48063a7f345e7a27ea99c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> directly from an initializer list of values.  <a href="namespaceviskores_1_1cont.html#a25a484115b48063a7f345e7a27ea99c0">More...</a><br /></td></tr>
<tr class="separator:a25a484115b48063a7f345e7a27ea99c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0abef93dae84c5317296c84050bd715"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBitField.html">viskores::cont::ArrayHandleBitField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#af0abef93dae84c5317296c84050bd715">make_ArrayHandleBitField</a> (const <a class="el" href="classviskores_1_1cont_1_1BitField.html">viskores::cont::BitField</a> &amp;bitField)</td></tr>
<tr class="separator:af0abef93dae84c5317296c84050bd715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb895600746f9b97262587f3dcc08a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBitField.html">viskores::cont::ArrayHandleBitField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a7fb895600746f9b97262587f3dcc08a0">make_ArrayHandleBitField</a> (<a class="el" href="classviskores_1_1cont_1_1BitField.html">viskores::cont::BitField</a> &amp;&amp;bitField) noexcept</td></tr>
<tr class="separator:a7fb895600746f9b97262587f3dcc08a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5aeb92133992e3ffc354f6b6f269dea"><td class="memTemplParams" colspan="2">template&lt;typename FirstHandleType , typename SecondHandleType , typename ThirdHandleType &gt; </td></tr>
<tr class="memitem:ac5aeb92133992e3ffc354f6b6f269dea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleCartesianProduct.html">viskores::cont::ArrayHandleCartesianProduct</a>&lt; FirstHandleType, SecondHandleType, ThirdHandleType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ac5aeb92133992e3ffc354f6b6f269dea">make_ArrayHandleCartesianProduct</a> (const FirstHandleType &amp;first, const SecondHandleType &amp;second, const ThirdHandleType &amp;third)</td></tr>
<tr class="memdesc:ac5aeb92133992e3ffc354f6b6f269dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function for creating an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleCartesianProduct.html" title="ArrayHandleCartesianProduct is a specialization of ArrayHandle.">ArrayHandleCartesianProduct</a>.  <a href="namespaceviskores_1_1cont.html#ac5aeb92133992e3ffc354f6b6f269dea">More...</a><br /></td></tr>
<tr class="separator:ac5aeb92133992e3ffc354f6b6f269dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2762f91983309565e887ce3c7667887"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ArrayType &gt; </td></tr>
<tr class="memitem:ac2762f91983309565e887ce3c7667887"><td class="memTemplItemLeft" align="right" valign="top">detail::MakeArrayHandleCastImpl&lt; T, typename ArrayType::ValueType, ArrayType &gt;::ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ac2762f91983309565e887ce3c7667887">make_ArrayHandleCast</a> (const ArrayType &amp;array, const T &amp;=T())</td></tr>
<tr class="memdesc:ac2762f91983309565e887ce3c7667887"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>make_ArrayHandleCast</code> is convenience function to generate an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleCast.html" title="Cast the values of an array to the specified type, on demand.">ArrayHandleCast</a>.  <a href="namespaceviskores_1_1cont.html#ac2762f91983309565e887ce3c7667887">More...</a><br /></td></tr>
<tr class="separator:ac2762f91983309565e887ce3c7667887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f4f380f83d91f4f23135cddbc639f4"><td class="memTemplParams" colspan="2">template&lt;typename... ArrayTs&gt; </td></tr>
<tr class="memitem:a08f4f380f83d91f4f23135cddbc639f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleCompositeVector.html">ArrayHandleCompositeVector</a>&lt; ArrayTs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a08f4f380f83d91f4f23135cddbc639f4">make_ArrayHandleCompositeVector</a> (const ArrayTs &amp;... arrays)</td></tr>
<tr class="memdesc:a08f4f380f83d91f4f23135cddbc639f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a composite vector array from other arrays.  <a href="namespaceviskores_1_1cont.html#a08f4f380f83d91f4f23135cddbc639f4">More...</a><br /></td></tr>
<tr class="separator:a08f4f380f83d91f4f23135cddbc639f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5161f420baf91dfdfc2797479da9de"><td class="memTemplParams" colspan="2">template&lt;typename ArrayHandleType1 , typename ArrayHandleType2 &gt; </td></tr>
<tr class="memitem:a6a5161f420baf91dfdfc2797479da9de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleConcatenate.html">ArrayHandleConcatenate</a>&lt; ArrayHandleType1, ArrayHandleType2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a6a5161f420baf91dfdfc2797479da9de">make_ArrayHandleConcatenate</a> (const ArrayHandleType1 &amp;array1, const ArrayHandleType2 &amp;array2)</td></tr>
<tr class="separator:a6a5161f420baf91dfdfc2797479da9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762ec3cad2e668ed2b1f11f97827ddb8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a762ec3cad2e668ed2b1f11f97827ddb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleConstant.html">viskores::cont::ArrayHandleConstant</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a762ec3cad2e668ed2b1f11f97827ddb8">make_ArrayHandleConstant</a> (T value, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfValues)</td></tr>
<tr class="memdesc:a762ec3cad2e668ed2b1f11f97827ddb8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>make_ArrayHandleConstant</code> is convenience function to generate an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleImplicit.html" title="An ArrayHandle that computes values on the fly.">ArrayHandleImplicit</a>.  <a href="namespaceviskores_1_1cont.html#a762ec3cad2e668ed2b1f11f97827ddb8">More...</a><br /></td></tr>
<tr class="separator:a762ec3cad2e668ed2b1f11f97827ddb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423c4556489aefed41cfb30903d65b56"><td class="memTemplParams" colspan="2">template&lt;typename CountingValueType &gt; </td></tr>
<tr class="memitem:a423c4556489aefed41cfb30903d65b56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleCounting.html">viskores::cont::ArrayHandleCounting</a>&lt; CountingValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a423c4556489aefed41cfb30903d65b56">make_ArrayHandleCounting</a> (CountingValueType start, CountingValueType step, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> length)</td></tr>
<tr class="memdesc:a423c4556489aefed41cfb30903d65b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function for creating an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleCounting.html" title="ArrayHandleCounting is a specialization of ArrayHandle.">ArrayHandleCounting</a>.  <a href="namespaceviskores_1_1cont.html#a423c4556489aefed41cfb30903d65b56">More...</a><br /></td></tr>
<tr class="separator:a423c4556489aefed41cfb30903d65b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c05dd5e0089f45842c6d538927d67ba"><td class="memTemplParams" colspan="2">template&lt;typename DecoratorImplT , typename... ArrayTs&gt; </td></tr>
<tr class="memitem:a7c05dd5e0089f45842c6d538927d67ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleDecorator.html">ArrayHandleDecorator</a>&lt; typename std::decay&lt; DecoratorImplT &gt;::type, typename std::decay&lt; ArrayTs &gt;::type... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a7c05dd5e0089f45842c6d538927d67ba">make_ArrayHandleDecorator</a> (<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numValues, DecoratorImplT &amp;&amp;f, ArrayTs &amp;&amp;... arrays)</td></tr>
<tr class="memdesc:a7c05dd5e0089f45842c6d538927d67ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleDecorator.html" title="A fancy ArrayHandle that can be used to modify the results from one or more source ArrayHandle.">ArrayHandleDecorator</a> with the specified number of values that uses the provided DecoratorImplT and source ArrayHandles.  <a href="namespaceviskores_1_1cont.html#a7c05dd5e0089f45842c6d538927d67ba">More...</a><br /></td></tr>
<tr class="separator:a7c05dd5e0089f45842c6d538927d67ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf74bea375e0d1896932e1edfead56ed"><td class="memTemplParams" colspan="2">template&lt;typename ArrayHandleType &gt; </td></tr>
<tr class="memitem:aaf74bea375e0d1896932e1edfead56ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleExtractComponent.html">ArrayHandleExtractComponent</a>&lt; ArrayHandleType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#aaf74bea375e0d1896932e1edfead56ed">make_ArrayHandleExtractComponent</a> (const ArrayHandleType &amp;array, <a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> component)</td></tr>
<tr class="memdesc:aaf74bea375e0d1896932e1edfead56ed"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>make_ArrayHandleExtractComponent</code> is convenience function to generate an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleExtractComponent.html" title="A fancy ArrayHandle that turns a vector array into a scalar array by slicing out a single component o...">ArrayHandleExtractComponent</a></code>.  <a href="namespaceviskores_1_1cont.html#aaf74bea375e0d1896932e1edfead56ed">More...</a><br /></td></tr>
<tr class="separator:aaf74bea375e0d1896932e1edfead56ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502d3615a4354e56f0dbf518a7e17a8f"><td class="memTemplParams" colspan="2">template&lt;viskores::IdComponent NUM_COMPONENTS, typename ArrayHandleType &gt; </td></tr>
<tr class="memitem:a502d3615a4354e56f0dbf518a7e17a8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleGroupVec.html">viskores::cont::ArrayHandleGroupVec</a>&lt; ArrayHandleType, NUM_COMPONENTS &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a502d3615a4354e56f0dbf518a7e17a8f">make_ArrayHandleGroupVec</a> (const ArrayHandleType &amp;array)</td></tr>
<tr class="memdesc:a502d3615a4354e56f0dbf518a7e17a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>make_ArrayHandleGroupVec</code> is convenience function to generate an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleGroupVec.html" title="Fancy array handle that groups values into vectors.">ArrayHandleGroupVec</a>.  <a href="namespaceviskores_1_1cont.html#a502d3615a4354e56f0dbf518a7e17a8f">More...</a><br /></td></tr>
<tr class="separator:a502d3615a4354e56f0dbf518a7e17a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c24c18f8d28f0f9fd1b1a2a8b579e8a"><td class="memTemplParams" colspan="2">template&lt;typename ComponentsArrayHandleType , typename OffsetsArrayHandleType &gt; </td></tr>
<tr class="memitem:a1c24c18f8d28f0f9fd1b1a2a8b579e8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleGroupVecVariable.html">viskores::cont::ArrayHandleGroupVecVariable</a>&lt; ComponentsArrayHandleType, OffsetsArrayHandleType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a1c24c18f8d28f0f9fd1b1a2a8b579e8a">make_ArrayHandleGroupVecVariable</a> (const ComponentsArrayHandleType &amp;componentsArray, const OffsetsArrayHandleType &amp;offsetsArray)</td></tr>
<tr class="memdesc:a1c24c18f8d28f0f9fd1b1a2a8b579e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>make_ArrayHandleGroupVecVariable</code> is convenience function to generate an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleGroupVecVariable.html" title="Fancy array handle that groups values into vectors of different sizes.">ArrayHandleGroupVecVariable</a>.  <a href="namespaceviskores_1_1cont.html#a1c24c18f8d28f0f9fd1b1a2a8b579e8a">More...</a><br /></td></tr>
<tr class="separator:a1c24c18f8d28f0f9fd1b1a2a8b579e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce304a7b9162d2ce78e4a2763c7f79e"><td class="memTemplParams" colspan="2">template&lt;typename FunctorType &gt; </td></tr>
<tr class="memitem:a6ce304a7b9162d2ce78e4a2763c7f79e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleImplicit.html">viskores::cont::ArrayHandleImplicit</a>&lt; FunctorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a6ce304a7b9162d2ce78e4a2763c7f79e">make_ArrayHandleImplicit</a> (FunctorType functor, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> length)</td></tr>
<tr class="memdesc:a6ce304a7b9162d2ce78e4a2763c7f79e"><td class="mdescLeft">&#160;</td><td class="mdescRight">make_ArrayHandleImplicit is convenience function to generate an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleImplicit.html" title="An ArrayHandle that computes values on the fly.">ArrayHandleImplicit</a>.  <a href="namespaceviskores_1_1cont.html#a6ce304a7b9162d2ce78e4a2763c7f79e">More...</a><br /></td></tr>
<tr class="separator:a6ce304a7b9162d2ce78e4a2763c7f79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9887dd8d2e5ff864172aa3ef52234767"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleIndex.html">viskores::cont::ArrayHandleIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a9887dd8d2e5ff864172aa3ef52234767">make_ArrayHandleIndex</a> (<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> length)</td></tr>
<tr class="memdesc:a9887dd8d2e5ff864172aa3ef52234767"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function for creating an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleIndex.html" title="An implicit array handle containing the its own indices.">ArrayHandleIndex</a>.  <a href="namespaceviskores_1_1cont.html#a9887dd8d2e5ff864172aa3ef52234767">More...</a><br /></td></tr>
<tr class="separator:a9887dd8d2e5ff864172aa3ef52234767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca556942a4196d16c27174f3b60069d"><td class="memTemplParams" colspan="2">template&lt;typename OffsetsStorageTag &gt; </td></tr>
<tr class="memitem:a9ca556942a4196d16c27174f3b60069d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleOffsetsToNumComponents.html">viskores::cont::ArrayHandleOffsetsToNumComponents</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, OffsetsStorageTag &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a9ca556942a4196d16c27174f3b60069d">make_ArrayHandleOffsetsToNumComponents</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, OffsetsStorageTag &gt; &amp;array)</td></tr>
<tr class="separator:a9ca556942a4196d16c27174f3b60069d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f70c9d16e932e0b46ad71450a12d62"><td class="memTemplParams" colspan="2">template&lt;typename IndexArrayHandleType , typename ValueArrayHandleType &gt; </td></tr>
<tr class="memitem:ae6f70c9d16e932e0b46ad71450a12d62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html">viskores::cont::ArrayHandlePermutation</a>&lt; IndexArrayHandleType, ValueArrayHandleType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ae6f70c9d16e932e0b46ad71450a12d62">make_ArrayHandlePermutation</a> (IndexArrayHandleType indexArray, ValueArrayHandleType valueArray)</td></tr>
<tr class="memdesc:ae6f70c9d16e932e0b46ad71450a12d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">make_ArrayHandleTransform is convenience function to generate an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleTransform.html" title="Implicitly transform values of one array to another with a functor.">ArrayHandleTransform</a>.  <a href="namespaceviskores_1_1cont.html#ae6f70c9d16e932e0b46ad71450a12d62">More...</a><br /></td></tr>
<tr class="separator:ae6f70c9d16e932e0b46ad71450a12d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e58e74bea31ae73b4dbdb493d0bbc83"><td class="memTemplParams" colspan="2">template&lt;typename HandleType &gt; </td></tr>
<tr class="memitem:a5e58e74bea31ae73b4dbdb493d0bbc83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleReverse.html">ArrayHandleReverse</a>&lt; HandleType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a5e58e74bea31ae73b4dbdb493d0bbc83">make_ArrayHandleReverse</a> (const HandleType &amp;handle)</td></tr>
<tr class="memdesc:a5e58e74bea31ae73b4dbdb493d0bbc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">make_ArrayHandleReverse is convenience function to generate an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleReverse.html" title="Reverse the order of an array, on demand.">ArrayHandleReverse</a>.  <a href="namespaceviskores_1_1cont.html#a5e58e74bea31ae73b4dbdb493d0bbc83">More...</a><br /></td></tr>
<tr class="separator:a5e58e74bea31ae73b4dbdb493d0bbc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4c96a0f036b707756c9f27e8d0de35"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb4c96a0f036b707756c9f27e8d0de35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#afb4c96a0f036b707756c9f27e8d0de35">make_ArrayHandleRuntimeVec</a> (<a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> numComponents, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;componentsArray=<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt;{})</td></tr>
<tr class="memdesc:afb4c96a0f036b707756c9f27e8d0de35"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>make_ArrayHandleRuntimeVec</code> is convenience function to generate an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">ArrayHandleRuntimeVec</a></code>.  <a href="namespaceviskores_1_1cont.html#afb4c96a0f036b707756c9f27e8d0de35">More...</a><br /></td></tr>
<tr class="separator:afb4c96a0f036b707756c9f27e8d0de35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f8c501625f7b7ccb60bfa0f63f6974"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa7f8c501625f7b7ccb60bfa0f63f6974"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#aa7f8c501625f7b7ccb60bfa0f63f6974">make_ArrayHandleRuntimeVec</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;componentsArray)</td></tr>
<tr class="memdesc:aa7f8c501625f7b7ccb60bfa0f63f6974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a basic array handle into an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">ArrayHandleRuntimeVec</a></code> with 1 component.  <a href="namespaceviskores_1_1cont.html#aa7f8c501625f7b7ccb60bfa0f63f6974">More...</a><br /></td></tr>
<tr class="separator:aa7f8c501625f7b7ccb60bfa0f63f6974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f34aba4b592cbbd74d2bc358e5199e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60f34aba4b592cbbd74d2bc358e5199e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a60f34aba4b592cbbd74d2bc358e5199e">make_ArrayHandleRuntimeVec</a> (<a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> numComponents, const T *array, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfValues, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> copy)</td></tr>
<tr class="memdesc:a60f34aba4b592cbbd74d2bc358e5199e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function for creating an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">ArrayHandleRuntimeVec</a></code> from a standard C array.  <a href="namespaceviskores_1_1cont.html#a60f34aba4b592cbbd74d2bc358e5199e">More...</a><br /></td></tr>
<tr class="separator:a60f34aba4b592cbbd74d2bc358e5199e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74811cb476e0c08eda2811191e445a14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74811cb476e0c08eda2811191e445a14"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a74811cb476e0c08eda2811191e445a14">make_ArrayHandleRuntimeVecMove</a> (<a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> numComponents, T *&amp;array, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfValues, viskores::cont::internal::BufferInfo::Deleter deleter=internal::SimpleArrayDeleter&lt; T &gt;, viskores::cont::internal::BufferInfo::Reallocater reallocater=internal::SimpleArrayReallocater&lt; T &gt;)</td></tr>
<tr class="memdesc:a74811cb476e0c08eda2811191e445a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function to move a user-allocated array into an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">ArrayHandleRuntimeVec</a></code>.  <a href="namespaceviskores_1_1cont.html#a74811cb476e0c08eda2811191e445a14">More...</a><br /></td></tr>
<tr class="separator:a74811cb476e0c08eda2811191e445a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9230be84e00a75591dbfc2dde41bf060"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:a9230be84e00a75591dbfc2dde41bf060"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a9230be84e00a75591dbfc2dde41bf060">make_ArrayHandleRuntimeVec</a> (<a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> numComponents, const std::vector&lt; T, Allocator &gt; &amp;array, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> copy)</td></tr>
<tr class="memdesc:a9230be84e00a75591dbfc2dde41bf060"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function for creating an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">ArrayHandleRuntimeVec</a></code> from an <code>std::vector</code>.  <a href="namespaceviskores_1_1cont.html#a9230be84e00a75591dbfc2dde41bf060">More...</a><br /></td></tr>
<tr class="separator:a9230be84e00a75591dbfc2dde41bf060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c314e346fa64e6c635b825a1e65a2e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:a30c314e346fa64e6c635b825a1e65a2e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a30c314e346fa64e6c635b825a1e65a2e">make_ArrayHandleRuntimeVecMove</a> (<a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> numComponents, std::vector&lt; T, Allocator &gt; &amp;&amp;array)</td></tr>
<tr class="memdesc:a30c314e346fa64e6c635b825a1e65a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move an <code>std::vector</code> into an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">ArrayHandleRuntimeVec</a></code>.  <a href="namespaceviskores_1_1cont.html#a30c314e346fa64e6c635b825a1e65a2e">More...</a><br /></td></tr>
<tr class="separator:a30c314e346fa64e6c635b825a1e65a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7460b16cb15a0ce5d6123e59162a0219"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:a7460b16cb15a0ce5d6123e59162a0219"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a7460b16cb15a0ce5d6123e59162a0219">make_ArrayHandleRuntimeVec</a> (<a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> numComponents, std::vector&lt; T, Allocator &gt; &amp;&amp;array, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>)</td></tr>
<tr class="separator:a7460b16cb15a0ce5d6123e59162a0219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac73251dfcee427a6d163156caa9a30"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a3ac73251dfcee427a6d163156caa9a30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a3ac73251dfcee427a6d163156caa9a30">make_ArrayHandleSOA</a> (std::initializer_list&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; typename <a class="el" href="structviskores_1_1VecTraits.html">viskores::VecTraits</a>&lt; ValueType &gt;::ComponentType, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt;&gt; &amp;&amp;componentArrays)</td></tr>
<tr class="memdesc:a3ac73251dfcee427a6d163156caa9a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">viskores::cont::ArrayHandleSOA</a></code> with an initializer list of array handles.  <a href="namespaceviskores_1_1cont.html#a3ac73251dfcee427a6d163156caa9a30">More...</a><br /></td></tr>
<tr class="separator:a3ac73251dfcee427a6d163156caa9a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb1178562784791f1c2c0263a9485f0"><td class="memTemplParams" colspan="2">template&lt;typename ComponentType , typename... RemainingArrays&gt; </td></tr>
<tr class="memitem:abdb1178562784791f1c2c0263a9485f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; ComponentType, internal::VecSizeFromRemaining&lt; RemainingArrays... &gt;::value &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#abdb1178562784791f1c2c0263a9485f0">make_ArrayHandleSOA</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; ComponentType, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;componentArray0, const RemainingArrays &amp;... componentArrays)</td></tr>
<tr class="memdesc:abdb1178562784791f1c2c0263a9485f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">viskores::cont::ArrayHandleSOA</a></code> with a number of array handles.  <a href="namespaceviskores_1_1cont.html#abdb1178562784791f1c2c0263a9485f0">More...</a><br /></td></tr>
<tr class="separator:abdb1178562784791f1c2c0263a9485f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90d3e452ad278deedc88aecfead4927"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ac90d3e452ad278deedc88aecfead4927"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ac90d3e452ad278deedc88aecfead4927">make_ArrayHandleSOA</a> (std::initializer_list&lt; std::vector&lt; typename <a class="el" href="structviskores_1_1VecTraits.html">viskores::VecTraits</a>&lt; ValueType &gt;::ComponentType &gt;&gt; &amp;&amp;componentVectors)</td></tr>
<tr class="memdesc:ac90d3e452ad278deedc88aecfead4927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">viskores::cont::ArrayHandleSOA</a></code> with an initializer list of <code>std::vector</code>.  <a href="namespaceviskores_1_1cont.html#ac90d3e452ad278deedc88aecfead4927">More...</a><br /></td></tr>
<tr class="separator:ac90d3e452ad278deedc88aecfead4927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbf4a34a2143f4a63d5f80e2a8a6de1"><td class="memTemplParams" colspan="2">template&lt;typename ComponentType , typename... RemainingVectors&gt; </td></tr>
<tr class="memitem:abdbf4a34a2143f4a63d5f80e2a8a6de1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; ComponentType, internal::VecSizeFromRemaining&lt; RemainingVectors... &gt;::value &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#abdbf4a34a2143f4a63d5f80e2a8a6de1">make_ArrayHandleSOA</a> (<a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> copy, const std::vector&lt; ComponentType &gt; &amp;vector0, RemainingVectors &amp;&amp;... componentVectors)</td></tr>
<tr class="memdesc:abdbf4a34a2143f4a63d5f80e2a8a6de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">viskores::cont::ArrayHandleSOA</a></code> with a number of <code>std::vector</code>.  <a href="namespaceviskores_1_1cont.html#abdbf4a34a2143f4a63d5f80e2a8a6de1">More...</a><br /></td></tr>
<tr class="separator:abdbf4a34a2143f4a63d5f80e2a8a6de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4229bc02f8fa9e17109c31ecb4b2ce1b"><td class="memTemplParams" colspan="2">template&lt;typename ComponentType , typename... RemainingVectors&gt; </td></tr>
<tr class="memitem:a4229bc02f8fa9e17109c31ecb4b2ce1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; ComponentType, internal::VecSizeFromRemaining&lt; RemainingVectors... &gt;::value &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a4229bc02f8fa9e17109c31ecb4b2ce1b">make_ArrayHandleSOA</a> (<a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> copy, std::vector&lt; ComponentType &gt; &amp;&amp;vector0, RemainingVectors &amp;&amp;... componentVectors)</td></tr>
<tr class="memdesc:a4229bc02f8fa9e17109c31ecb4b2ce1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">viskores::cont::ArrayHandleSOA</a></code> with a number of <code>std::vector</code>.  <a href="namespaceviskores_1_1cont.html#a4229bc02f8fa9e17109c31ecb4b2ce1b">More...</a><br /></td></tr>
<tr class="separator:a4229bc02f8fa9e17109c31ecb4b2ce1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b92f2fe6c3c23da7071c725e9aaceb4"><td class="memTemplParams" colspan="2">template&lt;typename ComponentType , typename... RemainingVectors&gt; </td></tr>
<tr class="memitem:a9b92f2fe6c3c23da7071c725e9aaceb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; ComponentType, internal::VecSizeFromRemaining&lt; RemainingVectors... &gt;::value &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a9b92f2fe6c3c23da7071c725e9aaceb4">make_ArrayHandleSOAMove</a> (std::vector&lt; ComponentType &gt; &amp;&amp;vector0, RemainingVectors &amp;&amp;... componentVectors)</td></tr>
<tr class="memdesc:a9b92f2fe6c3c23da7071c725e9aaceb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">viskores::cont::ArrayHandleSOA</a></code> with a number of <code>std::vector</code>.  <a href="namespaceviskores_1_1cont.html#a9b92f2fe6c3c23da7071c725e9aaceb4">More...</a><br /></td></tr>
<tr class="separator:a9b92f2fe6c3c23da7071c725e9aaceb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f86d8c702047107966120dd6522a288"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a2f86d8c702047107966120dd6522a288"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a2f86d8c702047107966120dd6522a288">make_ArrayHandleSOA</a> (std::initializer_list&lt; const typename <a class="el" href="structviskores_1_1VecTraits.html">viskores::VecTraits</a>&lt; ValueType &gt;::ComponentType * &gt; &amp;&amp;componentVectors, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> length, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> copy)</td></tr>
<tr class="memdesc:a2f86d8c702047107966120dd6522a288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">viskores::cont::ArrayHandleSOA</a></code> with an initializer list of C arrays.  <a href="namespaceviskores_1_1cont.html#a2f86d8c702047107966120dd6522a288">More...</a><br /></td></tr>
<tr class="separator:a2f86d8c702047107966120dd6522a288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9640cfedbe3a120ed1d7d312cb61261"><td class="memTemplParams" colspan="2">template&lt;typename ComponentType , typename... RemainingArrays&gt; </td></tr>
<tr class="memitem:af9640cfedbe3a120ed1d7d312cb61261"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; ComponentType, internal::VecSizeFromRemaining&lt; RemainingArrays... &gt;::value &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#af9640cfedbe3a120ed1d7d312cb61261">make_ArrayHandleSOA</a> (<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> length, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> copy, const ComponentType *array0, const RemainingArrays *... componentArrays)</td></tr>
<tr class="memdesc:af9640cfedbe3a120ed1d7d312cb61261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">viskores::cont::ArrayHandleSOA</a></code> with a number of C arrays.  <a href="namespaceviskores_1_1cont.html#af9640cfedbe3a120ed1d7d312cb61261">More...</a><br /></td></tr>
<tr class="separator:af9640cfedbe3a120ed1d7d312cb61261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a297b0cd25db294a5a95b64d684d834"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a297b0cd25db294a5a95b64d684d834"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleStride.html">viskores::cont::ArrayHandleStride</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a7a297b0cd25db294a5a95b64d684d834">make_ArrayHandleStride</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;array, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numValues, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> stride, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> offset, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> modulo=0, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> divisor=1)</td></tr>
<tr class="memdesc:a7a297b0cd25db294a5a95b64d684d834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array by adding a stride to a basic array.  <a href="namespaceviskores_1_1cont.html#a7a297b0cd25db294a5a95b64d684d834">More...</a><br /></td></tr>
<tr class="separator:a7a297b0cd25db294a5a95b64d684d834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcfc2146936cf0f210373192492e29f"><td class="memTemplParams" colspan="2">template&lt;typename ArrayHandleType , viskores::IdComponent OutSize&gt; </td></tr>
<tr class="memitem:a5fcfc2146936cf0f210373192492e29f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSwizzle.html">ArrayHandleSwizzle</a>&lt; ArrayHandleType, OutSize &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a5fcfc2146936cf0f210373192492e29f">make_ArrayHandleSwizzle</a> (const ArrayHandleType &amp;array, const <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; <a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>, OutSize &gt; &amp;map)</td></tr>
<tr class="memdesc:a5fcfc2146936cf0f210373192492e29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSwizzle.html" title="Swizzle the components of the values in an ArrayHandle.">ArrayHandleSwizzle</a></code> from a provided array and swizzle map.  <a href="namespaceviskores_1_1cont.html#a5fcfc2146936cf0f210373192492e29f">More...</a><br /></td></tr>
<tr class="separator:a5fcfc2146936cf0f210373192492e29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e6299c6fe97d558a7ebf3bb02b71a4"><td class="memTemplParams" colspan="2">template&lt;typename ArrayHandleType , typename... SwizzleIndexTypes&gt; </td></tr>
<tr class="memitem:a15e6299c6fe97d558a7ebf3bb02b71a4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a15e6299c6fe97d558a7ebf3bb02b71a4">make_ArrayHandleSwizzle</a> (const ArrayHandleType &amp;array, <a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> swizzleIndex0, SwizzleIndexTypes... swizzleIndices)</td></tr>
<tr class="memdesc:a15e6299c6fe97d558a7ebf3bb02b71a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSwizzle.html" title="Swizzle the components of the values in an ArrayHandle.">ArrayHandleSwizzle</a></code> from a provided array and swizzle map.  <a href="namespaceviskores_1_1cont.html#a15e6299c6fe97d558a7ebf3bb02b71a4">More...</a><br /></td></tr>
<tr class="separator:a15e6299c6fe97d558a7ebf3bb02b71a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7bada847b66a4d496009aea0efecd8"><td class="memTemplParams" colspan="2">template&lt;typename HandleType , typename FunctorType &gt; </td></tr>
<tr class="memitem:a7b7bada847b66a4d496009aea0efecd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleTransform.html">viskores::cont::ArrayHandleTransform</a>&lt; HandleType, FunctorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a7b7bada847b66a4d496009aea0efecd8">make_ArrayHandleTransform</a> (HandleType handle, FunctorType functor)</td></tr>
<tr class="memdesc:a7b7bada847b66a4d496009aea0efecd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">make_ArrayHandleTransform is convenience function to generate an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleTransform.html" title="Implicitly transform values of one array to another with a functor.">ArrayHandleTransform</a>.  <a href="namespaceviskores_1_1cont.html#a7b7bada847b66a4d496009aea0efecd8">More...</a><br /></td></tr>
<tr class="separator:a7b7bada847b66a4d496009aea0efecd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac93e16240fcbf343100d41df45eda84"><td class="memTemplParams" colspan="2">template&lt;typename HandleType , typename FunctorType , typename InverseFunctorType &gt; </td></tr>
<tr class="memitem:aac93e16240fcbf343100d41df45eda84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleTransform.html">viskores::cont::ArrayHandleTransform</a>&lt; HandleType, FunctorType, InverseFunctorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#aac93e16240fcbf343100d41df45eda84">make_ArrayHandleTransform</a> (HandleType handle, FunctorType functor, InverseFunctorType inverseFunctor)</td></tr>
<tr class="separator:aac93e16240fcbf343100d41df45eda84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac746fa9b831698817aa8637d2be6d4f3"><td class="memTemplParams" colspan="2">template&lt;typename ArrayHandleType &gt; </td></tr>
<tr class="memitem:ac746fa9b831698817aa8637d2be6d4f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleView.html">ArrayHandleView</a>&lt; ArrayHandleType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ac746fa9b831698817aa8637d2be6d4f3">make_ArrayHandleView</a> (const ArrayHandleType &amp;array, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> startIndex, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numValues)</td></tr>
<tr class="memdesc:ac746fa9b831698817aa8637d2be6d4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleView.html" title="Provided a windowed view into a viskores::cont::ArrayHandle.">viskores::cont::ArrayHandleView</a></code> from a source array.  <a href="namespaceviskores_1_1cont.html#ac746fa9b831698817aa8637d2be6d4f3">More...</a><br /></td></tr>
<tr class="separator:ac746fa9b831698817aa8637d2be6d4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97deb2a2a1e9bc33362a2cd9057e5261"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97deb2a2a1e9bc33362a2cd9057e5261"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleXGCCoordinates.html">viskores::cont::ArrayHandleXGCCoordinates</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a97deb2a2a1e9bc33362a2cd9057e5261">make_ArrayHandleXGCCoordinates</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T &gt; &amp;arrHandle, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfPlanesOwned, bool cylindrical, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfPlanes=-1, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> planeStartId=0)</td></tr>
<tr class="separator:a97deb2a2a1e9bc33362a2cd9057e5261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7172af4530c559215b2f94870d3b8b8e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7172af4530c559215b2f94870d3b8b8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleXGCCoordinates.html">viskores::cont::ArrayHandleXGCCoordinates</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a7172af4530c559215b2f94870d3b8b8e">make_ArrayHandleXGCCoordinates</a> (const T *array, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> length, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfPlanesOwned, bool cylindrical, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfPlanes=-1, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> planeStartId=0, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> copy=<a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a>)</td></tr>
<tr class="separator:a7172af4530c559215b2f94870d3b8b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803ca422e84f495e93a5a03e58e51c6c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a803ca422e84f495e93a5a03e58e51c6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleXGCCoordinates.html">viskores::cont::ArrayHandleXGCCoordinates</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a803ca422e84f495e93a5a03e58e51c6c">make_ArrayHandleXGCCoordinates</a> (const std::vector&lt; T &gt; &amp;array, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfPlanesOwned, bool cylindrical, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfPlanes=-1, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> planeStartId=0, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> copy=<a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a>)</td></tr>
<tr class="separator:a803ca422e84f495e93a5a03e58e51c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34460a9d359cdab18e42e447299bc669"><td class="memTemplParams" colspan="2">template&lt;typename FirstHandleType , typename SecondHandleType &gt; </td></tr>
<tr class="memitem:a34460a9d359cdab18e42e447299bc669"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleZip.html">viskores::cont::ArrayHandleZip</a>&lt; FirstHandleType, SecondHandleType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a34460a9d359cdab18e42e447299bc669">make_ArrayHandleZip</a> (const FirstHandleType &amp;first, const SecondHandleType &amp;second)</td></tr>
<tr class="memdesc:a34460a9d359cdab18e42e447299bc669"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function for creating an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleZip.html" title="ArrayHandleZip is a specialization of ArrayHandle.">ArrayHandleZip</a>.  <a href="namespaceviskores_1_1cont.html#a34460a9d359cdab18e42e447299bc669">More...</a><br /></td></tr>
<tr class="separator:a34460a9d359cdab18e42e447299bc669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e691c31236fe8d278bead85f6dbf605"><td class="memTemplParams" colspan="2">template&lt;typename PortalType &gt; </td></tr>
<tr class="memitem:a2e691c31236fe8d278bead85f6dbf605"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayPortalToIterators.html">viskores::cont::ArrayPortalToIterators</a>&lt; PortalType &gt;::IteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a2e691c31236fe8d278bead85f6dbf605">ArrayPortalToIteratorBegin</a> (const PortalType &amp;portal)</td></tr>
<tr class="memdesc:a2e691c31236fe8d278bead85f6dbf605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for converting an <a class="el" href="classviskores_1_1cont_1_1ArrayPortal.html" title="A class that points to and access and array of data.">ArrayPortal</a> to a begin iterator.  <a href="namespaceviskores_1_1cont.html#a2e691c31236fe8d278bead85f6dbf605">More...</a><br /></td></tr>
<tr class="separator:a2e691c31236fe8d278bead85f6dbf605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c820f4759d3d07cc92a1a10669f4521"><td class="memTemplParams" colspan="2">template&lt;typename PortalType &gt; </td></tr>
<tr class="memitem:a3c820f4759d3d07cc92a1a10669f4521"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayPortalToIterators.html">viskores::cont::ArrayPortalToIterators</a>&lt; PortalType &gt;::IteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a3c820f4759d3d07cc92a1a10669f4521">ArrayPortalToIteratorEnd</a> (const PortalType &amp;portal)</td></tr>
<tr class="memdesc:a3c820f4759d3d07cc92a1a10669f4521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for converting an <a class="el" href="classviskores_1_1cont_1_1ArrayPortal.html" title="A class that points to and access and array of data.">ArrayPortal</a> to an end iterator.  <a href="namespaceviskores_1_1cont.html#a3c820f4759d3d07cc92a1a10669f4521">More...</a><br /></td></tr>
<tr class="separator:a3c820f4759d3d07cc92a1a10669f4521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f8b1c047e94f6a5566e8179fc8bf75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a36f8b1c047e94f6a5566e8179fc8bf75">ThrowArrayRangeComputeFailed</a> ()</td></tr>
<tr class="separator:a36f8b1c047e94f6a5566e8179fc8bf75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b8ec5e1cfa507b63d6b8837e80ee88"><td class="memTemplParams" colspan="2">template&lt;typename ArrayHandleType &gt; </td></tr>
<tr class="memitem:a75b8ec5e1cfa507b63d6b8837e80ee88"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1Range.html">viskores::Range</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a75b8ec5e1cfa507b63d6b8837e80ee88">ArrayRangeCompute</a> (const ArrayHandleType &amp;input, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a> device=<a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{})</td></tr>
<tr class="separator:a75b8ec5e1cfa507b63d6b8837e80ee88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cda2f141570ff29b06b201105ad3e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structviskores_1_1Bounds.html">viskores::Bounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ac3cda2f141570ff29b06b201105ad3e4">BoundsCompute</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;dataset, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> coordinate_system_index=0)</td></tr>
<tr class="memdesc:ac3cda2f141570ff29b06b201105ad3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions to compute bounds for a single dataSset or partition dataset.  <a href="namespaceviskores_1_1cont.html#ac3cda2f141570ff29b06b201105ad3e4">More...</a><br /></td></tr>
<tr class="separator:ac3cda2f141570ff29b06b201105ad3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c10dea04b3b80449a0fc6c36cf6c2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structviskores_1_1Bounds.html">viskores::Bounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#af4c10dea04b3b80449a0fc6c36cf6c2d">BoundsCompute</a> (const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;pds, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> coordinate_system_index=0)</td></tr>
<tr class="separator:af4c10dea04b3b80449a0fc6c36cf6c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0bd7954e3ca919092981f0f01dfc56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structviskores_1_1Bounds.html">viskores::Bounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#aac0bd7954e3ca919092981f0f01dfc56">BoundsCompute</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;dataset, const std::string &amp;coordinate_system_name)</td></tr>
<tr class="separator:aac0bd7954e3ca919092981f0f01dfc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad344de6fd29f58ddc538355d8ebdc641"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structviskores_1_1Bounds.html">viskores::Bounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ad344de6fd29f58ddc538355d8ebdc641">BoundsCompute</a> (const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;pds, const std::string &amp;coordinate_system_name)</td></tr>
<tr class="separator:ad344de6fd29f58ddc538355d8ebdc641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142da7929dd1d682d1c6dab22b14b1fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structviskores_1_1Bounds.html">viskores::Bounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a142da7929dd1d682d1c6dab22b14b1fd">BoundsGlobalCompute</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;dataset, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> coordinate_system_index=0)</td></tr>
<tr class="memdesc:a142da7929dd1d682d1c6dab22b14b1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions to compute bounds for a single dataset or partitioned dataset globally.  <a href="namespaceviskores_1_1cont.html#a142da7929dd1d682d1c6dab22b14b1fd">More...</a><br /></td></tr>
<tr class="separator:a142da7929dd1d682d1c6dab22b14b1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7dd5711c223f2e1c45a69a95dabaf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structviskores_1_1Bounds.html">viskores::Bounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a2c7dd5711c223f2e1c45a69a95dabaf5">BoundsGlobalCompute</a> (const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;pds, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> coordinate_system_index=0)</td></tr>
<tr class="separator:a2c7dd5711c223f2e1c45a69a95dabaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ffb909dd6159b29fdde76243aae9d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structviskores_1_1Bounds.html">viskores::Bounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#af5ffb909dd6159b29fdde76243aae9d2">BoundsGlobalCompute</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;dataset, const std::string &amp;coordinate_system_name)</td></tr>
<tr class="separator:af5ffb909dd6159b29fdde76243aae9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe39d774cd80a9a2489bcdfc6f25f751"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structviskores_1_1Bounds.html">viskores::Bounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#afe39d774cd80a9a2489bcdfc6f25f751">BoundsGlobalCompute</a> (const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;pds, const std::string &amp;coordinate_system_name)</td></tr>
<tr class="separator:afe39d774cd80a9a2489bcdfc6f25f751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2404df9b667b4f6a7d730de52aa414f0"><td class="memTemplParams" colspan="2">template&lt;typename DynamicObject , typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a2404df9b667b4f6a7d730de52aa414f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a2404df9b667b4f6a7d730de52aa414f0">CastAndCall</a> (const DynamicObject &amp;dynamicObject, Functor &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2404df9b667b4f6a7d730de52aa414f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Generic interface to CastAndCall.  <a href="namespaceviskores_1_1cont.html#a2404df9b667b4f6a7d730de52aa414f0">More...</a><br /></td></tr>
<tr class="separator:a2404df9b667b4f6a7d730de52aa414f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2279e21253fe7d645b4017e9744c7bc6"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a2279e21253fe7d645b4017e9744c7bc6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a2279e21253fe7d645b4017e9744c7bc6">CastAndCall</a> (const <a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html">CoordinateSystem</a> &amp;coords, Functor &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2279e21253fe7d645b4017e9744c7bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of CastAndCall for basic <a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html" title="Manages a coordinate system for a DataSet.">CoordinateSystem</a> to make it be treated just like any other dynamic object.  <a href="namespaceviskores_1_1cont.html#a2279e21253fe7d645b4017e9744c7bc6">More...</a><br /></td></tr>
<tr class="separator:a2279e21253fe7d645b4017e9744c7bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d1abe80dbb360358f259f4af38ade6"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a97d1abe80dbb360358f259f4af38ade6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a97d1abe80dbb360358f259f4af38ade6">CastAndCall</a> (const <a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> &amp;field, Functor &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a97d1abe80dbb360358f259f4af38ade6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of CastAndCall for basic <a class="el" href="classviskores_1_1cont_1_1Field.html" title="A Field encapsulates an array on some piece of the mesh, such as the points, a cell set,...">Field</a> to make it be treated just like any other dynamic object.  <a href="namespaceviskores_1_1cont.html#a97d1abe80dbb360358f259f4af38ade6">More...</a><br /></td></tr>
<tr class="separator:a97d1abe80dbb360358f259f4af38ade6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf565c37efd1e135bd27eb9be69eb9be"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:adf565c37efd1e135bd27eb9be69eb9be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#adf565c37efd1e135bd27eb9be69eb9be">CastAndCall</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownCellSet.html">viskores::cont::UnknownCellSet</a> &amp;cellSet, Functor &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:adf565c37efd1e135bd27eb9be69eb9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of CastAndCall for unknown cell sets.  <a href="namespaceviskores_1_1cont.html#adf565c37efd1e135bd27eb9be69eb9be">More...</a><br /></td></tr>
<tr class="separator:adf565c37efd1e135bd27eb9be69eb9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39820aac8443ff3216eb5ccf8b976015"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a39820aac8443ff3216eb5ccf8b976015"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a39820aac8443ff3216eb5ccf8b976015">CastAndCall</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, U &gt; &amp;handle, Functor &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a39820aac8443ff3216eb5ccf8b976015"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of CastAndCall for basic <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> types, Since the type is already known no deduction is needed.  <a href="namespaceviskores_1_1cont.html#a39820aac8443ff3216eb5ccf8b976015">More...</a><br /></td></tr>
<tr class="separator:a39820aac8443ff3216eb5ccf8b976015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e88c2df25acbdf335ce7c8506c3a0da"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a4e88c2df25acbdf335ce7c8506c3a0da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a4e88c2df25acbdf335ce7c8506c3a0da">CastAndCall</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">UnknownArrayHandle</a> &amp;handle, Functor &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4e88c2df25acbdf335ce7c8506c3a0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of CastAndCall for <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a>.  <a href="namespaceviskores_1_1cont.html#a4e88c2df25acbdf335ce7c8506c3a0da">More...</a><br /></td></tr>
<tr class="separator:a4e88c2df25acbdf335ce7c8506c3a0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eebb73b96e2e764125aee2e4b919ec"><td class="memTemplParams" colspan="2">template&lt;viskores::IdComponent Dim, typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a81eebb73b96e2e764125aee2e4b919ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a81eebb73b96e2e764125aee2e4b919ec">CastAndCall</a> (const <a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">viskores::cont::CellSetStructured</a>&lt; Dim &gt; &amp;cellset, Functor &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a81eebb73b96e2e764125aee2e4b919ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of CastAndCall for basic <a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html" title="Defines a 1-, 2-, or 3-dimensional structured grid of points.">CellSetStructured</a> types, Since the type is already known no deduction is needed.  <a href="namespaceviskores_1_1cont.html#a81eebb73b96e2e764125aee2e4b919ec">More...</a><br /></td></tr>
<tr class="separator:a81eebb73b96e2e764125aee2e4b919ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544e01121683618cd29736dd58f0f7aa"><td class="memTemplParams" colspan="2">template&lt;typename ConnectivityStorageTag , typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a544e01121683618cd29736dd58f0f7aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a544e01121683618cd29736dd58f0f7aa">CastAndCall</a> (const <a class="el" href="classviskores_1_1cont_1_1CellSetSingleType.html">viskores::cont::CellSetSingleType</a>&lt; ConnectivityStorageTag &gt; &amp;cellset, Functor &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a544e01121683618cd29736dd58f0f7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of CastAndCall for basic <a class="el" href="classviskores_1_1cont_1_1CellSetSingleType.html" title="An explicit cell set with all cells of the same shape.">CellSetSingleType</a> types, Since the type is already known no deduction is needed.  <a href="namespaceviskores_1_1cont.html#a544e01121683618cd29736dd58f0f7aa">More...</a><br /></td></tr>
<tr class="separator:a544e01121683618cd29736dd58f0f7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac682d6864fbb610c90ac5e3f73f95de6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S , typename U , typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:ac682d6864fbb610c90ac5e3f73f95de6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ac682d6864fbb610c90ac5e3f73f95de6">CastAndCall</a> (const <a class="el" href="classviskores_1_1cont_1_1CellSetExplicit.html">viskores::cont::CellSetExplicit</a>&lt; T, S, U &gt; &amp;cellset, Functor &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac682d6864fbb610c90ac5e3f73f95de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of CastAndCall for basic <a class="el" href="classviskores_1_1cont_1_1CellSetExplicit.html" title="Defines an irregular collection of cells.">CellSetExplicit</a> types, Since the type is already known no deduction is needed.  <a href="namespaceviskores_1_1cont.html#ac682d6864fbb610c90ac5e3f73f95de6">More...</a><br /></td></tr>
<tr class="separator:ac682d6864fbb610c90ac5e3f73f95de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50eda64663fe6bb4c8f99ee43df7c8b"><td class="memTemplParams" colspan="2">template&lt;typename PermutationType , typename CellSetType , typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:ad50eda64663fe6bb4c8f99ee43df7c8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ad50eda64663fe6bb4c8f99ee43df7c8b">CastAndCall</a> (const <a class="el" href="classviskores_1_1cont_1_1CellSetPermutation.html">viskores::cont::CellSetPermutation</a>&lt; PermutationType, CellSetType &gt; &amp;cellset, Functor &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad50eda64663fe6bb4c8f99ee43df7c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of CastAndCall for basic <a class="el" href="classviskores_1_1cont_1_1CellSetPermutation.html" title="Rearranges the cells of one cell set to create another cell set.">CellSetPermutation</a> types, Since the type is already known no deduction is needed.  <a href="namespaceviskores_1_1cont.html#ad50eda64663fe6bb4c8f99ee43df7c8b">More...</a><br /></td></tr>
<tr class="separator:ad50eda64663fe6bb4c8f99ee43df7c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8049006f821e4659207add170166041a"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a8049006f821e4659207add170166041a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a8049006f821e4659207add170166041a">CastAndCall</a> (const <a class="el" href="classviskores_1_1cont_1_1CellSetExtrude.html">viskores::cont::CellSetExtrude</a> &amp;cellset, Functor &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a8049006f821e4659207add170166041a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of CastAndCall for basic <a class="el" href="classviskores_1_1cont_1_1CellSetExtrude.html" title="Defines a 3-dimensional extruded mesh representation.">CellSetExtrude</a> types, Since the type is already known no deduction is needed.  <a href="namespaceviskores_1_1cont.html#a8049006f821e4659207add170166041a">More...</a><br /></td></tr>
<tr class="separator:a8049006f821e4659207add170166041a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622b214ab1f55cd98464104de650b4fa"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a622b214ab1f55cd98464104de650b4fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a622b214ab1f55cd98464104de650b4fa">ConditionalCastAndCall</a> (std::true_type, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a622b214ab1f55cd98464104de650b4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">CastAndCall if the condition is true.  <a href="namespaceviskores_1_1cont.html#a622b214ab1f55cd98464104de650b4fa">More...</a><br /></td></tr>
<tr class="separator:a622b214ab1f55cd98464104de650b4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8177e568c6c5e8e38678b79c5cf6d3cd"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a8177e568c6c5e8e38678b79c5cf6d3cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a8177e568c6c5e8e38678b79c5cf6d3cd">ConditionalCastAndCall</a> (std::false_type, Args &amp;&amp;...)</td></tr>
<tr class="memdesc:a8177e568c6c5e8e38678b79c5cf6d3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-op variant since the condition is false.  <a href="namespaceviskores_1_1cont.html#a8177e568c6c5e8e38678b79c5cf6d3cd">More...</a><br /></td></tr>
<tr class="separator:a8177e568c6c5e8e38678b79c5cf6d3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8383ef093396d07bd5a92ae130e7e656"><td class="memTemplParams" colspan="2">template&lt;typename CellSetType , typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a8383ef093396d07bd5a92ae130e7e656"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a8383ef093396d07bd5a92ae130e7e656">CastAndCallCellLocatorChooser</a> (const CellSetType &amp;cellSet, const <a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html">viskores::cont::CoordinateSystem</a> &amp;coordinateSystem, Functor &amp;&amp;functor, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a8383ef093396d07bd5a92ae130e7e656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a functor with the appropriate type of <code>CellLocator</code>.  <a href="namespaceviskores_1_1cont.html#a8383ef093396d07bd5a92ae130e7e656">More...</a><br /></td></tr>
<tr class="separator:a8383ef093396d07bd5a92ae130e7e656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043da6a2c77a613c33d9a5b9b4d332ba"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a043da6a2c77a613c33d9a5b9b4d332ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a043da6a2c77a613c33d9a5b9b4d332ba">CastAndCallCellLocatorChooser</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;dataSet, Functor &amp;&amp;functor, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a043da6a2c77a613c33d9a5b9b4d332ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a functor with the appropriate type of <code>CellLocator</code>.  <a href="namespaceviskores_1_1cont.html#a043da6a2c77a613c33d9a5b9b4d332ba">More...</a><br /></td></tr>
<tr class="separator:a043da6a2c77a613c33d9a5b9b4d332ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695ba80af4e58edbfbf77e46f3e98e37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a695ba80af4e58edbfbf77e46f3e98e37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1CellSetExtrude.html">CellSetExtrude</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a695ba80af4e58edbfbf77e46f3e98e37">make_CellSetExtrude</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a551f985fe2e8dae6c5f03856ecfe0dae">viskores::Int32</a> &gt; &amp;conn, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandleXGCCoordinates.html">viskores::cont::ArrayHandleXGCCoordinates</a>&lt; T &gt; &amp;coords, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a551f985fe2e8dae6c5f03856ecfe0dae">viskores::Int32</a> &gt; &amp;nextNode, bool periodic=true)</td></tr>
<tr class="separator:a695ba80af4e58edbfbf77e46f3e98e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1011dac9bd6c523ca8c7e70c5d35da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d1011dac9bd6c523ca8c7e70c5d35da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1CellSetExtrude.html">CellSetExtrude</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a1d1011dac9bd6c523ca8c7e70c5d35da">make_CellSetExtrude</a> (const std::vector&lt; <a class="el" href="namespaceviskores.html#a551f985fe2e8dae6c5f03856ecfe0dae">viskores::Int32</a> &gt; &amp;conn, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandleXGCCoordinates.html">viskores::cont::ArrayHandleXGCCoordinates</a>&lt; T &gt; &amp;coords, const std::vector&lt; <a class="el" href="namespaceviskores.html#a551f985fe2e8dae6c5f03856ecfe0dae">viskores::Int32</a> &gt; &amp;nextNode, bool periodic=true)</td></tr>
<tr class="separator:a1d1011dac9bd6c523ca8c7e70c5d35da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafcd37e4d92c6722c898de96d13be41"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeafcd37e4d92c6722c898de96d13be41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1CellSetExtrude.html">CellSetExtrude</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#aeafcd37e4d92c6722c898de96d13be41">make_CellSetExtrude</a> (std::vector&lt; <a class="el" href="namespaceviskores.html#a551f985fe2e8dae6c5f03856ecfe0dae">viskores::Int32</a> &gt; &amp;&amp;conn, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandleXGCCoordinates.html">viskores::cont::ArrayHandleXGCCoordinates</a>&lt; T &gt; &amp;coords, std::vector&lt; <a class="el" href="namespaceviskores.html#a551f985fe2e8dae6c5f03856ecfe0dae">viskores::Int32</a> &gt; &amp;&amp;nextNode, bool periodic=true)</td></tr>
<tr class="separator:aeafcd37e4d92c6722c898de96d13be41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f3bcee73f50de8af9b08f3edbbc913"><td class="memTemplParams" colspan="2">template&lt;typename OriginalCellSet , typename PermutationArrayHandleType &gt; </td></tr>
<tr class="memitem:a12f3bcee73f50de8af9b08f3edbbc913"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1CellSetPermutation.html">viskores::cont::CellSetPermutation</a>&lt; OriginalCellSet, PermutationArrayHandleType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a12f3bcee73f50de8af9b08f3edbbc913">make_CellSetPermutation</a> (const PermutationArrayHandleType &amp;cellIndexMap, const OriginalCellSet &amp;cellSet)</td></tr>
<tr class="separator:a12f3bcee73f50de8af9b08f3edbbc913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7bee0f87fc44bbd353e2d80a20a234"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:acb7bee0f87fc44bbd353e2d80a20a234"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#acb7bee0f87fc44bbd353e2d80a20a234">ColorTableMap</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;values, const <a class="el" href="classviskores_1_1cont_1_1ColorTableSamplesRGBA.html">viskores::cont::ColorTableSamplesRGBA</a> &amp;samples, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#afb51ac2f1b928606ed0381cf7470c2c5">viskores::Vec4ui_8</a> &gt; &amp;rgbaOut)</td></tr>
<tr class="memdesc:acb7bee0f87fc44bbd353e2d80a20a234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample each value through an intermediate lookup/sample table to generate RGBA colors.  <a href="namespaceviskores_1_1cont.html#acb7bee0f87fc44bbd353e2d80a20a234">More...</a><br /></td></tr>
<tr class="separator:acb7bee0f87fc44bbd353e2d80a20a234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fd8a764606792aed22c2f14e1eb6b1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a39fd8a764606792aed22c2f14e1eb6b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a39fd8a764606792aed22c2f14e1eb6b1">ColorTableMap</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;values, const <a class="el" href="classviskores_1_1cont_1_1ColorTableSamplesRGB.html">viskores::cont::ColorTableSamplesRGB</a> &amp;samples, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a75fb5b3cc80b03eaa494d3075a42faca">viskores::Vec3ui_8</a> &gt; &amp;rgbOut)</td></tr>
<tr class="memdesc:a39fd8a764606792aed22c2f14e1eb6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample each value through an intermediate lookup/sample table to generate RGB colors.  <a href="namespaceviskores_1_1cont.html#a39fd8a764606792aed22c2f14e1eb6b1">More...</a><br /></td></tr>
<tr class="separator:a39fd8a764606792aed22c2f14e1eb6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f02b48b8e1118034fb44602a59e20e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename S &gt; </td></tr>
<tr class="memitem:ab0f02b48b8e1118034fb44602a59e20e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ab0f02b48b8e1118034fb44602a59e20e">ColorTableMapMagnitude</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; T, N &gt;, S &gt; &amp;values, const <a class="el" href="classviskores_1_1cont_1_1ColorTableSamplesRGBA.html">viskores::cont::ColorTableSamplesRGBA</a> &amp;samples, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#afb51ac2f1b928606ed0381cf7470c2c5">viskores::Vec4ui_8</a> &gt; &amp;rgbaOut)</td></tr>
<tr class="memdesc:ab0f02b48b8e1118034fb44602a59e20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use magnitude of a vector with a sample table to generate RGBA colors.  <a href="namespaceviskores_1_1cont.html#ab0f02b48b8e1118034fb44602a59e20e">More...</a><br /></td></tr>
<tr class="separator:ab0f02b48b8e1118034fb44602a59e20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a16cf4dc539de435f6f34d472a542d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename S &gt; </td></tr>
<tr class="memitem:ae7a16cf4dc539de435f6f34d472a542d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ae7a16cf4dc539de435f6f34d472a542d">ColorTableMapMagnitude</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; T, N &gt;, S &gt; &amp;values, const <a class="el" href="classviskores_1_1cont_1_1ColorTableSamplesRGB.html">viskores::cont::ColorTableSamplesRGB</a> &amp;samples, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a75fb5b3cc80b03eaa494d3075a42faca">viskores::Vec3ui_8</a> &gt; &amp;rgbOut)</td></tr>
<tr class="memdesc:ae7a16cf4dc539de435f6f34d472a542d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use magnitude of a vector with a sample table to generate RGB colors.  <a href="namespaceviskores_1_1cont.html#ae7a16cf4dc539de435f6f34d472a542d">More...</a><br /></td></tr>
<tr class="separator:ae7a16cf4dc539de435f6f34d472a542d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae49cc7431b9ed125161f73f4011554d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename S &gt; </td></tr>
<tr class="memitem:aae49cc7431b9ed125161f73f4011554d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#aae49cc7431b9ed125161f73f4011554d">ColorTableMapComponent</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; T, N &gt;, S &gt; &amp;values, <a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> comp, const <a class="el" href="classviskores_1_1cont_1_1ColorTableSamplesRGBA.html">viskores::cont::ColorTableSamplesRGBA</a> &amp;samples, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#afb51ac2f1b928606ed0381cf7470c2c5">viskores::Vec4ui_8</a> &gt; &amp;rgbaOut)</td></tr>
<tr class="memdesc:aae49cc7431b9ed125161f73f4011554d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a single component of a vector with a sample table to generate RGBA colors.  <a href="namespaceviskores_1_1cont.html#aae49cc7431b9ed125161f73f4011554d">More...</a><br /></td></tr>
<tr class="separator:aae49cc7431b9ed125161f73f4011554d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2863f0324200cec0e451279baf63c55e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename S &gt; </td></tr>
<tr class="memitem:a2863f0324200cec0e451279baf63c55e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a2863f0324200cec0e451279baf63c55e">ColorTableMapComponent</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; T, N &gt;, S &gt; &amp;values, <a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> comp, const <a class="el" href="classviskores_1_1cont_1_1ColorTableSamplesRGB.html">viskores::cont::ColorTableSamplesRGB</a> &amp;samples, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a75fb5b3cc80b03eaa494d3075a42faca">viskores::Vec3ui_8</a> &gt; &amp;rgbOut)</td></tr>
<tr class="memdesc:a2863f0324200cec0e451279baf63c55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a single component of a vector with a sample table to generate RGB colors.  <a href="namespaceviskores_1_1cont.html#a2863f0324200cec0e451279baf63c55e">More...</a><br /></td></tr>
<tr class="separator:a2863f0324200cec0e451279baf63c55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dcfec7e073e99c85e0542a1d343b05"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ab9dcfec7e073e99c85e0542a1d343b05"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ab9dcfec7e073e99c85e0542a1d343b05">ColorTableMap</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;values, const <a class="el" href="classviskores_1_1cont_1_1ColorTable.html">viskores::cont::ColorTable</a> &amp;table, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#afb51ac2f1b928606ed0381cf7470c2c5">viskores::Vec4ui_8</a> &gt; &amp;rgbaOut)</td></tr>
<tr class="memdesc:ab9dcfec7e073e99c85e0542a1d343b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate each value through the color table to generate RGBA colors.  <a href="namespaceviskores_1_1cont.html#ab9dcfec7e073e99c85e0542a1d343b05">More...</a><br /></td></tr>
<tr class="separator:ab9dcfec7e073e99c85e0542a1d343b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe40a526013a27b1fc3518a69281fba5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:afe40a526013a27b1fc3518a69281fba5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#afe40a526013a27b1fc3518a69281fba5">ColorTableMap</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;values, const <a class="el" href="classviskores_1_1cont_1_1ColorTable.html">viskores::cont::ColorTable</a> &amp;table, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; <a class="el" href="namespaceviskores.html#afea83468f8cfcf7f649b1fd42d117a0d">viskores::UInt8</a>, 3 &gt;&gt; &amp;rgbOut)</td></tr>
<tr class="memdesc:afe40a526013a27b1fc3518a69281fba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate each value through the color table to generate RGB colors.  <a href="namespaceviskores_1_1cont.html#afe40a526013a27b1fc3518a69281fba5">More...</a><br /></td></tr>
<tr class="separator:afe40a526013a27b1fc3518a69281fba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093ddf94e800d08fdb5a29120db38b9a"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename S &gt; </td></tr>
<tr class="memitem:a093ddf94e800d08fdb5a29120db38b9a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a093ddf94e800d08fdb5a29120db38b9a">ColorTableMapMagnitude</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; T, N &gt;, S &gt; &amp;values, const <a class="el" href="classviskores_1_1cont_1_1ColorTable.html">viskores::cont::ColorTable</a> &amp;table, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#afb51ac2f1b928606ed0381cf7470c2c5">viskores::Vec4ui_8</a> &gt; &amp;rgbaOut)</td></tr>
<tr class="memdesc:a093ddf94e800d08fdb5a29120db38b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use magnitude of a vector to generate RGBA colors.  <a href="namespaceviskores_1_1cont.html#a093ddf94e800d08fdb5a29120db38b9a">More...</a><br /></td></tr>
<tr class="separator:a093ddf94e800d08fdb5a29120db38b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d80929a469d0d87e02fba74ace7119"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename S &gt; </td></tr>
<tr class="memitem:ae6d80929a469d0d87e02fba74ace7119"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ae6d80929a469d0d87e02fba74ace7119">ColorTableMapMagnitude</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; T, N &gt;, S &gt; &amp;values, const <a class="el" href="classviskores_1_1cont_1_1ColorTable.html">viskores::cont::ColorTable</a> &amp;table, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; <a class="el" href="namespaceviskores.html#afea83468f8cfcf7f649b1fd42d117a0d">viskores::UInt8</a>, 3 &gt;&gt; &amp;rgbOut)</td></tr>
<tr class="memdesc:ae6d80929a469d0d87e02fba74ace7119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use magnitude of a vector to generate RGB colors.  <a href="namespaceviskores_1_1cont.html#ae6d80929a469d0d87e02fba74ace7119">More...</a><br /></td></tr>
<tr class="separator:ae6d80929a469d0d87e02fba74ace7119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e78a4275eee7daf9f6c3208fad4ec5"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename S &gt; </td></tr>
<tr class="memitem:ad1e78a4275eee7daf9f6c3208fad4ec5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ad1e78a4275eee7daf9f6c3208fad4ec5">ColorTableMapComponent</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; T, N &gt;, S &gt; &amp;values, <a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> comp, const <a class="el" href="classviskores_1_1cont_1_1ColorTable.html">viskores::cont::ColorTable</a> &amp;table, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#afb51ac2f1b928606ed0381cf7470c2c5">viskores::Vec4ui_8</a> &gt; &amp;rgbaOut)</td></tr>
<tr class="memdesc:ad1e78a4275eee7daf9f6c3208fad4ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a single component of a vector to generate RGBA colors.  <a href="namespaceviskores_1_1cont.html#ad1e78a4275eee7daf9f6c3208fad4ec5">More...</a><br /></td></tr>
<tr class="separator:ad1e78a4275eee7daf9f6c3208fad4ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ae6911cc7fe1e450dbf79dccc24707"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename S &gt; </td></tr>
<tr class="memitem:a11ae6911cc7fe1e450dbf79dccc24707"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a11ae6911cc7fe1e450dbf79dccc24707">ColorTableMapComponent</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; T, N &gt;, S &gt; &amp;values, <a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> comp, const <a class="el" href="classviskores_1_1cont_1_1ColorTable.html">viskores::cont::ColorTable</a> &amp;table, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; <a class="el" href="namespaceviskores.html#afea83468f8cfcf7f649b1fd42d117a0d">viskores::UInt8</a>, 3 &gt;&gt; &amp;rgbOut)</td></tr>
<tr class="memdesc:a11ae6911cc7fe1e450dbf79dccc24707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a single component of a vector to generate RGB colors.  <a href="namespaceviskores_1_1cont.html#a11ae6911cc7fe1e450dbf79dccc24707">More...</a><br /></td></tr>
<tr class="separator:a11ae6911cc7fe1e450dbf79dccc24707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94eb61894ec5cb45eafd588185859b0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a94eb61894ec5cb45eafd588185859b0a">ConvertNumComponentsToOffsets</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;numComponentsArray, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &gt; &amp;offsetsArray, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &amp;componentsArraySize, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a> device=<a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{})</td></tr>
<tr class="memdesc:a94eb61894ec5cb45eafd588185859b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>ConvertNumComponentsToOffsets</code> takes an array of <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a> sizes (i.e.  <a href="namespaceviskores_1_1cont.html#a94eb61894ec5cb45eafd588185859b0a">More...</a><br /></td></tr>
<tr class="separator:a94eb61894ec5cb45eafd588185859b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c40d75b54ede0c5cdc69ed77a9978b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a6c40d75b54ede0c5cdc69ed77a9978b3">ConvertNumComponentsToOffsets</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;numComponentsArray, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &gt; &amp;offsetsArray, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a> device=<a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{})</td></tr>
<tr class="separator:a6c40d75b54ede0c5cdc69ed77a9978b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3711a19570a2171d92980381372a5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#aca3711a19570a2171d92980381372a5a">ConvertNumComponentsToOffsets</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;numComponentsArray, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &amp;componentsArraySize, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a> device=<a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{})</td></tr>
<tr class="separator:aca3711a19570a2171d92980381372a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a2bb43a62e81881293867174d12030"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a94a2bb43a62e81881293867174d12030">ConvertNumComponentsToOffsets</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;numComponentsArray, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a> device=<a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{})</td></tr>
<tr class="separator:a94a2bb43a62e81881293867174d12030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad348497fd44a00989203358ad7be5109"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad348497fd44a00989203358ad7be5109"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html">viskores::cont::CoordinateSystem</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ad348497fd44a00989203358ad7be5109">make_CoordinateSystem</a> (std::string name, const std::vector&lt; T &gt; &amp;data, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> copy=<a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a>)</td></tr>
<tr class="separator:ad348497fd44a00989203358ad7be5109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93811e3967a5138e0a58f50666845ad0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93811e3967a5138e0a58f50666845ad0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html">viskores::cont::CoordinateSystem</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a93811e3967a5138e0a58f50666845ad0">make_CoordinateSystem</a> (std::string name, const T *data, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfValues, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> copy=<a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a>)</td></tr>
<tr class="separator:a93811e3967a5138e0a58f50666845ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6eea6c6b388ebae82d3e783d40956d"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a7c6eea6c6b388ebae82d3e783d40956d">GlobalGhostCellFieldName</a> () noexcept</td></tr>
<tr class="separator:a7c6eea6c6b388ebae82d3e783d40956d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6499c1f313b6aeba11a4e5e525dd61"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a4f6499c1f313b6aeba11a4e5e525dd61">GetGlobalGhostCellFieldName</a> () noexcept</td></tr>
<tr class="separator:a4f6499c1f313b6aeba11a4e5e525dd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4725d93587437375e4560b21e98b425"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ad4725d93587437375e4560b21e98b425">SetGlobalGhostCellFieldName</a> (const std::string &amp;name) noexcept</td></tr>
<tr class="separator:ad4725d93587437375e4560b21e98b425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c2693178c33cfbad4a7b8863e4c2d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">DeviceAdapterId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#af2c2693178c33cfbad4a7b8863e4c2d8">make_DeviceAdapterId</a> (const <a class="el" href="namespaceviskores_1_1cont.html#a8915670663a9ef414cf88fce2f4e6ca6">DeviceAdapterNameType</a> &amp;name)</td></tr>
<tr class="memdesc:af2c2693178c33cfbad4a7b8863e4c2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a device adapter id from a runtime string The string is case-insensitive.  <a href="namespaceviskores_1_1cont.html#af2c2693178c33cfbad4a7b8863e4c2d8">More...</a><br /></td></tr>
<tr class="separator:af2c2693178c33cfbad4a7b8863e4c2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa438f6a5bf4b16b673aa9f41f0eb5863"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">DeviceAdapterId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#aa438f6a5bf4b16b673aa9f41f0eb5863">make_DeviceAdapterId</a> (<a class="el" href="namespaceviskores.html#a51c25b092de0dab71d38ba566199f8bf">viskores::Int8</a> id)</td></tr>
<tr class="memdesc:aa438f6a5bf4b16b673aa9f41f0eb5863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a device adapter id a <a class="el" href="namespaceviskores.html#a51c25b092de0dab71d38ba566199f8bf" title="Base type to use for 8-bit signed integer numbers.">viskores::Int8</a>.  <a href="namespaceviskores_1_1cont.html#aa438f6a5bf4b16b673aa9f41f0eb5863">More...</a><br /></td></tr>
<tr class="separator:aa438f6a5bf4b16b673aa9f41f0eb5863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9af159713650bc114e7b0566ec0d50c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#af9af159713650bc114e7b0566ec0d50c">GetDIYDeviceAdapter</a> ()</td></tr>
<tr class="separator:af9af159713650bc114e7b0566ec0d50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f81f8313381b165bfcf9975611edd8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a0f81f8313381b165bfcf9975611edd8c">DIYMasterExchange</a> (viskoresdiy::Master &amp;master, bool remote=false)</td></tr>
<tr class="memdesc:a0f81f8313381b165bfcf9975611edd8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps viskoresdiy::Master::exchange by setting its appropiate viskoresdiy::MemoryManagement.  <a href="namespaceviskores_1_1cont.html#a0f81f8313381b165bfcf9975611edd8c">More...</a><br /></td></tr>
<tr class="separator:a0f81f8313381b165bfcf9975611edd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d414682f81a83ec8a9e31d5927b7f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a18d414682f81a83ec8a9e31d5927b7f0">throwFailedRuntimeDeviceTransfer</a> (const std::string &amp;className, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a> device)</td></tr>
<tr class="memdesc:a18d414682f81a83ec8a9e31d5927b7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws an ErrorBadeDevice exception with the following message: "Viskores was unable to transfer <code>className</code> to DeviceAdapter[id,name].  <a href="namespaceviskores_1_1cont.html#a18d414682f81a83ec8a9e31d5927b7f0">More...</a><br /></td></tr>
<tr class="separator:a18d414682f81a83ec8a9e31d5927b7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945f308c83bb2157ee0c7a61ae540632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a945f308c83bb2157ee0c7a61ae540632">throwFailedDynamicCast</a> (const std::string &amp;baseType, const std::string &amp;derivedType)</td></tr>
<tr class="memdesc:a945f308c83bb2157ee0c7a61ae540632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws an <a class="el" href="classviskores_1_1cont_1_1ErrorBadType.html" title="This class is thrown when Viskores encounters data of a type that is incompatible with the current op...">ErrorBadType</a> exception with the following message: Cast failed: <code>baseType</code> --&gt; <code>derivedType"</code>.  <a href="namespaceviskores_1_1cont.html#a945f308c83bb2157ee0c7a61ae540632">More...</a><br /></td></tr>
<tr class="separator:a945f308c83bb2157ee0c7a61ae540632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31857dd3c95e3edf9820e5e09ed5675"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af31857dd3c95e3edf9820e5e09ed5675"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#af31857dd3c95e3edf9820e5e09ed5675">make_Field</a> (std::string name, <a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">Field::Association</a> association, const T *data, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> size, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> copy)</td></tr>
<tr class="memdesc:af31857dd3c95e3edf9820e5e09ed5675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience functions to build fields from C style arrays and std::vector.  <a href="namespaceviskores_1_1cont.html#af31857dd3c95e3edf9820e5e09ed5675">More...</a><br /></td></tr>
<tr class="separator:af31857dd3c95e3edf9820e5e09ed5675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63634ac7ce8ccf7253238f5bcab98625"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a63634ac7ce8ccf7253238f5bcab98625"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a63634ac7ce8ccf7253238f5bcab98625">make_Field</a> (std::string name, <a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">Field::Association</a> association, const std::vector&lt; T &gt; &amp;data, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> copy)</td></tr>
<tr class="separator:a63634ac7ce8ccf7253238f5bcab98625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92221a3a4468577faa26109c2a7f972"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad92221a3a4468577faa26109c2a7f972"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ad92221a3a4468577faa26109c2a7f972">make_FieldMove</a> (std::string name, <a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">Field::Association</a> association, std::vector&lt; T &gt; &amp;&amp;data)</td></tr>
<tr class="separator:ad92221a3a4468577faa26109c2a7f972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30beccb62e53129a535a483376085fb4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a30beccb62e53129a535a483376085fb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a30beccb62e53129a535a483376085fb4">make_Field</a> (std::string name, <a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">Field::Association</a> association, std::vector&lt; T &gt; &amp;&amp;data, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>)</td></tr>
<tr class="separator:a30beccb62e53129a535a483376085fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036364ee7500e9262e2bfa31f7f39090"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a036364ee7500e9262e2bfa31f7f39090"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a036364ee7500e9262e2bfa31f7f39090">make_Field</a> (std::string name, <a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">Field::Association</a> association, std::initializer_list&lt; T &gt; &amp;&amp;data)</td></tr>
<tr class="separator:a036364ee7500e9262e2bfa31f7f39090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782234106c92a428d5f35b7fa9999dba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a782234106c92a428d5f35b7fa9999dba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a782234106c92a428d5f35b7fa9999dba">make_FieldPoint</a> (std::string name, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;data)</td></tr>
<tr class="memdesc:a782234106c92a428d5f35b7fa9999dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to build point fields from <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a>.  <a href="namespaceviskores_1_1cont.html#a782234106c92a428d5f35b7fa9999dba">More...</a><br /></td></tr>
<tr class="separator:a782234106c92a428d5f35b7fa9999dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d22dc8411a14450cad3f9fa7fa4e08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#af8d22dc8411a14450cad3f9fa7fa4e08">make_FieldPoint</a> (std::string name, const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;data)</td></tr>
<tr class="memdesc:af8d22dc8411a14450cad3f9fa7fa4e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to build point fields from <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">viskores::cont::UnknownArrayHandle</a>.  <a href="namespaceviskores_1_1cont.html#af8d22dc8411a14450cad3f9fa7fa4e08">More...</a><br /></td></tr>
<tr class="separator:af8d22dc8411a14450cad3f9fa7fa4e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5bd3aa7b00c758cb063b1bc0a70d29"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a6e5bd3aa7b00c758cb063b1bc0a70d29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a6e5bd3aa7b00c758cb063b1bc0a70d29">make_FieldCell</a> (std::string name, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;data)</td></tr>
<tr class="memdesc:a6e5bd3aa7b00c758cb063b1bc0a70d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to build cell fields from <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a>.  <a href="namespaceviskores_1_1cont.html#a6e5bd3aa7b00c758cb063b1bc0a70d29">More...</a><br /></td></tr>
<tr class="separator:a6e5bd3aa7b00c758cb063b1bc0a70d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df7fc9562548b86a669e53143caebf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a7df7fc9562548b86a669e53143caebf4">make_FieldCell</a> (std::string name, const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;data)</td></tr>
<tr class="memdesc:a7df7fc9562548b86a669e53143caebf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to build cell fields from <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">viskores::cont::UnknownArrayHandle</a>.  <a href="namespaceviskores_1_1cont.html#a7df7fc9562548b86a669e53143caebf4">More...</a><br /></td></tr>
<tr class="separator:a7df7fc9562548b86a669e53143caebf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4edc88b61cce5bed4bad7ab5f33859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1Range.html">viskores::Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a1e4edc88b61cce5bed4bad7ab5f33859">FieldRangeCompute</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;dataset, const std::string &amp;name, <a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a> assoc=<a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bdaed36a1ef76a59ee3f15180e0441188ad">viskores::cont::Field::Association::Any</a>)</td></tr>
<tr class="memdesc:a1e4edc88b61cce5bed4bad7ab5f33859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute ranges for fields in a <a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">DataSet</a> or <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html" title="Comprises a set of viskores::cont::DataSet objects.">PartitionedDataSet</a>.  <a href="namespaceviskores_1_1cont.html#a1e4edc88b61cce5bed4bad7ab5f33859">More...</a><br /></td></tr>
<tr class="separator:a1e4edc88b61cce5bed4bad7ab5f33859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e68c675ab5542a6ba4e3daeb9cf097a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1Range.html">viskores::Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a6e68c675ab5542a6ba4e3daeb9cf097a">FieldRangeCompute</a> (const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;pds, const std::string &amp;name, <a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a> assoc=<a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bdaed36a1ef76a59ee3f15180e0441188ad">viskores::cont::Field::Association::Any</a>)</td></tr>
<tr class="memdesc:a6e68c675ab5542a6ba4e3daeb9cf097a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range for a field from a <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html" title="Comprises a set of viskores::cont::DataSet objects.">PartitionedDataSet</a>.  <a href="namespaceviskores_1_1cont.html#a6e68c675ab5542a6ba4e3daeb9cf097a">More...</a><br /></td></tr>
<tr class="separator:a6e68c675ab5542a6ba4e3daeb9cf097a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7292ed87a2b2804a3e79f18dfeecec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1Range.html">viskores::Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ad7292ed87a2b2804a3e79f18dfeecec7">FieldRangeGlobalCompute</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;dataset, const std::string &amp;name, <a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a> assoc=<a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bdaed36a1ef76a59ee3f15180e0441188ad">viskores::cont::Field::Association::Any</a>)</td></tr>
<tr class="memdesc:ad7292ed87a2b2804a3e79f18dfeecec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility functions to compute global ranges for dataset fields.  <a href="namespaceviskores_1_1cont.html#ad7292ed87a2b2804a3e79f18dfeecec7">More...</a><br /></td></tr>
<tr class="separator:ad7292ed87a2b2804a3e79f18dfeecec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5cc6f518fd80199b9129d41b95fa15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1Range.html">viskores::Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a3b5cc6f518fd80199b9129d41b95fa15">FieldRangeGlobalCompute</a> (const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;pds, const std::string &amp;name, <a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a> assoc=<a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bdaed36a1ef76a59ee3f15180e0441188ad">viskores::cont::Field::Association::Any</a>)</td></tr>
<tr class="memdesc:a3b5cc6f518fd80199b9129d41b95fa15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range for a field from a <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html" title="Comprises a set of viskores::cont::DataSet objects.">PartitionedDataSet</a>.  <a href="namespaceviskores_1_1cont.html#a3b5cc6f518fd80199b9129d41b95fa15">More...</a><br /></td></tr>
<tr class="separator:a3b5cc6f518fd80199b9129d41b95fa15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbc121e495268abde8188a8f0eab2bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590">InitializeOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#aedbc121e495268abde8188a8f0eab2bf">operator|</a> (const <a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590">InitializeOptions</a> &amp;lhs, const <a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590">InitializeOptions</a> &amp;rhs)</td></tr>
<tr class="separator:aedbc121e495268abde8188a8f0eab2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a54a18d541080d09b0de55ea815500e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590">InitializeOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a6a54a18d541080d09b0de55ea815500e">operator&amp;</a> (const <a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590">InitializeOptions</a> &amp;lhs, const <a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590">InitializeOptions</a> &amp;rhs)</td></tr>
<tr class="separator:a6a54a18d541080d09b0de55ea815500e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbf88926929313f6a8f4d25da8a4f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8">viskores::cont::LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a3cbf88926929313f6a8f4d25da8a4f1e">GetStderrLogLevel</a> ()</td></tr>
<tr class="memdesc:a3cbf88926929313f6a8f4d25da8a4f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the active highest log level that will be printed to stderr.  <a href="namespaceviskores_1_1cont.html#a3cbf88926929313f6a8f4d25da8a4f1e">More...</a><br /></td></tr>
<tr class="separator:a3cbf88926929313f6a8f4d25da8a4f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4867020c06e87e15da99893d978f1f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ae4867020c06e87e15da99893d978f1f5">SetLogLevelName</a> (<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8">viskores::cont::LogLevel</a> level, const std::string &amp;name)</td></tr>
<tr class="memdesc:ae4867020c06e87e15da99893d978f1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a custom name to identify a log level.  <a href="namespaceviskores_1_1cont.html#ae4867020c06e87e15da99893d978f1f5">More...</a><br /></td></tr>
<tr class="separator:ae4867020c06e87e15da99893d978f1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af795c4c6362577e392717edf5115d90f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#af795c4c6362577e392717edf5115d90f">GetLogLevelName</a> (<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8">viskores::cont::LogLevel</a> level)</td></tr>
<tr class="memdesc:af795c4c6362577e392717edf5115d90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a human readable name for the log level.  <a href="namespaceviskores_1_1cont.html#af795c4c6362577e392717edf5115d90f">More...</a><br /></td></tr>
<tr class="separator:af795c4c6362577e392717edf5115d90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52908c96372d006b3c4f9d5df719aa42"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a52908c96372d006b3c4f9d5df719aa42">GetLogErrorContext</a> ()</td></tr>
<tr class="separator:a52908c96372d006b3c4f9d5df719aa42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc1dfbf84e47cf1006ccb464c3db506"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#abbc1dfbf84e47cf1006ccb464c3db506">GetStackTrace</a> (<a class="el" href="namespaceviskores.html#a551f985fe2e8dae6c5f03856ecfe0dae">viskores::Int32</a> skip=0)</td></tr>
<tr class="memdesc:abbc1dfbf84e47cf1006ccb464c3db506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stacktrace on supported platforms.  <a href="namespaceviskores_1_1cont.html#abbc1dfbf84e47cf1006ccb464c3db506">More...</a><br /></td></tr>
<tr class="separator:abbc1dfbf84e47cf1006ccb464c3db506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb04ffff933d97a1cd9b9c9682285ff2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#aeb04ffff933d97a1cd9b9c9682285ff2">GetHumanReadableSize</a> (<a class="el" href="namespaceviskores.html#ad73d0fee6a8e525142086920906c2fcf">viskores::UInt64</a> bytes, int prec=2)</td></tr>
<tr class="memdesc:aeb04ffff933d97a1cd9b9c9682285ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a size in bytes to a human readable string (such as "64 bytes", "1.44 MiB", "128 GiB", etc).  <a href="namespaceviskores_1_1cont.html#aeb04ffff933d97a1cd9b9c9682285ff2">More...</a><br /></td></tr>
<tr class="separator:aeb04ffff933d97a1cd9b9c9682285ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3368505f69c8efd7f5680799947967"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f3368505f69c8efd7f5680799947967"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a2f3368505f69c8efd7f5680799947967">GetHumanReadableSize</a> (T &amp;&amp;bytes, int prec=2)</td></tr>
<tr class="separator:a2f3368505f69c8efd7f5680799947967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61167c31cbdc603aa5abee56e042e7e1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a61167c31cbdc603aa5abee56e042e7e1">GetSizeString</a> (<a class="el" href="namespaceviskores.html#ad73d0fee6a8e525142086920906c2fcf">viskores::UInt64</a> bytes, int prec=2)</td></tr>
<tr class="memdesc:a61167c31cbdc603aa5abee56e042e7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "%1 (%2 bytes)" where %1 is the result from GetHumanReadableSize and %2 is the exact number of bytes.  <a href="namespaceviskores_1_1cont.html#a61167c31cbdc603aa5abee56e042e7e1">More...</a><br /></td></tr>
<tr class="separator:a61167c31cbdc603aa5abee56e042e7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40e04e4fc25155ce0ad5bbeb0b78b4b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad40e04e4fc25155ce0ad5bbeb0b78b4b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ad40e04e4fc25155ce0ad5bbeb0b78b4b">GetSizeString</a> (T &amp;&amp;bytes, int prec=2)</td></tr>
<tr class="separator:ad40e04e4fc25155ce0ad5bbeb0b78b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92abf2395bab76ff668252212a614101"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a92abf2395bab76ff668252212a614101">LogCond</a> (<a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8">LogLevel</a> level, bool cond, const char *file, unsigned line, const char *format...)</td></tr>
<tr class="memdesc:a92abf2395bab76ff668252212a614101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally logs a message with a printf-like format.  <a href="namespaceviskores_1_1cont.html#a92abf2395bab76ff668252212a614101">More...</a><br /></td></tr>
<tr class="separator:a92abf2395bab76ff668252212a614101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7476a8729dc6497be943049114b15d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a2f7476a8729dc6497be943049114b15d">MergePartitionedDataSet</a> (const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;partitionedDataSet, <a class="el" href="namespaceviskores.html#a87daa0e8ab1805ee441976f4e334daba">viskores::Float64</a> invalidValue=viskores::Nan64())</td></tr>
<tr class="memdesc:a2f7476a8729dc6497be943049114b15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can merge multiple data sets into on data set.  <a href="namespaceviskores_1_1cont.html#a2f7476a8729dc6497be943049114b15d">More...</a><br /></td></tr>
<tr class="separator:a2f7476a8729dc6497be943049114b15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff06db5fd197ac4f0889736f8d89b1c"><td class="memTemplParams" colspan="2">template&lt;typename ParticleType &gt; </td></tr>
<tr class="memitem:a0ff06db5fd197ac4f0889736f8d89b1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a0ff06db5fd197ac4f0889736f8d89b1c">ParticleArrayCopy</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; ParticleType, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;inP, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#abb422027052141614ec406112a05576d">viskores::Vec3f</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;outPos, bool CopyTerminatedOnly=false)</td></tr>
<tr class="memdesc:a0ff06db5fd197ac4f0889736f8d89b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy fields in <a class="el" href="classviskores_1_1Particle.html">viskores::Particle</a> to standard types.  <a href="namespaceviskores_1_1cont.html#a0ff06db5fd197ac4f0889736f8d89b1c">More...</a><br /></td></tr>
<tr class="separator:a0ff06db5fd197ac4f0889736f8d89b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f616ecbe79f207ca5872e3821fc6569"><td class="memTemplParams" colspan="2">template&lt;typename ParticleType &gt; </td></tr>
<tr class="memitem:a4f616ecbe79f207ca5872e3821fc6569"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a4f616ecbe79f207ca5872e3821fc6569">ParticleArrayCopy</a> (const std::vector&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; ParticleType, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt;&gt; &amp;inputs, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#abb422027052141614ec406112a05576d">viskores::Vec3f</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;outPos)</td></tr>
<tr class="memdesc:a4f616ecbe79f207ca5872e3821fc6569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy fields in <a class="el" href="classviskores_1_1Particle.html">viskores::Particle</a> to standard types.  <a href="namespaceviskores_1_1cont.html#a4f616ecbe79f207ca5872e3821fc6569">More...</a><br /></td></tr>
<tr class="separator:a4f616ecbe79f207ca5872e3821fc6569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cee37917af66e3e41af0165f0fc9f49"><td class="memTemplParams" colspan="2">template&lt;typename ParticleType &gt; </td></tr>
<tr class="memitem:a8cee37917af66e3e41af0165f0fc9f49"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a8cee37917af66e3e41af0165f0fc9f49">ParticleArrayCopy</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; ParticleType, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;inP, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#abb422027052141614ec406112a05576d">viskores::Vec3f</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;outPos, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;outID, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;outSteps, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1ParticleStatus.html">viskores::ParticleStatus</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;outStatus, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#af6c632281522d90b3f50ad6396efa1d5">viskores::FloatDefault</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;outTime)</td></tr>
<tr class="memdesc:a8cee37917af66e3e41af0165f0fc9f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all fields in <a class="el" href="classviskores_1_1Particle.html">viskores::Particle</a> to standard types.  <a href="namespaceviskores_1_1cont.html#a8cee37917af66e3e41af0165f0fc9f49">More...</a><br /></td></tr>
<tr class="separator:a8cee37917af66e3e41af0165f0fc9f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8478594b979dc91ca3fe85561fa93575"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1RuntimeDeviceTracker.html">viskores::cont::RuntimeDeviceTracker</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a8478594b979dc91ca3fe85561fa93575">GetRuntimeDeviceTracker</a> ()</td></tr>
<tr class="memdesc:a8478594b979dc91ca3fe85561fa93575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <code><a class="el" href="classviskores_1_1cont_1_1RuntimeDeviceTracker.html" title="RuntimeDeviceTracker is the central location for determining which device adapter will be active for ...">RuntimeDeviceTracker</a></code> for the current thread.  <a href="namespaceviskores_1_1cont.html#a8478594b979dc91ca3fe85561fa93575">More...</a><br /></td></tr>
<tr class="separator:a8478594b979dc91ca3fe85561fa93575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bd7f4a2c0d643c9c1910c954775a41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a66bd7f4a2c0d643c9c1910c954775a41">operator==</a> (const <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;token, <a class="el" href="classviskores_1_1cont_1_1Token_1_1Reference.html">viskores::cont::Token::Reference</a> ref)</td></tr>
<tr class="separator:a66bd7f4a2c0d643c9c1910c954775a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719de7feda498e1de433e9f6765109d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a719de7feda498e1de433e9f6765109d1">operator!=</a> (const <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;token, <a class="el" href="classviskores_1_1cont_1_1Token_1_1Reference.html">viskores::cont::Token::Reference</a> ref)</td></tr>
<tr class="separator:a719de7feda498e1de433e9f6765109d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30fc19fd133c816d78529fffbaa189f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#ad30fc19fd133c816d78529fffbaa189f">operator==</a> (<a class="el" href="classviskores_1_1cont_1_1Token_1_1Reference.html">viskores::cont::Token::Reference</a> ref, const <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;token)</td></tr>
<tr class="separator:ad30fc19fd133c816d78529fffbaa189f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c16dd072bbd5e62a2b14662bde00e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a83c16dd072bbd5e62a2b14662bde00e1">operator!=</a> (<a class="el" href="classviskores_1_1cont_1_1Token_1_1Reference.html">viskores::cont::Token::Reference</a> ref, const <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;token)</td></tr>
<tr class="separator:a83c16dd072bbd5e62a2b14662bde00e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8681997d87a70fec1cc2ab4e7978bfd8"><td class="memTemplParams" colspan="2">template&lt;typename ArrayHandleType &gt; </td></tr>
<tr class="memitem:a8681997d87a70fec1cc2ab4e7978bfd8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a8681997d87a70fec1cc2ab4e7978bfd8">IsType</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;array)</td></tr>
<tr class="memdesc:a8681997d87a70fec1cc2ab4e7978bfd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>variant</code> matches the type of ArrayHandleType.  <a href="namespaceviskores_1_1cont.html#a8681997d87a70fec1cc2ab4e7978bfd8">More...</a><br /></td></tr>
<tr class="separator:a8681997d87a70fec1cc2ab4e7978bfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de1b84413acb19d622228fd0496e5b1"><td class="memTemplParams" colspan="2">template&lt;typename ArrayHandleType &gt; </td></tr>
<tr class="memitem:a0de1b84413acb19d622228fd0496e5b1"><td class="memTemplItemLeft" align="right" valign="top">ArrayHandleType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a0de1b84413acb19d622228fd0496e5b1">Cast</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;array)</td></tr>
<tr class="memdesc:a0de1b84413acb19d622228fd0496e5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>variant</code> cast to the given <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> type.  <a href="namespaceviskores_1_1cont.html#a0de1b84413acb19d622228fd0496e5b1">More...</a><br /></td></tr>
<tr class="separator:a0de1b84413acb19d622228fd0496e5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503fe9095a711d30ed93abc142ad5165"><td class="memTemplParams" colspan="2">template&lt;typename CellSetType &gt; </td></tr>
<tr class="memitem:a503fe9095a711d30ed93abc142ad5165"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a503fe9095a711d30ed93abc142ad5165">IsType</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownCellSet.html">viskores::cont::UnknownCellSet</a> &amp;unknownCellSet)</td></tr>
<tr class="memdesc:a503fe9095a711d30ed93abc142ad5165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>unknownCellSet</code> matches the type of <code>CellSetType</code>.  <a href="namespaceviskores_1_1cont.html#a503fe9095a711d30ed93abc142ad5165">More...</a><br /></td></tr>
<tr class="separator:a503fe9095a711d30ed93abc142ad5165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d52b84a5ad1f3eb5faae1cf1df1bf5b"><td class="memTemplParams" colspan="2">template&lt;typename CellSetType &gt; </td></tr>
<tr class="memitem:a1d52b84a5ad1f3eb5faae1cf1df1bf5b"><td class="memTemplItemLeft" align="right" valign="top">CellSetType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviskores_1_1cont.html#a1d52b84a5ad1f3eb5faae1cf1df1bf5b">Cast</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownCellSet.html">viskores::cont::UnknownCellSet</a> &amp;unknownCellSet)</td></tr>
<tr class="memdesc:a1d52b84a5ad1f3eb5faae1cf1df1bf5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>unknownCellSet</code> cast to the given <code><a class="el" href="classviskores_1_1cont_1_1CellSet.html" title="Defines the topological structure of the data in a DataSet.">CellSet</a></code> type.  <a href="namespaceviskores_1_1cont.html#a1d52b84a5ad1f3eb5faae1cf1df1bf5b">More...</a><br /></td></tr>
<tr class="separator:a1d52b84a5ad1f3eb5faae1cf1df1bf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Viskores Control Environment. </p>
<p><a class="el" href="namespaceviskores_1_1cont.html" title="Viskores Control Environment.">viskores::cont</a> defines the publicly accessible API for the Viskores Control Environment. Users of the Viskores Toolkit can use this namespace to access the Control Environment. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="afcd29978dffdb19b96a869e701d32af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd29978dffdb19b96a869e701d32af5">&#9670;&nbsp;</a></span>ArrayHandleMultiplexerFromList</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceviskores_1_1cont.html#afcd29978dffdb19b96a869e701d32af5">viskores::cont::ArrayHandleMultiplexerFromList</a> = typedef <a class="el" href="namespaceviskores.html#a830688b5428ee181f86f094c1a94fdc0">viskores::ListApply</a>&lt;<a class="el" href="structviskores_1_1List.html">List</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandleMultiplexer.html">ArrayHandleMultiplexer</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a<code><a class="el" href="structviskores_1_1List.html" title="A template used to hold a list of types.">viskores::List</a></code> to an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleMultiplexer.html" title="An ArrayHandle that can behave like several other handles.">ArrayHandleMultiplexer</a></code> </p>
<p>The argument of this template must be a <code><a class="el" href="structviskores_1_1List.html" title="A template used to hold a list of types.">viskores::List</a></code> and furthermore all the types in the list tag must be some type of <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>. The templated type gets aliased to an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleMultiplexer.html" title="An ArrayHandle that can behave like several other handles.">ArrayHandleMultiplexer</a></code> that can store any of these <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> types. </p>

</div>
</div>
<a id="a7e9a73fe8766c56470a6d2c2ce88c3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9a73fe8766c56470a6d2c2ce88c3ba">&#9670;&nbsp;</a></span>CellLocatorChooser</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CellSetType , typename CoordinateSystemArrayType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceviskores_1_1cont.html#a7e9a73fe8766c56470a6d2c2ce88c3ba">viskores::cont::CellLocatorChooser</a> = typedef typename detail::CellLocatorChooserImpl&lt;CellSetType, CoordinateSystemArrayType&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A template to select an appropriate CellLocator based on <a class="el" href="classviskores_1_1cont_1_1CellSet.html" title="Defines the topological structure of the data in a DataSet.">CellSet</a> type. </p>
<p>Given a concrete type for a <code><a class="el" href="classviskores_1_1cont_1_1CellSet.html" title="Defines the topological structure of the data in a DataSet.">CellSet</a></code> subclass and a type of <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> for the coordinate system, <code>CellLocatorChooser</code> picks an appropriate <code>CellLocator</code> for that type of grid. It is a convenient class to use when you can resolve your templates to discover the type of data set being used for location. </p>

</div>
</div>
<a id="a8a515e9971f308b69b52543163186796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a515e9971f308b69b52543163186796">&#9670;&nbsp;</a></span>CellSetListCommon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceviskores_1_1cont.html#a8a515e9971f308b69b52543163186796">viskores::cont::CellSetListCommon</a> = typedef <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt;<a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">viskores::cont::CellSetStructured</a>&lt;2&gt;, <a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">viskores::cont::CellSetStructured</a>&lt;3&gt;, <a class="el" href="classviskores_1_1cont_1_1CellSetExplicit.html">viskores::cont::CellSetExplicit</a>&lt;&gt;, <a class="el" href="classviskores_1_1cont_1_1CellSetSingleType.html">viskores::cont::CellSetSingleType</a>&lt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77eb61ad4d044bd9fe05405b5ca3abeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77eb61ad4d044bd9fe05405b5ca3abeb">&#9670;&nbsp;</a></span>CellSetListExplicit</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ShapesStorageTag  = VISKORES_DEFAULT_STORAGE_TAG, typename ConnectivityStorageTag  = VISKORES_DEFAULT_STORAGE_TAG, typename OffsetsStorageTag  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceviskores_1_1cont.html#a77eb61ad4d044bd9fe05405b5ca3abeb">viskores::cont::CellSetListExplicit</a> = typedef <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt; <a class="el" href="classviskores_1_1cont_1_1CellSetExplicit.html">viskores::cont::CellSetExplicit</a>&lt;ShapesStorageTag, ConnectivityStorageTag, OffsetsStorageTag&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a862ce7135e517fd824a60d7ba7c598f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862ce7135e517fd824a60d7ba7c598f1">&#9670;&nbsp;</a></span>CellSetListExplicitDefault</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceviskores_1_1cont.html#a862ce7135e517fd824a60d7ba7c598f1">viskores::cont::CellSetListExplicitDefault</a> = typedef <a class="el" href="namespaceviskores_1_1cont.html#a77eb61ad4d044bd9fe05405b5ca3abeb">CellSetListExplicit</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb38573900a296909c75803d3935ea2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb38573900a296909c75803d3935ea2f">&#9670;&nbsp;</a></span>CellSetListStructured</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceviskores_1_1cont.html#afb38573900a296909c75803d3935ea2f">viskores::cont::CellSetListStructured</a> = typedef <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt;<a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">viskores::cont::CellSetStructured</a>&lt;2&gt;, <a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">viskores::cont::CellSetStructured</a>&lt;3&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa24a2e274d8048bfdde3e431a516290e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24a2e274d8048bfdde3e431a516290e">&#9670;&nbsp;</a></span>CellSetListStructured1D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceviskores_1_1cont.html#aa24a2e274d8048bfdde3e431a516290e">viskores::cont::CellSetListStructured1D</a> = typedef <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt;<a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">viskores::cont::CellSetStructured</a>&lt;1&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f088b2de20c00423f3033fb2a8f2e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f088b2de20c00423f3033fb2a8f2e51">&#9670;&nbsp;</a></span>CellSetListStructured2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceviskores_1_1cont.html#a5f088b2de20c00423f3033fb2a8f2e51">viskores::cont::CellSetListStructured2D</a> = typedef <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt;<a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">viskores::cont::CellSetStructured</a>&lt;2&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fcfb5a1a258985358a5b956dabbf204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcfb5a1a258985358a5b956dabbf204">&#9670;&nbsp;</a></span>CellSetListStructured3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceviskores_1_1cont.html#a7fcfb5a1a258985358a5b956dabbf204">viskores::cont::CellSetListStructured3D</a> = typedef <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt;<a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">viskores::cont::CellSetStructured</a>&lt;3&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbf53004900f054346dbcc50299edb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf53004900f054346dbcc50299edb76">&#9670;&nbsp;</a></span>CellSetListUnstructured</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceviskores_1_1cont.html#afbf53004900f054346dbcc50299edb76">viskores::cont::CellSetListUnstructured</a> = typedef <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt;<a class="el" href="classviskores_1_1cont_1_1CellSetExplicit.html">viskores::cont::CellSetExplicit</a>&lt;&gt;, <a class="el" href="classviskores_1_1cont_1_1CellSetSingleType.html">viskores::cont::CellSetSingleType</a>&lt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fc8ffe46050ffab138889b29ed32700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc8ffe46050ffab138889b29ed32700">&#9670;&nbsp;</a></span>DeviceAdapterListCommon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceviskores_1_1cont.html#a3fc8ffe46050ffab138889b29ed32700">viskores::cont::DeviceAdapterListCommon</a> = typedef <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt;<a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagCuda.html">viskores::cont::DeviceAdapterTagCuda</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagTBB.html">viskores::cont::DeviceAdapterTagTBB</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagOpenMP.html">viskores::cont::DeviceAdapterTagOpenMP</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagKokkos.html">viskores::cont::DeviceAdapterTagKokkos</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagSerial.html">viskores::cont::DeviceAdapterTagSerial</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8915670663a9ef414cf88fce2f4e6ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8915670663a9ef414cf88fce2f4e6ca6">&#9670;&nbsp;</a></span>DeviceAdapterNameType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceviskores_1_1cont.html#a8915670663a9ef414cf88fce2f4e6ca6">viskores::cont::DeviceAdapterNameType</a> = typedef std::string</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f11087403367d3de5e7ee55a7aabcd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f11087403367d3de5e7ee55a7aabcd5">&#9670;&nbsp;</a></span>StorageListBasic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceviskores_1_1cont.html#a6f11087403367d3de5e7ee55a7aabcd5">viskores::cont::StorageListBasic</a> = typedef <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt;<a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5191156a7eb1a9aa238cb82a11833ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5191156a7eb1a9aa238cb82a11833ed">&#9670;&nbsp;</a></span>StorageListCommon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceviskores_1_1cont.html#ac5191156a7eb1a9aa238cb82a11833ed">viskores::cont::StorageListCommon</a> = typedef <a class="el" href="structviskores_1_1List.html">viskores::List</a>&lt;<a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagSOA.html">viskores::cont::StorageTagSOA</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagUniformPoints.html">viskores::cont::StorageTagUniformPoints</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagCartesianProduct.html">viskores::cont::StorageTagCartesianProduct</a>&lt;<a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a80bf92eb36c625655d6326126877b590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bf92eb36c625655d6326126877b590">&#9670;&nbsp;</a></span>InitializeOptions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590">viskores::cont::InitializeOptions</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a80bf92eb36c625655d6326126877b590a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>Placeholder used when no options are enabled. </p>
<p>This is the value used when the third argument to <code><a class="el" href="namespaceviskores_1_1cont.html#afef0b0c98b83a46a4cb6d5c557c6f8a0" title="Initialize the Viskores library, parsing arguments when provided:">viskores::cont::Initialize</a></code> is not provided. </p>
</td></tr>
<tr><td class="fieldname"><a id="a80bf92eb36c625655d6326126877b590aadcac17d2654c11145294ff6a76cfc44"></a>RequireDevice&#160;</td><td class="fielddoc"><p>Issue an error if the device argument is not specified. </p>
</td></tr>
<tr><td class="fieldname"><a id="a80bf92eb36c625655d6326126877b590ae217e6295fba24735b5cd56a6a6a4e2d"></a>DefaultAnyDevice&#160;</td><td class="fielddoc"><p>If no device is specified, treat it as if the user gave <code>--viskores-device=Any</code>. </p>
<p>This means that <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagUndefined.html" title="Tag for a device adapter used to avoid specifying a device.">DeviceAdapterTagUndefined</a></code> will never be returned in the result. </p>
</td></tr>
<tr><td class="fieldname"><a id="a80bf92eb36c625655d6326126877b590a36f67495191bac78113863c9790e885a"></a>AddHelp&#160;</td><td class="fielddoc"><p><a class="el" href="structviskores_1_1Add.html">Add</a> a help argument. </p>
<p>If <code>-h</code> or <code>--viskores-help</code> is provided, prints a usage statement. Of course, the usage statement will only print out arguments processed by Viskores, which is why help is not given by default. Alternatively, a string with usage help is returned from <code><a class="el" href="namespaceviskores_1_1cont.html#afef0b0c98b83a46a4cb6d5c557c6f8a0" title="Initialize the Viskores library, parsing arguments when provided:">viskores::cont::Initialize</a></code> so that the calling program can provide Viskores's help in its own usage statement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a80bf92eb36c625655d6326126877b590aa5340dde36f103eea8d59d3441ac5811"></a>ErrorOnBadOption&#160;</td><td class="fielddoc"><p>If an unknown option is encountered, the program terminates with an error and a usage statement is printed. </p>
<p>If this option is not provided, any unknown options are returned in <code>argv</code>. If this option is used, it is a good idea to use AddHelp as well. </p>
</td></tr>
<tr><td class="fieldname"><a id="a80bf92eb36c625655d6326126877b590a755f0c94a071bf91d1993896debd05ef"></a>ErrorOnBadArgument&#160;</td><td class="fielddoc"><p>If an extra argument is encountered, the program terminates with an error and a usage statement is printed. </p>
<p>If this option is not provided, any unknown arguments are returned in <code>argv</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a80bf92eb36c625655d6326126877b590a2e979835dd62324f5bfe217449ba4974"></a>Strict&#160;</td><td class="fielddoc"><p>If supplied, Initialize treats its own arguments as the only ones supported by the application and provides an error if not followed exactly. </p>
<p>This is a convenience option that is a combination of <code>ErrorOnBadOption</code>, <code>ErrorOnBadArgument</code>, and <code>AddHelp</code>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a24ee7b2f9f91bc845712d68320fb17b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ee7b2f9f91bc845712d68320fb17b8">&#9670;&nbsp;</a></span>LogLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8">viskores::cont::LogLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Log levels for use with the logging macros. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a24ee7b2f9f91bc845712d68320fb17b8ad15305d7a4e34e02489c74a5ef542f36"></a>Off&#160;</td><td class="fielddoc"><p>A placeholder used to silence all logging. </p>
<p>Do not actually log to this level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24ee7b2f9f91bc845712d68320fb17b8a882384ec38ce8d9582b57e70861730e4"></a>Fatal&#160;</td><td class="fielddoc"><p>Fatal errors that should abort execution. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24ee7b2f9f91bc845712d68320fb17b8a902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"><p>Important but non-fatal errors, such as device fail-over. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24ee7b2f9f91bc845712d68320fb17b8a56525ae64d370c0b448ac0d60710ef17"></a>Warn&#160;</td><td class="fielddoc"><p>Less important user errors, such as out-of-bounds parameters. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24ee7b2f9f91bc845712d68320fb17b8a4059b0251f66a18cb56f544728796875"></a>Info&#160;</td><td class="fielddoc"><p>Information messages (detected hardware, etc) and temporary debugging output. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24ee7b2f9f91bc845712d68320fb17b8a96de354fa3df933535d4859d07a3ba72"></a>UserFirst&#160;</td><td class="fielddoc"><p>The first in a range of logging levels reserved for code that uses Viskores. </p>
<p>Internal Viskores code will not log on these levels but will report these logs. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24ee7b2f9f91bc845712d68320fb17b8ab42e4589c8b234eb92ef9f0d9ee2f2fa"></a>UserLast&#160;</td><td class="fielddoc"><p>The last in a range of logging levels reserved for code that uses Viskores. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24ee7b2f9f91bc845712d68320fb17b8a6bae7d6f71c134004e024e761e751d15"></a>DevicesEnabled&#160;</td><td class="fielddoc"><p>Information about which devices are enabled/disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24ee7b2f9f91bc845712d68320fb17b8aed0b6558cc63345b5c2457c8147f47d6"></a>Perf&#160;</td><td class="fielddoc"><p>General timing data and algorithm flow information, such as filter execution, worklet dispatches, and device algorithm calls. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24ee7b2f9f91bc845712d68320fb17b8a3ae11403720653bf12a816b8cfe9ed9a"></a>MemCont&#160;</td><td class="fielddoc"><p>Host-side resource allocations/frees (e.g. <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> control buffers). </p>
</td></tr>
<tr><td class="fieldname"><a id="a24ee7b2f9f91bc845712d68320fb17b8a71eeffb381f7882ce5b712100a533d74"></a>MemExec&#160;</td><td class="fielddoc"><p>Device-side resource allocations/frees (e.g <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> device buffers). </p>
</td></tr>
<tr><td class="fieldname"><a id="a24ee7b2f9f91bc845712d68320fb17b8acaaa1eac406602906c6240fb628d1667"></a>MemTransfer&#160;</td><td class="fielddoc"><p>Transferring of data between a host and device. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24ee7b2f9f91bc845712d68320fb17b8a1bda1e66fc4e1dc1d74e8714f1e6e5c8"></a>KernelLaunches&#160;</td><td class="fielddoc"><p>Details on device-side kernel launches. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24ee7b2f9f91bc845712d68320fb17b8a4cd9f3996d60790cd11c04f842ebc43c"></a>Cast&#160;</td><td class="fielddoc"><p>Reports when a dynamic object is (or is not) resolved via a CastAndCall or other casting method. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24ee7b2f9f91bc845712d68320fb17b8a99234db2faf7adc90f0defc6fae1b05e"></a>UserVerboseFirst&#160;</td><td class="fielddoc"><p>The first in a range of logging levels reserved for code that uses Viskores. </p>
<p>Internal Viskores code will not log on these levels but will report these logs. These are used similarly to those in the UserFirst range but are at a lower precedence that also includes more verbose reporting from Viskores. </p>
</td></tr>
<tr><td class="fieldname"><a id="a24ee7b2f9f91bc845712d68320fb17b8afc3dd3deb3795e4e427df8318a71b9a9"></a>UserVerboseLast&#160;</td><td class="fielddoc"><p>The last in a range of logging levels reserved for code that uses Viskores. </p>
</td></tr>
</table>

</div>
</div>
<a id="a306be5a9721d7c501244123158b5b1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306be5a9721d7c501244123158b5b1e1">&#9670;&nbsp;</a></span>RuntimeDeviceTrackerMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceviskores_1_1cont.html#a306be5a9721d7c501244123158b5b1e1">viskores::cont::RuntimeDeviceTrackerMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifier used to specify whether to enable or disable a particular device. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a306be5a9721d7c501244123158b5b1e1a9eb6b78a99cdb6ffd3d40d18621d9f80"></a>Force&#160;</td><td class="fielddoc"><p>Replaces the current list of devices to try with the device specified. </p>
<p>This has the effect of forcing Viskores to use the provided device. This is the default behavior for <code><a class="el" href="classviskores_1_1cont_1_1ScopedRuntimeDeviceTracker.html" title="A class to create a scoped runtime device tracker object.">viskores::cont::ScopedRuntimeDeviceTracker</a></code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a306be5a9721d7c501244123158b5b1e1a2faec1f9f8cc7f8f40d521c4dd574f49"></a>Enable&#160;</td><td class="fielddoc"><p>Adds the provided device adapter to the list of devices to try. </p>
</td></tr>
<tr><td class="fieldname"><a id="a306be5a9721d7c501244123158b5b1e1abcfaccebf745acfd5e75351095a5394a"></a>Disable&#160;</td><td class="fielddoc"><p>Removes the provided device adapter from the list of devices to try. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5b3d4f4c88b6b4edc5c0e3ff9146455c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3d4f4c88b6b4edc5c0e3ff9146455c">&#9670;&nbsp;</a></span>ArrayCopy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SourceArrayType , typename DestArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArrayCopy </td>
          <td>(</td>
          <td class="paramtype">const SourceArrayType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DestArrayType &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does a deep copy from one array to another array. </p>
<p>Given a source <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> and a destination <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>, this function allocates the destination <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> to the correct size and deeply copies all the values from the source to the destination.</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment, the runtime device tracker is used to try to find another device.</p>
<p>This should work on some non-writable array handles as well, as long as both <em>source</em> and <em>destination</em> are the same type.</p>
<p>This version of array copy uses a precompiled version of copy that is efficient for most standard memory layouts. However, there are some types of fancy <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> that cannot be handled directly, and the fallback for these arrays can be slow. If you see a warning in the log about an inefficient memory copy when extracting a component, pay heed and look for a different way to copy the data (perhaps using <code>ArrayCopyDevice</code>). </p>

</div>
</div>
<a id="ab385e62169c184753af6b86840f76a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab385e62169c184753af6b86840f76a5f">&#9670;&nbsp;</a></span>ArrayCopy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SourceArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArrayCopy </td>
          <td>(</td>
          <td class="paramtype">const SourceArrayType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does a deep copy from one array to another array. </p>
<p>Given a source <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> and a destination <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>, this function allocates the destination <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> to the correct size and deeply copies all the values from the source to the destination.</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment, the runtime device tracker is used to try to find another device.</p>
<p>This should work on some non-writable array handles as well, as long as both <em>source</em> and <em>destination</em> are the same type.</p>
<p>This version of array copy uses a precompiled version of copy that is efficient for most standard memory layouts. However, there are some types of fancy <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> that cannot be handled directly, and the fallback for these arrays can be slow. If you see a warning in the log about an inefficient memory copy when extracting a component, pay heed and look for a different way to copy the data (perhaps using <code>ArrayCopyDevice</code>). </p>

</div>
</div>
<a id="a19a61040a75e0fbb5c32e8726434cd2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a61040a75e0fbb5c32e8726434cd2f">&#9670;&nbsp;</a></span>ArrayCopy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArrayCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3673acaf19f7f3d84e664c0ea686d21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3673acaf19f7f3d84e664c0ea686d21d">&#9670;&nbsp;</a></span>ArrayCopyDevice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InValueType , typename InStorage , typename OutValueType , typename OutStorage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArrayCopyDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; InValueType, InStorage &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; OutValueType, OutStorage &gt; &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does a deep copy from one array to another array. </p>
<p>Given a source <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> and a destination <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>, this function allocates the destination <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> to the correct size and deeply copies all the values from the source to the destination.</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment, the runtime device tracker is used to try to find another device.</p>
<p>This should work on some non-writable array handles as well, as long as both <em>source</em> and <em>destination</em> are the same type.</p>
<p>This version of array copy is templated to create custom code for the particular types of <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>s that you are copying. This will ensure that you get the best possible copy, but requires a device compiler and tends to bloat the code. </p>

</div>
</div>
<a id="a10609ea9407d6237ca1dec8669a511f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10609ea9407d6237ca1dec8669a511f3">&#9670;&nbsp;</a></span>ArrayCopyShallowIfPossible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArrayCopyShallowIfPossible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies from an unknown to a known array type. </p>
<p>Often times you have an array of an unknown type (likely from a data set), and you need it to be of a particular type (or can make a reasonable but uncertain assumption about it being a particular type). You really just want a shallow copy (a reference in a concrete <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>) if that is possible.</p>
<p><code><a class="el" href="namespaceviskores_1_1cont.html#a10609ea9407d6237ca1dec8669a511f3" title="Copies from an unknown to a known array type.">ArrayCopyShallowIfPossible()</a></code> pulls an array of a specific type from an <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code>. If the type is compatible, it will perform a shallow copy. If it is not possible, a deep copy is performed to get it to the correct type. </p>

</div>
</div>
<a id="a2331ab862cd8447e45bb20f465412857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2331ab862cd8447e45bb20f465412857">&#9670;&nbsp;</a></span>ArrayExtractComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleStride.html">viskores::cont::ArrayHandleStride</a>&lt;typename <a class="el" href="structviskores_1_1VecTraits.html">viskores::VecTraits</a>&lt;T&gt;::BaseComponentType&gt; viskores::cont::ArrayExtractComponent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>componentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>allowCopy</em> = <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3">viskores::CopyFlag::On</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pulls a component out of an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>. </p>
<p>Given an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> of any type, <code>ArrayExtractComponent</code> returns an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleStride.html" title="An ArrayHandle that accesses a basic array with strides and offsets.">ArrayHandleStride</a></code> of the base component type that contains the data for the specified array component. This function can be used to apply an operation on an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> one component at a time. Because the array type is always <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleStride.html" title="An ArrayHandle that accesses a basic array with strides and offsets.">ArrayHandleStride</a></code>, you can drastically cut down on the number of templates to instantiate (at a possible cost to performance).</p>
<p>Note that <code>ArrayExtractComponent</code> will flatten out the indices of any vec value type and return an <code>ArrayExtractComponent</code> of the base component type. For example, if you call <code>ArrayExtractComponent</code> on an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> with a value type of <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a>&lt;<a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a>&lt;<a class="el" href="namespaceviskores.html#afcbbc86b7129a2612785d217e77a633a" title="Base type to use for 32-bit floating-point numbers.">viskores::Float32</a>, 2&gt;, 3&gt;</code>, you will get an <code>ArrayExtractComponent&lt;<a class="el" href="namespaceviskores.html#afcbbc86b7129a2612785d217e77a633a" title="Base type to use for 32-bit floating-point numbers.">viskores::Float32</a>&gt;</code> returned. The <code>componentIndex</code> provided will be applied to the nested vector in depth first order. So in the previous example, a <code>componentIndex</code> of 0 gets the values at [0][0], <code>componentIndex</code> of 1 gets [0][1], <code>componentIndex</code> of 2 gets [1][0], and so on.</p>
<p>Some <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>s allow this method to return an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleStride.html" title="An ArrayHandle that accesses a basic array with strides and offsets.">ArrayHandleStride</a></code> that shares the same memory as the the original <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>. This form will be used if possible. In this case, if data are written into the <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleStride.html" title="An ArrayHandle that accesses a basic array with strides and offsets.">ArrayHandleStride</a></code>, they are also written into the original <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>. However, other forms will require copies into a new array. In this case, writes into <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleStride.html" title="An ArrayHandle that accesses a basic array with strides and offsets.">ArrayHandleStride</a></code> will not affect the original <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>.</p>
<p>For some operations, such as writing into an output array, this behavior of shared arrays is necessary. For this case, the optional argument <code>allowCopy</code> can be set to <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a></code> to prevent the copying behavior into the return <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleStride.html" title="An ArrayHandle that accesses a basic array with strides and offsets.">ArrayHandleStride</a></code>. If this is the case, an <code><a class="el" href="classviskores_1_1cont_1_1ErrorBadValue.html" title="This class is thrown when a Viskores function or method encounters an invalid value that inhibits pro...">ErrorBadValue</a></code> is thrown. If the arrays can be shared, they always will be regardless of the value of <code>allowCopy</code>.</p>
<p>Many forms of <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> have optimized versions to pull out a component. Some, however, do not. In these cases, a fallback array copy, done in serial, will be performed. A warning will be logged to alert users of this likely performance bottleneck.</p>
<p>As an implementation note, this function should not be overloaded directly. Instead, <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> implementations should provide a specialization of <code>viskores::cont::internal::ArrayExtractComponentImpl</code>. </p>

</div>
</div>
<a id="a41a300337f3f848bd77b125454ac9f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a300337f3f848bd77b125454ac9f00">&#9670;&nbsp;</a></span>ArrayGetValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T viskores::cont::ArrayGetValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a small set of values from an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>data</em> at the indices in <em>ids</em> are copied into a new array and returned. This is useful for retrieving a subset of an array from a device without transferring the entire array to the host.</p>
<p>These functions should not be called repeatedly in a loop to fetch all values from an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a> and <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a7d28220785ee72f97469b29a7b587443" title="Get an array portal that can be used in the control environment.">ArrayHandle::ReadPortal()</a>).</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using the ArrayCopy method with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id may be passed into ArrayGetValue, or multiple ids may be specified to ArrayGetValues as an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle&lt;viskores::Id&gt;</a>, a std::vector&lt;viskores::Id&gt;, a c-array (pointer and size), or as a brace-enclosed initializer list.</p>
<p>The single result from ArrayGetValue may be returned or written to an output argument. Multiple results from ArrayGetValues may be returned as an std::vector&lt;T&gt;, or written to an output argument as an ArrayHandle&lt;T&gt; or a std::vector&lt;T&gt;.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first value in an array handle:</span></div>
<div class="line">T firstVal = <a class="code" href="namespaceviskores_1_1cont.html#a41a300337f3f848bd77b125454ac9f00">viskores::cont::ArrayGetValue</a>(0, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and third values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndThird = <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, 2}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and last values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndLast =</div>
<div class="line">    <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, data.<a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">GetNumberOfValues</a>() - 1}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first 4 values into an array handle:</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> firstFour;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>(ids, data, firstFour);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3a8e4b63c519616e30ea09058608993d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8e4b63c519616e30ea09058608993d">&#9670;&nbsp;</a></span>ArrayGetValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArrayGetValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a small set of values from an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>data</em> at the indices in <em>ids</em> are copied into a new array and returned. This is useful for retrieving a subset of an array from a device without transferring the entire array to the host.</p>
<p>These functions should not be called repeatedly in a loop to fetch all values from an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a> and <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a7d28220785ee72f97469b29a7b587443" title="Get an array portal that can be used in the control environment.">ArrayHandle::ReadPortal()</a>).</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using the ArrayCopy method with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id may be passed into ArrayGetValue, or multiple ids may be specified to ArrayGetValues as an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle&lt;viskores::Id&gt;</a>, a std::vector&lt;viskores::Id&gt;, a c-array (pointer and size), or as a brace-enclosed initializer list.</p>
<p>The single result from ArrayGetValue may be returned or written to an output argument. Multiple results from ArrayGetValues may be returned as an std::vector&lt;T&gt;, or written to an output argument as an ArrayHandle&lt;T&gt; or a std::vector&lt;T&gt;.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first value in an array handle:</span></div>
<div class="line">T firstVal = <a class="code" href="namespaceviskores_1_1cont.html#a41a300337f3f848bd77b125454ac9f00">viskores::cont::ArrayGetValue</a>(0, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and third values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndThird = <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, 2}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and last values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndLast =</div>
<div class="line">    <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, data.<a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">GetNumberOfValues</a>() - 1}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first 4 values into an array handle:</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> firstFour;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>(ids, data, firstFour);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af40004c6a4496def4d696fdb9438d6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40004c6a4496def4d696fdb9438d6bf">&#9670;&nbsp;</a></span>ArrayGetValues() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; viskores::cont::ArrayGetValues </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a small set of values from an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>data</em> at the indices in <em>ids</em> are copied into a new array and returned. This is useful for retrieving a subset of an array from a device without transferring the entire array to the host.</p>
<p>These functions should not be called repeatedly in a loop to fetch all values from an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a> and <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a7d28220785ee72f97469b29a7b587443" title="Get an array portal that can be used in the control environment.">ArrayHandle::ReadPortal()</a>).</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using the ArrayCopy method with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id may be passed into ArrayGetValue, or multiple ids may be specified to ArrayGetValues as an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle&lt;viskores::Id&gt;</a>, a std::vector&lt;viskores::Id&gt;, a c-array (pointer and size), or as a brace-enclosed initializer list.</p>
<p>The single result from ArrayGetValue may be returned or written to an output argument. Multiple results from ArrayGetValues may be returned as an std::vector&lt;T&gt;, or written to an output argument as an ArrayHandle&lt;T&gt; or a std::vector&lt;T&gt;.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first value in an array handle:</span></div>
<div class="line">T firstVal = <a class="code" href="namespaceviskores_1_1cont.html#a41a300337f3f848bd77b125454ac9f00">viskores::cont::ArrayGetValue</a>(0, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and third values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndThird = <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, 2}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and last values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndLast =</div>
<div class="line">    <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, data.<a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">GetNumberOfValues</a>() - 1}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first 4 values into an array handle:</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> firstFour;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>(ids, data, firstFour);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8b66fc4ae409d2178b90034bb90fa9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b66fc4ae409d2178b90034bb90fa9f7">&#9670;&nbsp;</a></span>ArrayGetValues() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SData , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArrayGetValues </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a small set of values from an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>data</em> at the indices in <em>ids</em> are copied into a new array and returned. This is useful for retrieving a subset of an array from a device without transferring the entire array to the host.</p>
<p>These functions should not be called repeatedly in a loop to fetch all values from an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a> and <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a7d28220785ee72f97469b29a7b587443" title="Get an array portal that can be used in the control environment.">ArrayHandle::ReadPortal()</a>).</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using the ArrayCopy method with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id may be passed into ArrayGetValue, or multiple ids may be specified to ArrayGetValues as an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle&lt;viskores::Id&gt;</a>, a std::vector&lt;viskores::Id&gt;, a c-array (pointer and size), or as a brace-enclosed initializer list.</p>
<p>The single result from ArrayGetValue may be returned or written to an output argument. Multiple results from ArrayGetValues may be returned as an std::vector&lt;T&gt;, or written to an output argument as an ArrayHandle&lt;T&gt; or a std::vector&lt;T&gt;.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first value in an array handle:</span></div>
<div class="line">T firstVal = <a class="code" href="namespaceviskores_1_1cont.html#a41a300337f3f848bd77b125454ac9f00">viskores::cont::ArrayGetValue</a>(0, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and third values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndThird = <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, 2}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and last values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndLast =</div>
<div class="line">    <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, data.<a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">GetNumberOfValues</a>() - 1}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first 4 values into an array handle:</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> firstFour;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>(ids, data, firstFour);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a202a8611eeb5862f52ad592b1a87958c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202a8611eeb5862f52ad592b1a87958c">&#9670;&nbsp;</a></span>ArrayGetValues() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SData , typename SOut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArrayGetValues </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SOut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a small set of values from an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>data</em> at the indices in <em>ids</em> are copied into a new array and returned. This is useful for retrieving a subset of an array from a device without transferring the entire array to the host.</p>
<p>These functions should not be called repeatedly in a loop to fetch all values from an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a> and <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a7d28220785ee72f97469b29a7b587443" title="Get an array portal that can be used in the control environment.">ArrayHandle::ReadPortal()</a>).</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using the ArrayCopy method with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id may be passed into ArrayGetValue, or multiple ids may be specified to ArrayGetValues as an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle&lt;viskores::Id&gt;</a>, a std::vector&lt;viskores::Id&gt;, a c-array (pointer and size), or as a brace-enclosed initializer list.</p>
<p>The single result from ArrayGetValue may be returned or written to an output argument. Multiple results from ArrayGetValues may be returned as an std::vector&lt;T&gt;, or written to an output argument as an ArrayHandle&lt;T&gt; or a std::vector&lt;T&gt;.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first value in an array handle:</span></div>
<div class="line">T firstVal = <a class="code" href="namespaceviskores_1_1cont.html#a41a300337f3f848bd77b125454ac9f00">viskores::cont::ArrayGetValue</a>(0, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and third values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndThird = <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, 2}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and last values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndLast =</div>
<div class="line">    <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, data.<a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">GetNumberOfValues</a>() - 1}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first 4 values into an array handle:</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> firstFour;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>(ids, data, firstFour);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a43de893eb8a9041973fd9ddb2c591d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43de893eb8a9041973fd9ddb2c591d91">&#9670;&nbsp;</a></span>ArrayGetValues() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc , typename SData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; viskores::cont::ArrayGetValues </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a small set of values from an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>data</em> at the indices in <em>ids</em> are copied into a new array and returned. This is useful for retrieving a subset of an array from a device without transferring the entire array to the host.</p>
<p>These functions should not be called repeatedly in a loop to fetch all values from an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a> and <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a7d28220785ee72f97469b29a7b587443" title="Get an array portal that can be used in the control environment.">ArrayHandle::ReadPortal()</a>).</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using the ArrayCopy method with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id may be passed into ArrayGetValue, or multiple ids may be specified to ArrayGetValues as an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle&lt;viskores::Id&gt;</a>, a std::vector&lt;viskores::Id&gt;, a c-array (pointer and size), or as a brace-enclosed initializer list.</p>
<p>The single result from ArrayGetValue may be returned or written to an output argument. Multiple results from ArrayGetValues may be returned as an std::vector&lt;T&gt;, or written to an output argument as an ArrayHandle&lt;T&gt; or a std::vector&lt;T&gt;.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first value in an array handle:</span></div>
<div class="line">T firstVal = <a class="code" href="namespaceviskores_1_1cont.html#a41a300337f3f848bd77b125454ac9f00">viskores::cont::ArrayGetValue</a>(0, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and third values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndThird = <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, 2}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and last values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndLast =</div>
<div class="line">    <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, data.<a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">GetNumberOfValues</a>() - 1}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first 4 values into an array handle:</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> firstFour;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>(ids, data, firstFour);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a86f61294f7babe1e8eefe5c9b2863869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f61294f7babe1e8eefe5c9b2863869">&#9670;&nbsp;</a></span>ArrayGetValues() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc , typename SData , typename SOut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArrayGetValues </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SOut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a small set of values from an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>data</em> at the indices in <em>ids</em> are copied into a new array and returned. This is useful for retrieving a subset of an array from a device without transferring the entire array to the host.</p>
<p>These functions should not be called repeatedly in a loop to fetch all values from an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a> and <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a7d28220785ee72f97469b29a7b587443" title="Get an array portal that can be used in the control environment.">ArrayHandle::ReadPortal()</a>).</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using the ArrayCopy method with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id may be passed into ArrayGetValue, or multiple ids may be specified to ArrayGetValues as an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle&lt;viskores::Id&gt;</a>, a std::vector&lt;viskores::Id&gt;, a c-array (pointer and size), or as a brace-enclosed initializer list.</p>
<p>The single result from ArrayGetValue may be returned or written to an output argument. Multiple results from ArrayGetValues may be returned as an std::vector&lt;T&gt;, or written to an output argument as an ArrayHandle&lt;T&gt; or a std::vector&lt;T&gt;.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first value in an array handle:</span></div>
<div class="line">T firstVal = <a class="code" href="namespaceviskores_1_1cont.html#a41a300337f3f848bd77b125454ac9f00">viskores::cont::ArrayGetValue</a>(0, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and third values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndThird = <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, 2}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and last values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndLast =</div>
<div class="line">    <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, data.<a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">GetNumberOfValues</a>() - 1}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first 4 values into an array handle:</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> firstFour;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>(ids, data, firstFour);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad3d634ea552b1086541f4a5bb58fa45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d634ea552b1086541f4a5bb58fa45b">&#9670;&nbsp;</a></span>ArrayGetValues() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename AllocId , typename SData , typename AllocOut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArrayGetValues </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, AllocId &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T, AllocOut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a small set of values from an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>data</em> at the indices in <em>ids</em> are copied into a new array and returned. This is useful for retrieving a subset of an array from a device without transferring the entire array to the host.</p>
<p>These functions should not be called repeatedly in a loop to fetch all values from an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a> and <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a7d28220785ee72f97469b29a7b587443" title="Get an array portal that can be used in the control environment.">ArrayHandle::ReadPortal()</a>).</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using the ArrayCopy method with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id may be passed into ArrayGetValue, or multiple ids may be specified to ArrayGetValues as an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle&lt;viskores::Id&gt;</a>, a std::vector&lt;viskores::Id&gt;, a c-array (pointer and size), or as a brace-enclosed initializer list.</p>
<p>The single result from ArrayGetValue may be returned or written to an output argument. Multiple results from ArrayGetValues may be returned as an std::vector&lt;T&gt;, or written to an output argument as an ArrayHandle&lt;T&gt; or a std::vector&lt;T&gt;.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first value in an array handle:</span></div>
<div class="line">T firstVal = <a class="code" href="namespaceviskores_1_1cont.html#a41a300337f3f848bd77b125454ac9f00">viskores::cont::ArrayGetValue</a>(0, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and third values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndThird = <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, 2}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and last values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndLast =</div>
<div class="line">    <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, data.<a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">GetNumberOfValues</a>() - 1}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first 4 values into an array handle:</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> firstFour;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>(ids, data, firstFour);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0b6c6dea53174478b3b27159699abd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6c6dea53174478b3b27159699abd45">&#9670;&nbsp;</a></span>ArrayGetValues() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SIds , typename T , typename SData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; viskores::cont::ArrayGetValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, SIds &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a small set of values from an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>data</em> at the indices in <em>ids</em> are copied into a new array and returned. This is useful for retrieving a subset of an array from a device without transferring the entire array to the host.</p>
<p>These functions should not be called repeatedly in a loop to fetch all values from an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a> and <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a7d28220785ee72f97469b29a7b587443" title="Get an array portal that can be used in the control environment.">ArrayHandle::ReadPortal()</a>).</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using the ArrayCopy method with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id may be passed into ArrayGetValue, or multiple ids may be specified to ArrayGetValues as an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle&lt;viskores::Id&gt;</a>, a std::vector&lt;viskores::Id&gt;, a c-array (pointer and size), or as a brace-enclosed initializer list.</p>
<p>The single result from ArrayGetValue may be returned or written to an output argument. Multiple results from ArrayGetValues may be returned as an std::vector&lt;T&gt;, or written to an output argument as an ArrayHandle&lt;T&gt; or a std::vector&lt;T&gt;.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first value in an array handle:</span></div>
<div class="line">T firstVal = <a class="code" href="namespaceviskores_1_1cont.html#a41a300337f3f848bd77b125454ac9f00">viskores::cont::ArrayGetValue</a>(0, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and third values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndThird = <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, 2}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and last values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndLast =</div>
<div class="line">    <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, data.<a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">GetNumberOfValues</a>() - 1}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first 4 values into an array handle:</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> firstFour;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>(ids, data, firstFour);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae949ebe6e402697c8c598b547518878c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae949ebe6e402697c8c598b547518878c">&#9670;&nbsp;</a></span>ArrayGetValues() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SIds , typename T , typename SData , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArrayGetValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, SIds &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a small set of values from an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>data</em> at the indices in <em>ids</em> are copied into a new array and returned. This is useful for retrieving a subset of an array from a device without transferring the entire array to the host.</p>
<p>These functions should not be called repeatedly in a loop to fetch all values from an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a> and <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a7d28220785ee72f97469b29a7b587443" title="Get an array portal that can be used in the control environment.">ArrayHandle::ReadPortal()</a>).</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using the ArrayCopy method with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id may be passed into ArrayGetValue, or multiple ids may be specified to ArrayGetValues as an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle&lt;viskores::Id&gt;</a>, a std::vector&lt;viskores::Id&gt;, a c-array (pointer and size), or as a brace-enclosed initializer list.</p>
<p>The single result from ArrayGetValue may be returned or written to an output argument. Multiple results from ArrayGetValues may be returned as an std::vector&lt;T&gt;, or written to an output argument as an ArrayHandle&lt;T&gt; or a std::vector&lt;T&gt;.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first value in an array handle:</span></div>
<div class="line">T firstVal = <a class="code" href="namespaceviskores_1_1cont.html#a41a300337f3f848bd77b125454ac9f00">viskores::cont::ArrayGetValue</a>(0, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and third values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndThird = <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, 2}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and last values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndLast =</div>
<div class="line">    <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, data.<a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">GetNumberOfValues</a>() - 1}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first 4 values into an array handle:</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> firstFour;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>(ids, data, firstFour);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2a660d002917bda52fe319d3a809a344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a660d002917bda52fe319d3a809a344">&#9670;&nbsp;</a></span>ArrayGetValues() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SIds , typename T , typename SData , typename SOut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArrayGetValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, SIds &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SOut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a small set of values from an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>data</em> at the indices in <em>ids</em> are copied into a new array and returned. This is useful for retrieving a subset of an array from a device without transferring the entire array to the host.</p>
<p>These functions should not be called repeatedly in a loop to fetch all values from an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a> and <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a7d28220785ee72f97469b29a7b587443" title="Get an array portal that can be used in the control environment.">ArrayHandle::ReadPortal()</a>).</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using the ArrayCopy method with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id may be passed into ArrayGetValue, or multiple ids may be specified to ArrayGetValues as an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle&lt;viskores::Id&gt;</a>, a std::vector&lt;viskores::Id&gt;, a c-array (pointer and size), or as a brace-enclosed initializer list.</p>
<p>The single result from ArrayGetValue may be returned or written to an output argument. Multiple results from ArrayGetValues may be returned as an std::vector&lt;T&gt;, or written to an output argument as an ArrayHandle&lt;T&gt; or a std::vector&lt;T&gt;.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first value in an array handle:</span></div>
<div class="line">T firstVal = <a class="code" href="namespaceviskores_1_1cont.html#a41a300337f3f848bd77b125454ac9f00">viskores::cont::ArrayGetValue</a>(0, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and third values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndThird = <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, 2}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and last values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndLast =</div>
<div class="line">    <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, data.<a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">GetNumberOfValues</a>() - 1}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first 4 values into an array handle:</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> firstFour;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>(ids, data, firstFour);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a37e0624486659f0bb0f53d3397193361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e0624486659f0bb0f53d3397193361">&#9670;&nbsp;</a></span>ArrayGetValues() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SIds , typename TIn , typename SData , typename TOut , typename SOut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArrayGetValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, SIds &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; TOut, <a class="el" href="structviskores_1_1cont_1_1StorageTagCast.html">viskores::cont::StorageTagCast</a>&lt; TIn, SData &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; TOut, SOut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We need a specialization for <code>ArrayHandleCasts</code> to avoid runtime type missmatch errors inside <code>ArrayGetValuesImpl</code>. </p>

</div>
</div>
<a id="aa6acb973c9b8d8bf863219fdde43b897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6acb973c9b8d8bf863219fdde43b897">&#9670;&nbsp;</a></span>ArrayGetValues() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; viskores::cont::ArrayGetValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a small set of values from an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>data</em> at the indices in <em>ids</em> are copied into a new array and returned. This is useful for retrieving a subset of an array from a device without transferring the entire array to the host.</p>
<p>These functions should not be called repeatedly in a loop to fetch all values from an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a> and <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a7d28220785ee72f97469b29a7b587443" title="Get an array portal that can be used in the control environment.">ArrayHandle::ReadPortal()</a>).</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using the ArrayCopy method with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id may be passed into ArrayGetValue, or multiple ids may be specified to ArrayGetValues as an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle&lt;viskores::Id&gt;</a>, a std::vector&lt;viskores::Id&gt;, a c-array (pointer and size), or as a brace-enclosed initializer list.</p>
<p>The single result from ArrayGetValue may be returned or written to an output argument. Multiple results from ArrayGetValues may be returned as an std::vector&lt;T&gt;, or written to an output argument as an ArrayHandle&lt;T&gt; or a std::vector&lt;T&gt;.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first value in an array handle:</span></div>
<div class="line">T firstVal = <a class="code" href="namespaceviskores_1_1cont.html#a41a300337f3f848bd77b125454ac9f00">viskores::cont::ArrayGetValue</a>(0, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and third values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndThird = <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, 2}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and last values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndLast =</div>
<div class="line">    <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, data.<a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">GetNumberOfValues</a>() - 1}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first 4 values into an array handle:</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> firstFour;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>(ids, data, firstFour);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac730497355f742ba50fb9e170cdde9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac730497355f742ba50fb9e170cdde9e3">&#9670;&nbsp;</a></span>ArrayGetValues() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SData , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArrayGetValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a small set of values from an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>data</em> at the indices in <em>ids</em> are copied into a new array and returned. This is useful for retrieving a subset of an array from a device without transferring the entire array to the host.</p>
<p>These functions should not be called repeatedly in a loop to fetch all values from an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a> and <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a7d28220785ee72f97469b29a7b587443" title="Get an array portal that can be used in the control environment.">ArrayHandle::ReadPortal()</a>).</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using the ArrayCopy method with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id may be passed into ArrayGetValue, or multiple ids may be specified to ArrayGetValues as an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle&lt;viskores::Id&gt;</a>, a std::vector&lt;viskores::Id&gt;, a c-array (pointer and size), or as a brace-enclosed initializer list.</p>
<p>The single result from ArrayGetValue may be returned or written to an output argument. Multiple results from ArrayGetValues may be returned as an std::vector&lt;T&gt;, or written to an output argument as an ArrayHandle&lt;T&gt; or a std::vector&lt;T&gt;.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first value in an array handle:</span></div>
<div class="line">T firstVal = <a class="code" href="namespaceviskores_1_1cont.html#a41a300337f3f848bd77b125454ac9f00">viskores::cont::ArrayGetValue</a>(0, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and third values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndThird = <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, 2}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and last values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndLast =</div>
<div class="line">    <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, data.<a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">GetNumberOfValues</a>() - 1}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first 4 values into an array handle:</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> firstFour;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>(ids, data, firstFour);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a56d50e39ea847e8aab36a552c79d2d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d50e39ea847e8aab36a552c79d2d31">&#9670;&nbsp;</a></span>ArrayGetValues() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SData , typename SOut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArrayGetValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SOut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a small set of values from an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>data</em> at the indices in <em>ids</em> are copied into a new array and returned. This is useful for retrieving a subset of an array from a device without transferring the entire array to the host.</p>
<p>These functions should not be called repeatedly in a loop to fetch all values from an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a> and <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a7d28220785ee72f97469b29a7b587443" title="Get an array portal that can be used in the control environment.">ArrayHandle::ReadPortal()</a>).</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using the ArrayCopy method with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id may be passed into ArrayGetValue, or multiple ids may be specified to ArrayGetValues as an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle&lt;viskores::Id&gt;</a>, a std::vector&lt;viskores::Id&gt;, a c-array (pointer and size), or as a brace-enclosed initializer list.</p>
<p>The single result from ArrayGetValue may be returned or written to an output argument. Multiple results from ArrayGetValues may be returned as an std::vector&lt;T&gt;, or written to an output argument as an ArrayHandle&lt;T&gt; or a std::vector&lt;T&gt;.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first value in an array handle:</span></div>
<div class="line">T firstVal = <a class="code" href="namespaceviskores_1_1cont.html#a41a300337f3f848bd77b125454ac9f00">viskores::cont::ArrayGetValue</a>(0, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and third values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndThird = <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, 2}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first and last values in an array handle:</span></div>
<div class="line">std::vector&lt;T&gt; firstAndLast =</div>
<div class="line">    <a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>({0, data.<a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">GetNumberOfValues</a>() - 1}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fetch the first 4 values into an array handle:</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> firstFour;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a>(ids, data, firstFour);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2e691c31236fe8d278bead85f6dbf605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e691c31236fe8d278bead85f6dbf605">&#9670;&nbsp;</a></span>ArrayPortalToIteratorBegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PortalType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayPortalToIterators.html">viskores::cont::ArrayPortalToIterators</a>&lt;PortalType&gt;::IteratorType viskores::cont::ArrayPortalToIteratorBegin </td>
          <td>(</td>
          <td class="paramtype">const PortalType &amp;&#160;</td>
          <td class="paramname"><em>portal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for converting an <a class="el" href="classviskores_1_1cont_1_1ArrayPortal.html" title="A class that points to and access and array of data.">ArrayPortal</a> to a begin iterator. </p>

</div>
</div>
<a id="a3c820f4759d3d07cc92a1a10669f4521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c820f4759d3d07cc92a1a10669f4521">&#9670;&nbsp;</a></span>ArrayPortalToIteratorEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PortalType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayPortalToIterators.html">viskores::cont::ArrayPortalToIterators</a>&lt;PortalType&gt;::IteratorType viskores::cont::ArrayPortalToIteratorEnd </td>
          <td>(</td>
          <td class="paramtype">const PortalType &amp;&#160;</td>
          <td class="paramname"><em>portal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for converting an <a class="el" href="classviskores_1_1cont_1_1ArrayPortal.html" title="A class that points to and access and array of data.">ArrayPortal</a> to an end iterator. </p>

</div>
</div>
<a id="a75b8ec5e1cfa507b63d6b8837e80ee88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b8ec5e1cfa507b63d6b8837e80ee88">&#9670;&nbsp;</a></span>ArrayRangeCompute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayHandleType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="structviskores_1_1Range.html">viskores::Range</a>&gt; viskores::cont::ArrayRangeCompute </td>
          <td>(</td>
          <td class="paramtype">const ArrayHandleType &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em> = <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5632529f805100e990e69297976f2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5632529f805100e990e69297976f2e9">&#9670;&nbsp;</a></span>ArrayRangeCompute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="structviskores_1_1Range.html">viskores::Range</a>&gt; viskores::cont::ArrayRangeCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>computeFiniteRange</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em> = <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the range of the data in an array handle. </p>
<p>Given an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>, this function computes the range (min and max) of the values in the array. For arrays containing <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a> values, the range is computed for each component, and in the case of nested Vecs, ranges are computed for each of the leaf components.</p>
<p>The <code>array</code> parameter is the input array as a <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">viskores::cont::UnknownArrayHandle</a></code>.</p>
<p>The optional <code>maskArray</code> parameter supports selectively choosing which entries to include in the range. It is an array handle of type <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="namespaceviskores.html#afea83468f8cfcf7f649b1fd42d117a0d" title="Base type to use for 8-bit unsigned integer numbers.">viskores::UInt8</a>&gt;</code>. This array should have the same number of elements as the input array with each value representing the masking status of the corresponding value in the input array (masked if 0 else unmasked). Ignored if empty.</p>
<p>The optional <code>computeFiniteRange</code> parameter specifies whether if non-finite values in the array should be ignored to compute the finite range of the array. For <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a> types, individual component values are considered independantly.</p>
<p>The optional <code>device</code> parameter can be used to specify a device to run the range computation on. The default value is <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html" title="Tag for a device adapter used to specify that any device may be used for an operation.">viskores::cont::DeviceAdapterTagAny</a>{}</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The result is returned in an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> of <code><a class="el" href="structviskores_1_1Range.html" title="Represent a continuous scalar range of values.">Range</a></code> objects. There is one value in the returned array for every component of the input's value type. For nested Vecs the results are stored in depth-first order.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>ArrayRangeCompute</code> takes an <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a> as the input. The implementation uses precompiled and specicialized code for several of the most commonly used value and storage types, with a fallback for other cases. This is so that <a class="el" href="ArrayRangeCompute_8h.html">ArrayRangeCompute.h</a> can be included in code that does not use a device compiler. This should be sufficient for most cases, but if you need to compute the range for an array type that is not explicitly handled by <code>ArrayRangeCompute</code> and the fallback code is not performant, use the templated version <code>ArrayRangeComputeTemplate</code>. Specializations can be implemented by specializing the template class <code>ArrayRangeComputeImpl</code>. Please refer to <a class="el" href="ArrayRangeComputeTemplate_8h.html">ArrayRangeComputeTemplate.h</a> for details</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceviskores_1_1cont.html#acfdda9aa9fbdf3033221f01df8940616" title="Templated version of ArrayRangeCompute.">ArrayRangeComputeTemplate</a> </dd></dl>

</div>
</div>
<a id="ae75f1a7a32eb934283bf4bd92d852bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75f1a7a32eb934283bf4bd92d852bb4">&#9670;&nbsp;</a></span>ArrayRangeCompute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="structviskores_1_1Range.html">viskores::Range</a>&gt; viskores::cont::ArrayRangeCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#afea83468f8cfcf7f649b1fd42d117a0d">viskores::UInt8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>maskArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>computeFiniteRange</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em> = <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the range of the data in an array handle. </p>
<p>Given an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>, this function computes the range (min and max) of the values in the array. For arrays containing <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a> values, the range is computed for each component, and in the case of nested Vecs, ranges are computed for each of the leaf components.</p>
<p>The <code>array</code> parameter is the input array as a <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">viskores::cont::UnknownArrayHandle</a></code>.</p>
<p>The optional <code>maskArray</code> parameter supports selectively choosing which entries to include in the range. It is an array handle of type <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="namespaceviskores.html#afea83468f8cfcf7f649b1fd42d117a0d" title="Base type to use for 8-bit unsigned integer numbers.">viskores::UInt8</a>&gt;</code>. This array should have the same number of elements as the input array with each value representing the masking status of the corresponding value in the input array (masked if 0 else unmasked). Ignored if empty.</p>
<p>The optional <code>computeFiniteRange</code> parameter specifies whether if non-finite values in the array should be ignored to compute the finite range of the array. For <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a> types, individual component values are considered independantly.</p>
<p>The optional <code>device</code> parameter can be used to specify a device to run the range computation on. The default value is <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html" title="Tag for a device adapter used to specify that any device may be used for an operation.">viskores::cont::DeviceAdapterTagAny</a>{}</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The result is returned in an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> of <code><a class="el" href="structviskores_1_1Range.html" title="Represent a continuous scalar range of values.">Range</a></code> objects. There is one value in the returned array for every component of the input's value type. For nested Vecs the results are stored in depth-first order.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>ArrayRangeCompute</code> takes an <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a> as the input. The implementation uses precompiled and specicialized code for several of the most commonly used value and storage types, with a fallback for other cases. This is so that <a class="el" href="ArrayRangeCompute_8h.html">ArrayRangeCompute.h</a> can be included in code that does not use a device compiler. This should be sufficient for most cases, but if you need to compute the range for an array type that is not explicitly handled by <code>ArrayRangeCompute</code> and the fallback code is not performant, use the templated version <code>ArrayRangeComputeTemplate</code>. Specializations can be implemented by specializing the template class <code>ArrayRangeComputeImpl</code>. Please refer to <a class="el" href="ArrayRangeComputeTemplate_8h.html">ArrayRangeComputeTemplate.h</a> for details</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceviskores_1_1cont.html#acfdda9aa9fbdf3033221f01df8940616" title="Templated version of ArrayRangeCompute.">ArrayRangeComputeTemplate</a> </dd></dl>

</div>
</div>
<a id="a56fa4be1068d891c9cc1ad7dc5836df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fa4be1068d891c9cc1ad7dc5836df3">&#9670;&nbsp;</a></span>ArrayRangeCompute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="structviskores_1_1Range.html">viskores::Range</a>&gt; viskores::cont::ArrayRangeCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the range of the data in an array handle. </p>
<p>Given an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>, this function computes the range (min and max) of the values in the array. For arrays containing <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a> values, the range is computed for each component, and in the case of nested Vecs, ranges are computed for each of the leaf components.</p>
<p>The <code>array</code> parameter is the input array as a <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">viskores::cont::UnknownArrayHandle</a></code>.</p>
<p>The optional <code>maskArray</code> parameter supports selectively choosing which entries to include in the range. It is an array handle of type <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="namespaceviskores.html#afea83468f8cfcf7f649b1fd42d117a0d" title="Base type to use for 8-bit unsigned integer numbers.">viskores::UInt8</a>&gt;</code>. This array should have the same number of elements as the input array with each value representing the masking status of the corresponding value in the input array (masked if 0 else unmasked). Ignored if empty.</p>
<p>The optional <code>computeFiniteRange</code> parameter specifies whether if non-finite values in the array should be ignored to compute the finite range of the array. For <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a> types, individual component values are considered independantly.</p>
<p>The optional <code>device</code> parameter can be used to specify a device to run the range computation on. The default value is <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html" title="Tag for a device adapter used to specify that any device may be used for an operation.">viskores::cont::DeviceAdapterTagAny</a>{}</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The result is returned in an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> of <code><a class="el" href="structviskores_1_1Range.html" title="Represent a continuous scalar range of values.">Range</a></code> objects. There is one value in the returned array for every component of the input's value type. For nested Vecs the results are stored in depth-first order.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>ArrayRangeCompute</code> takes an <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a> as the input. The implementation uses precompiled and specicialized code for several of the most commonly used value and storage types, with a fallback for other cases. This is so that <a class="el" href="ArrayRangeCompute_8h.html">ArrayRangeCompute.h</a> can be included in code that does not use a device compiler. This should be sufficient for most cases, but if you need to compute the range for an array type that is not explicitly handled by <code>ArrayRangeCompute</code> and the fallback code is not performant, use the templated version <code>ArrayRangeComputeTemplate</code>. Specializations can be implemented by specializing the template class <code>ArrayRangeComputeImpl</code>. Please refer to <a class="el" href="ArrayRangeComputeTemplate_8h.html">ArrayRangeComputeTemplate.h</a> for details</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceviskores_1_1cont.html#acfdda9aa9fbdf3033221f01df8940616" title="Templated version of ArrayRangeCompute.">ArrayRangeComputeTemplate</a> </dd></dl>

</div>
</div>
<a id="a49710decdd08bf5f3d97fb9bd803ac4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49710decdd08bf5f3d97fb9bd803ac4b">&#9670;&nbsp;</a></span>ArrayRangeComputeMagnitude() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1Range.html">viskores::Range</a> viskores::cont::ArrayRangeComputeMagnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>computeFiniteRange</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em> = <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the range of the magnitude of the <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a> data in an array handle. </p>
<p>Given an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>, this function computes the range (min and max) of the magnitude of the values in the array.</p>
<p>The <code>array</code> parameter is the input array as a <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">viskores::cont::UnknownArrayHandle</a></code>.</p>
<p>The optional <code>maskArray</code> parameter supports selectively choosing which entries to include in the range. It is an array handle of type <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="namespaceviskores.html#afea83468f8cfcf7f649b1fd42d117a0d" title="Base type to use for 8-bit unsigned integer numbers.">viskores::UInt8</a>&gt;</code>. This array should have the same number of elements as the input array with each value representing the masking status of the corresponding value in the input array (masked if 0 else unmasked). Ignored if empty.</p>
<p>The optional <code>computeFiniteRange</code> parameter specifies whether if non-finite values in the array should be ignored to compute the finite range of the array. A <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a> with any non-finite component will be ignored.</p>
<p>The optional <code>device</code> parameter can be used to specify a device to run the range computation on. The default value is <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html" title="Tag for a device adapter used to specify that any device may be used for an operation.">viskores::cont::DeviceAdapterTagAny</a>{}</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The result is returned in a single <code><a class="el" href="structviskores_1_1Range.html" title="Represent a continuous scalar range of values.">Range</a></code> objects.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>ArrayRangeComputeMagnitude</code> takes an <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a> as the input. The implementation uses precompiled and specicialized code for several of the most commonly used value and storage types, with a fallback for other cases. This is so that <a class="el" href="ArrayRangeCompute_8h.html">ArrayRangeCompute.h</a> can be included in code that does not use a device compiler. This should be sufficient for most cases, but if you need to compute the range for an array type that is not explicitly handled by <code>ArrayRangeComputeMagnitude</code> and the fallback code is not performant, use the templated version <code>ArrayRangeComputeMagnitudeTemplate</code>. Specializations can be implemented by specializing the template class <code>ArrayRangeComputeMagnitudeImpl</code>. Please refer to <a class="el" href="ArrayRangeComputeTemplate_8h.html">ArrayRangeComputeTemplate.h</a> for details</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceviskores_1_1cont.html#a6800b818269ded14c622733294f1692f" title="Templated version of ArrayRangeComputeMagnitude.">ArrayRangeComputeMagnitudeTemplate</a> </dd></dl>

</div>
</div>
<a id="a142d65159dbe72f40f80e4c56cf21632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142d65159dbe72f40f80e4c56cf21632">&#9670;&nbsp;</a></span>ArrayRangeComputeMagnitude() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1Range.html">viskores::Range</a> viskores::cont::ArrayRangeComputeMagnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#afea83468f8cfcf7f649b1fd42d117a0d">viskores::UInt8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>maskArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>computeFiniteRange</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em> = <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the range of the magnitude of the <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a> data in an array handle. </p>
<p>Given an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>, this function computes the range (min and max) of the magnitude of the values in the array.</p>
<p>The <code>array</code> parameter is the input array as a <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">viskores::cont::UnknownArrayHandle</a></code>.</p>
<p>The optional <code>maskArray</code> parameter supports selectively choosing which entries to include in the range. It is an array handle of type <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="namespaceviskores.html#afea83468f8cfcf7f649b1fd42d117a0d" title="Base type to use for 8-bit unsigned integer numbers.">viskores::UInt8</a>&gt;</code>. This array should have the same number of elements as the input array with each value representing the masking status of the corresponding value in the input array (masked if 0 else unmasked). Ignored if empty.</p>
<p>The optional <code>computeFiniteRange</code> parameter specifies whether if non-finite values in the array should be ignored to compute the finite range of the array. A <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a> with any non-finite component will be ignored.</p>
<p>The optional <code>device</code> parameter can be used to specify a device to run the range computation on. The default value is <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html" title="Tag for a device adapter used to specify that any device may be used for an operation.">viskores::cont::DeviceAdapterTagAny</a>{}</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The result is returned in a single <code><a class="el" href="structviskores_1_1Range.html" title="Represent a continuous scalar range of values.">Range</a></code> objects.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>ArrayRangeComputeMagnitude</code> takes an <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a> as the input. The implementation uses precompiled and specicialized code for several of the most commonly used value and storage types, with a fallback for other cases. This is so that <a class="el" href="ArrayRangeCompute_8h.html">ArrayRangeCompute.h</a> can be included in code that does not use a device compiler. This should be sufficient for most cases, but if you need to compute the range for an array type that is not explicitly handled by <code>ArrayRangeComputeMagnitude</code> and the fallback code is not performant, use the templated version <code>ArrayRangeComputeMagnitudeTemplate</code>. Specializations can be implemented by specializing the template class <code>ArrayRangeComputeMagnitudeImpl</code>. Please refer to <a class="el" href="ArrayRangeComputeTemplate_8h.html">ArrayRangeComputeTemplate.h</a> for details</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceviskores_1_1cont.html#a6800b818269ded14c622733294f1692f" title="Templated version of ArrayRangeComputeMagnitude.">ArrayRangeComputeMagnitudeTemplate</a> </dd></dl>

</div>
</div>
<a id="ab3fa3fdfb2c3860d80f496466cfdedfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fa3fdfb2c3860d80f496466cfdedfa">&#9670;&nbsp;</a></span>ArrayRangeComputeMagnitude() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1Range.html">viskores::Range</a> viskores::cont::ArrayRangeComputeMagnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the range of the magnitude of the <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a> data in an array handle. </p>
<p>Given an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>, this function computes the range (min and max) of the magnitude of the values in the array.</p>
<p>The <code>array</code> parameter is the input array as a <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">viskores::cont::UnknownArrayHandle</a></code>.</p>
<p>The optional <code>maskArray</code> parameter supports selectively choosing which entries to include in the range. It is an array handle of type <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="namespaceviskores.html#afea83468f8cfcf7f649b1fd42d117a0d" title="Base type to use for 8-bit unsigned integer numbers.">viskores::UInt8</a>&gt;</code>. This array should have the same number of elements as the input array with each value representing the masking status of the corresponding value in the input array (masked if 0 else unmasked). Ignored if empty.</p>
<p>The optional <code>computeFiniteRange</code> parameter specifies whether if non-finite values in the array should be ignored to compute the finite range of the array. A <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a> with any non-finite component will be ignored.</p>
<p>The optional <code>device</code> parameter can be used to specify a device to run the range computation on. The default value is <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html" title="Tag for a device adapter used to specify that any device may be used for an operation.">viskores::cont::DeviceAdapterTagAny</a>{}</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The result is returned in a single <code><a class="el" href="structviskores_1_1Range.html" title="Represent a continuous scalar range of values.">Range</a></code> objects.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>ArrayRangeComputeMagnitude</code> takes an <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a> as the input. The implementation uses precompiled and specicialized code for several of the most commonly used value and storage types, with a fallback for other cases. This is so that <a class="el" href="ArrayRangeCompute_8h.html">ArrayRangeCompute.h</a> can be included in code that does not use a device compiler. This should be sufficient for most cases, but if you need to compute the range for an array type that is not explicitly handled by <code>ArrayRangeComputeMagnitude</code> and the fallback code is not performant, use the templated version <code>ArrayRangeComputeMagnitudeTemplate</code>. Specializations can be implemented by specializing the template class <code>ArrayRangeComputeMagnitudeImpl</code>. Please refer to <a class="el" href="ArrayRangeComputeTemplate_8h.html">ArrayRangeComputeTemplate.h</a> for details</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceviskores_1_1cont.html#a6800b818269ded14c622733294f1692f" title="Templated version of ArrayRangeComputeMagnitude.">ArrayRangeComputeMagnitudeTemplate</a> </dd></dl>

</div>
</div>
<a id="a6800b818269ded14c622733294f1692f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6800b818269ded14c622733294f1692f">&#9670;&nbsp;</a></span>ArrayRangeComputeMagnitudeTemplate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1Range.html">viskores::Range</a> viskores::cont::ArrayRangeComputeMagnitudeTemplate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>computeFiniteRange</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em> = <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Templated version of ArrayRangeComputeMagnitude. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceviskores_1_1cont.html#a49710decdd08bf5f3d97fb9bd803ac4b" title="Compute the range of the magnitude of the Vec data in an array handle.">ArrayRangeComputeMagnitude</a> </dd></dl>

</div>
</div>
<a id="a1cc72e4a8991872fe97144331081bb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc72e4a8991872fe97144331081bb48">&#9670;&nbsp;</a></span>ArrayRangeComputeMagnitudeTemplate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1Range.html">viskores::Range</a> viskores::cont::ArrayRangeComputeMagnitudeTemplate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#afea83468f8cfcf7f649b1fd42d117a0d">viskores::UInt8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>maskArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>computeFiniteRange</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em> = <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Templated version of ArrayRangeComputeMagnitude. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceviskores_1_1cont.html#a49710decdd08bf5f3d97fb9bd803ac4b" title="Compute the range of the magnitude of the Vec data in an array handle.">ArrayRangeComputeMagnitude</a> </dd></dl>

</div>
</div>
<a id="a6e2ad2cd4d12aff801d327d2907aec97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2ad2cd4d12aff801d327d2907aec97">&#9670;&nbsp;</a></span>ArrayRangeComputeMagnitudeTemplate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1Range.html">viskores::Range</a> viskores::cont::ArrayRangeComputeMagnitudeTemplate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Templated version of ArrayRangeComputeMagnitude. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceviskores_1_1cont.html#a49710decdd08bf5f3d97fb9bd803ac4b" title="Compute the range of the magnitude of the Vec data in an array handle.">ArrayRangeComputeMagnitude</a> </dd></dl>

</div>
</div>
<a id="acfdda9aa9fbdf3033221f01df8940616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfdda9aa9fbdf3033221f01df8940616">&#9670;&nbsp;</a></span>ArrayRangeComputeTemplate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="structviskores_1_1Range.html">viskores::Range</a>&gt; viskores::cont::ArrayRangeComputeTemplate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>computeFiniteRange</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em> = <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Templated version of ArrayRangeCompute. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceviskores_1_1cont.html#ad5632529f805100e990e69297976f2e9" title="Compute the range of the data in an array handle.">ArrayRangeCompute</a> </dd></dl>

</div>
</div>
<a id="adc87137b0f3bcdb1f7d6f164c6d01960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc87137b0f3bcdb1f7d6f164c6d01960">&#9670;&nbsp;</a></span>ArrayRangeComputeTemplate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="structviskores_1_1Range.html">viskores::Range</a>&gt; viskores::cont::ArrayRangeComputeTemplate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#afea83468f8cfcf7f649b1fd42d117a0d">viskores::UInt8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>maskArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>computeFiniteRange</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em> = <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Templated version of ArrayRangeCompute. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceviskores_1_1cont.html#ad5632529f805100e990e69297976f2e9" title="Compute the range of the data in an array handle.">ArrayRangeCompute</a> </dd></dl>

</div>
</div>
<a id="adb9237595dcb3fef3dd3fb84e99be530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9237595dcb3fef3dd3fb84e99be530">&#9670;&nbsp;</a></span>ArrayRangeComputeTemplate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="structviskores_1_1Range.html">viskores::Range</a>&gt; viskores::cont::ArrayRangeComputeTemplate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Templated version of ArrayRangeCompute. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceviskores_1_1cont.html#ad5632529f805100e990e69297976f2e9" title="Compute the range of the data in an array handle.">ArrayRangeCompute</a> </dd></dl>

</div>
</div>
<a id="a1e1482b3e7c4cbb782db98b3cc5c86c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1482b3e7c4cbb782db98b3cc5c86c3">&#9670;&nbsp;</a></span>ArraySetValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArraySetValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a single value in an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> at the specified index. </p>
<p>This is a convenience function that sets a single value at the given index. It is equivalent to calling ArraySetValues with single-element arrays. </p>

</div>
</div>
<a id="ab5fc8719dabdcee950536d42c87f7ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fc8719dabdcee950536d42c87f7ddd">&#9670;&nbsp;</a></span>ArraySetValues() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArraySetValues </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a small set of values in an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>values</em> are copied into <em>data</em> at the indices specified in <em>ids</em>. This is useful for updating a subset of an array on a device without transferring the entire array.</p>
<p>These functions should not be called repeatedly in a loop to set all values in an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a>) or to do so in a worklet.</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using ArrayCopy with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id and value may be passed into ArraySetValue, or multiple ids and values may be specified to ArraySetValues as ArrayHandles, std::vectors, c-arrays (pointer and size), or as brace-enclosed initializer lists.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set a single value in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a1e1482b3e7c4cbb782db98b3cc5c86c3">viskores::cont::ArraySetValue</a>(0, T{42}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the first and third values in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>({0, 2}, {T{10}, T{30}}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using std::vector</span></div>
<div class="line">std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line">std::vector&lt;T&gt; values{T{10}, T{20}, T{30}, T{40}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(ids, values, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using array handles directly</span></div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;viskores::Id&gt;</a> idsHandle;</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> valuesHandle;</div>
<div class="line"><span class="comment">// ... populate handles ...</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(idsHandle, valuesHandle, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using raw pointers</span></div>
<div class="line"><a class="code" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> rawIds[] = {0, 1, 2};</div>
<div class="line">T rawValues[] = {T{10}, T{20}, T{30}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(rawIds, 3, rawValues, 3, data);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a695378bf2c1f629e48ac8829410c6100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695378bf2c1f629e48ac8829410c6100">&#9670;&nbsp;</a></span>ArraySetValues() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SData , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArraySetValues </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a small set of values in an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>values</em> are copied into <em>data</em> at the indices specified in <em>ids</em>. This is useful for updating a subset of an array on a device without transferring the entire array.</p>
<p>These functions should not be called repeatedly in a loop to set all values in an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a>) or to do so in a worklet.</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using ArrayCopy with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id and value may be passed into ArraySetValue, or multiple ids and values may be specified to ArraySetValues as ArrayHandles, std::vectors, c-arrays (pointer and size), or as brace-enclosed initializer lists.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set a single value in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a1e1482b3e7c4cbb782db98b3cc5c86c3">viskores::cont::ArraySetValue</a>(0, T{42}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the first and third values in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>({0, 2}, {T{10}, T{30}}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using std::vector</span></div>
<div class="line">std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line">std::vector&lt;T&gt; values{T{10}, T{20}, T{30}, T{40}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(ids, values, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using array handles directly</span></div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;viskores::Id&gt;</a> idsHandle;</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> valuesHandle;</div>
<div class="line"><span class="comment">// ... populate handles ...</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(idsHandle, valuesHandle, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using raw pointers</span></div>
<div class="line"><a class="code" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> rawIds[] = {0, 1, 2};</div>
<div class="line">T rawValues[] = {T{10}, T{20}, T{30}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(rawIds, 3, rawValues, 3, data);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9a949aa10b526020294d2b92ebb8e159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a949aa10b526020294d2b92ebb8e159">&#9670;&nbsp;</a></span>ArraySetValues() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SValues , typename SData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArraySetValues </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SValues &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a small set of values in an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>values</em> are copied into <em>data</em> at the indices specified in <em>ids</em>. This is useful for updating a subset of an array on a device without transferring the entire array.</p>
<p>These functions should not be called repeatedly in a loop to set all values in an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a>) or to do so in a worklet.</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using ArrayCopy with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id and value may be passed into ArraySetValue, or multiple ids and values may be specified to ArraySetValues as ArrayHandles, std::vectors, c-arrays (pointer and size), or as brace-enclosed initializer lists.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set a single value in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a1e1482b3e7c4cbb782db98b3cc5c86c3">viskores::cont::ArraySetValue</a>(0, T{42}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the first and third values in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>({0, 2}, {T{10}, T{30}}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using std::vector</span></div>
<div class="line">std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line">std::vector&lt;T&gt; values{T{10}, T{20}, T{30}, T{40}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(ids, values, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using array handles directly</span></div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;viskores::Id&gt;</a> idsHandle;</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> valuesHandle;</div>
<div class="line"><span class="comment">// ... populate handles ...</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(idsHandle, valuesHandle, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using raw pointers</span></div>
<div class="line"><a class="code" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> rawIds[] = {0, 1, 2};</div>
<div class="line">T rawValues[] = {T{10}, T{20}, T{30}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(rawIds, 3, rawValues, 3, data);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="acf87e3c4eb7edaca60f5099409752b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf87e3c4eb7edaca60f5099409752b30">&#9670;&nbsp;</a></span>ArraySetValues() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename AllocId , typename AllocVal , typename SData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArraySetValues </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, AllocId &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, AllocVal &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a small set of values in an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>values</em> are copied into <em>data</em> at the indices specified in <em>ids</em>. This is useful for updating a subset of an array on a device without transferring the entire array.</p>
<p>These functions should not be called repeatedly in a loop to set all values in an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a>) or to do so in a worklet.</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using ArrayCopy with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id and value may be passed into ArraySetValue, or multiple ids and values may be specified to ArraySetValues as ArrayHandles, std::vectors, c-arrays (pointer and size), or as brace-enclosed initializer lists.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set a single value in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a1e1482b3e7c4cbb782db98b3cc5c86c3">viskores::cont::ArraySetValue</a>(0, T{42}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the first and third values in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>({0, 2}, {T{10}, T{30}}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using std::vector</span></div>
<div class="line">std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line">std::vector&lt;T&gt; values{T{10}, T{20}, T{30}, T{40}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(ids, values, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using array handles directly</span></div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;viskores::Id&gt;</a> idsHandle;</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> valuesHandle;</div>
<div class="line"><span class="comment">// ... populate handles ...</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(idsHandle, valuesHandle, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using raw pointers</span></div>
<div class="line"><a class="code" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> rawIds[] = {0, 1, 2};</div>
<div class="line">T rawValues[] = {T{10}, T{20}, T{30}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(rawIds, 3, rawValues, 3, data);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae3ac72a44be289836cd176a3210550f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ac72a44be289836cd176a3210550f3">&#9670;&nbsp;</a></span>ArraySetValues() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SIds , typename SValues , typename SData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArraySetValues </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, SIds &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SValues &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a small set of values in an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>values</em> are copied into <em>data</em> at the indices specified in <em>ids</em>. This is useful for updating a subset of an array on a device without transferring the entire array.</p>
<p>These functions should not be called repeatedly in a loop to set all values in an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a>) or to do so in a worklet.</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using ArrayCopy with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id and value may be passed into ArraySetValue, or multiple ids and values may be specified to ArraySetValues as ArrayHandles, std::vectors, c-arrays (pointer and size), or as brace-enclosed initializer lists.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set a single value in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a1e1482b3e7c4cbb782db98b3cc5c86c3">viskores::cont::ArraySetValue</a>(0, T{42}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the first and third values in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>({0, 2}, {T{10}, T{30}}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using std::vector</span></div>
<div class="line">std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line">std::vector&lt;T&gt; values{T{10}, T{20}, T{30}, T{40}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(ids, values, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using array handles directly</span></div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;viskores::Id&gt;</a> idsHandle;</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> valuesHandle;</div>
<div class="line"><span class="comment">// ... populate handles ...</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(idsHandle, valuesHandle, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using raw pointers</span></div>
<div class="line"><a class="code" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> rawIds[] = {0, 1, 2};</div>
<div class="line">T rawValues[] = {T{10}, T{20}, T{30}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(rawIds, 3, rawValues, 3, data);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab17a2b6462f2dfe9dd9c91cce350d7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17a2b6462f2dfe9dd9c91cce350d7f8">&#9670;&nbsp;</a></span>ArraySetValues() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SIds , typename T , typename SData , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArraySetValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, SIds &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a small set of values in an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>values</em> are copied into <em>data</em> at the indices specified in <em>ids</em>. This is useful for updating a subset of an array on a device without transferring the entire array.</p>
<p>These functions should not be called repeatedly in a loop to set all values in an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a>) or to do so in a worklet.</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using ArrayCopy with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id and value may be passed into ArraySetValue, or multiple ids and values may be specified to ArraySetValues as ArrayHandles, std::vectors, c-arrays (pointer and size), or as brace-enclosed initializer lists.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set a single value in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a1e1482b3e7c4cbb782db98b3cc5c86c3">viskores::cont::ArraySetValue</a>(0, T{42}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the first and third values in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>({0, 2}, {T{10}, T{30}}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using std::vector</span></div>
<div class="line">std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line">std::vector&lt;T&gt; values{T{10}, T{20}, T{30}, T{40}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(ids, values, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using array handles directly</span></div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;viskores::Id&gt;</a> idsHandle;</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> valuesHandle;</div>
<div class="line"><span class="comment">// ... populate handles ...</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(idsHandle, valuesHandle, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using raw pointers</span></div>
<div class="line"><a class="code" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> rawIds[] = {0, 1, 2};</div>
<div class="line">T rawValues[] = {T{10}, T{20}, T{30}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(rawIds, 3, rawValues, 3, data);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a25244dd8e50a0973b3d275ed2d67ed00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25244dd8e50a0973b3d275ed2d67ed00">&#9670;&nbsp;</a></span>ArraySetValues() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SIds , typename T , typename SValues , typename SData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArraySetValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, SIds &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SValues &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a small set of values in an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>values</em> are copied into <em>data</em> at the indices specified in <em>ids</em>. This is useful for updating a subset of an array on a device without transferring the entire array.</p>
<p>These functions should not be called repeatedly in a loop to set all values in an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a>) or to do so in a worklet.</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using ArrayCopy with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id and value may be passed into ArraySetValue, or multiple ids and values may be specified to ArraySetValues as ArrayHandles, std::vectors, c-arrays (pointer and size), or as brace-enclosed initializer lists.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set a single value in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a1e1482b3e7c4cbb782db98b3cc5c86c3">viskores::cont::ArraySetValue</a>(0, T{42}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the first and third values in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>({0, 2}, {T{10}, T{30}}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using std::vector</span></div>
<div class="line">std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line">std::vector&lt;T&gt; values{T{10}, T{20}, T{30}, T{40}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(ids, values, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using array handles directly</span></div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;viskores::Id&gt;</a> idsHandle;</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> valuesHandle;</div>
<div class="line"><span class="comment">// ... populate handles ...</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(idsHandle, valuesHandle, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using raw pointers</span></div>
<div class="line"><a class="code" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> rawIds[] = {0, 1, 2};</div>
<div class="line">T rawValues[] = {T{10}, T{20}, T{30}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(rawIds, 3, rawValues, 3, data);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aef3fb95fc597457b15bfc0ddffbe3ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3fb95fc597457b15bfc0ddffbe3ef2">&#9670;&nbsp;</a></span>ArraySetValues() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SIds , typename TIn , typename SValues , typename TOut , typename SData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArraySetValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, SIds &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; TIn, SValues &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; TOut, <a class="el" href="structviskores_1_1cont_1_1StorageTagCast.html">viskores::cont::StorageTagCast</a>&lt; TIn, SData &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization for ArrayHandleCasts. </p>

</div>
</div>
<a id="acda67a6bd495a4b6775d0c76e482f56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda67a6bd495a4b6775d0c76e482f56c">&#9670;&nbsp;</a></span>ArraySetValues() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArraySetValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a small set of values in an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>values</em> are copied into <em>data</em> at the indices specified in <em>ids</em>. This is useful for updating a subset of an array on a device without transferring the entire array.</p>
<p>These functions should not be called repeatedly in a loop to set all values in an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a>) or to do so in a worklet.</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using ArrayCopy with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id and value may be passed into ArraySetValue, or multiple ids and values may be specified to ArraySetValues as ArrayHandles, std::vectors, c-arrays (pointer and size), or as brace-enclosed initializer lists.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set a single value in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a1e1482b3e7c4cbb782db98b3cc5c86c3">viskores::cont::ArraySetValue</a>(0, T{42}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the first and third values in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>({0, 2}, {T{10}, T{30}}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using std::vector</span></div>
<div class="line">std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line">std::vector&lt;T&gt; values{T{10}, T{20}, T{30}, T{40}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(ids, values, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using array handles directly</span></div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;viskores::Id&gt;</a> idsHandle;</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> valuesHandle;</div>
<div class="line"><span class="comment">// ... populate handles ...</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(idsHandle, valuesHandle, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using raw pointers</span></div>
<div class="line"><a class="code" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> rawIds[] = {0, 1, 2};</div>
<div class="line">T rawValues[] = {T{10}, T{20}, T{30}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(rawIds, 3, rawValues, 3, data);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a00f86bf6575e2c9398788eb9db0cd145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f86bf6575e2c9398788eb9db0cd145">&#9670;&nbsp;</a></span>ArraySetValues() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArraySetValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a small set of values in an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>values</em> are copied into <em>data</em> at the indices specified in <em>ids</em>. This is useful for updating a subset of an array on a device without transferring the entire array.</p>
<p>These functions should not be called repeatedly in a loop to set all values in an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a>) or to do so in a worklet.</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using ArrayCopy with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id and value may be passed into ArraySetValue, or multiple ids and values may be specified to ArraySetValues as ArrayHandles, std::vectors, c-arrays (pointer and size), or as brace-enclosed initializer lists.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set a single value in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a1e1482b3e7c4cbb782db98b3cc5c86c3">viskores::cont::ArraySetValue</a>(0, T{42}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the first and third values in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>({0, 2}, {T{10}, T{30}}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using std::vector</span></div>
<div class="line">std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line">std::vector&lt;T&gt; values{T{10}, T{20}, T{30}, T{40}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(ids, values, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using array handles directly</span></div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;viskores::Id&gt;</a> idsHandle;</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> valuesHandle;</div>
<div class="line"><span class="comment">// ... populate handles ...</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(idsHandle, valuesHandle, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using raw pointers</span></div>
<div class="line"><a class="code" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> rawIds[] = {0, 1, 2};</div>
<div class="line">T rawValues[] = {T{10}, T{20}, T{30}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(rawIds, 3, rawValues, 3, data);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a070760fd494e8f90d1846069b828aa9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070760fd494e8f90d1846069b828aa9e">&#9670;&nbsp;</a></span>ArraySetValues() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ArraySetValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, SData &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a small set of values in an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> with minimal device transfers. </p>
<p>The values in <em>values</em> are copied into <em>data</em> at the indices specified in <em>ids</em>. This is useful for updating a subset of an array on a device without transferring the entire array.</p>
<p>These functions should not be called repeatedly in a loop to set all values in an array handle. The much more efficient way to do this is to use the proper control-side portals (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff" title="Get an array portal that can be used in the control environment.">ArrayHandle::WritePortal()</a>) or to do so in a worklet.</p>
<p>This method will attempt to copy the data using the device that the input data is already valid on. If the input data is only valid in the control environment or the device copy fails, a control-side copy is performed.</p>
<p>Since a serial control-side copy may be used, this method is only intended for copying small subsets of the input data. Larger subsets that would benefit from parallelization should prefer using ArrayCopy with an <a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html" title="Implicitly permutes the values in an array.">ArrayHandlePermutation</a>.</p>
<p>This utility provides several convenient overloads:</p>
<p>A single id and value may be passed into ArraySetValue, or multiple ids and values may be specified to ArraySetValues as ArrayHandles, std::vectors, c-arrays (pointer and size), or as brace-enclosed initializer lists.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> data = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set a single value in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a1e1482b3e7c4cbb782db98b3cc5c86c3">viskores::cont::ArraySetValue</a>(0, T{42}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the first and third values in an array handle:</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>({0, 2}, {T{10}, T{30}}, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using std::vector</span></div>
<div class="line">std::vector&lt;viskores::Id&gt; ids{0, 1, 2, 3};</div>
<div class="line">std::vector&lt;T&gt; values{T{10}, T{20}, T{30}, T{40}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(ids, values, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using array handles directly</span></div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;viskores::Id&gt;</a> idsHandle;</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> valuesHandle;</div>
<div class="line"><span class="comment">// ... populate handles ...</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(idsHandle, valuesHandle, data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set values using raw pointers</span></div>
<div class="line"><a class="code" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> rawIds[] = {0, 1, 2};</div>
<div class="line">T rawValues[] = {T{10}, T{20}, T{30}};</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a>(rawIds, 3, rawValues, 3, data);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aac0bd7954e3ca919092981f0f01dfc56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0bd7954e3ca919092981f0f01dfc56">&#9670;&nbsp;</a></span>BoundsCompute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1Bounds.html">viskores::Bounds</a> viskores::cont::BoundsCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>coordinate_system_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3cda2f141570ff29b06b201105ad3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3cda2f141570ff29b06b201105ad3e4">&#9670;&nbsp;</a></span>BoundsCompute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1Bounds.html">viskores::Bounds</a> viskores::cont::BoundsCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>coordinate_system_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functions to compute bounds for a single dataSset or partition dataset. </p>
<p>These are utility functions that compute bounds for a single dataset or partitioned dataset. When Viskores is operating in an distributed environment, these are bounds on the local process. To get global bounds across all ranks, use <code><a class="el" href="namespaceviskores_1_1cont.html#a142da7929dd1d682d1c6dab22b14b1fd" title="Functions to compute bounds for a single dataset or partitioned dataset globally.">viskores::cont::BoundsGlobalCompute</a></code> instead.</p>
<p>Note that if the provided <a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html" title="Manages a coordinate system for a DataSet.">CoordinateSystem</a> does not exists, empty bounds are returned. Likewise, for <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html" title="Comprises a set of viskores::cont::DataSet objects.">PartitionedDataSet</a>, partitions without the chosen <a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html" title="Manages a coordinate system for a DataSet.">CoordinateSystem</a> are skipped. </p>

</div>
</div>
<a id="ad344de6fd29f58ddc538355d8ebdc641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad344de6fd29f58ddc538355d8ebdc641">&#9670;&nbsp;</a></span>BoundsCompute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1Bounds.html">viskores::Bounds</a> viskores::cont::BoundsCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>pds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>coordinate_system_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4c10dea04b3b80449a0fc6c36cf6c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c10dea04b3b80449a0fc6c36cf6c2d">&#9670;&nbsp;</a></span>BoundsCompute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1Bounds.html">viskores::Bounds</a> viskores::cont::BoundsCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>pds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>coordinate_system_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af5ffb909dd6159b29fdde76243aae9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ffb909dd6159b29fdde76243aae9d2">&#9670;&nbsp;</a></span>BoundsGlobalCompute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1Bounds.html">viskores::Bounds</a> viskores::cont::BoundsGlobalCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>coordinate_system_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a142da7929dd1d682d1c6dab22b14b1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142da7929dd1d682d1c6dab22b14b1fd">&#9670;&nbsp;</a></span>BoundsGlobalCompute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1Bounds.html">viskores::Bounds</a> viskores::cont::BoundsGlobalCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>coordinate_system_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functions to compute bounds for a single dataset or partitioned dataset globally. </p>
<p>These are utility functions that compute bounds for a single dataset or partitioned dataset globally i.e. across all ranks when operating in a distributed environment. When Viskores not operating in an distributed environment, these behave same as <code><a class="el" href="namespaceviskores_1_1cont.html#ac3cda2f141570ff29b06b201105ad3e4" title="Functions to compute bounds for a single dataSset or partition dataset.">viskores::cont::BoundsCompute</a></code>.</p>
<p>Note that if the provided <a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html" title="Manages a coordinate system for a DataSet.">CoordinateSystem</a> does not exists, empty bounds are returned. Likewise, for <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html" title="Comprises a set of viskores::cont::DataSet objects.">PartitionedDataSet</a>, partitions without the chosen <a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html" title="Manages a coordinate system for a DataSet.">CoordinateSystem</a> are skipped. </p>

</div>
</div>
<a id="afe39d774cd80a9a2489bcdfc6f25f751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe39d774cd80a9a2489bcdfc6f25f751">&#9670;&nbsp;</a></span>BoundsGlobalCompute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1Bounds.html">viskores::Bounds</a> viskores::cont::BoundsGlobalCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>pds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>coordinate_system_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c7dd5711c223f2e1c45a69a95dabaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7dd5711c223f2e1c45a69a95dabaf5">&#9670;&nbsp;</a></span>BoundsGlobalCompute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1Bounds.html">viskores::Bounds</a> viskores::cont::BoundsGlobalCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>pds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>coordinate_system_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0de1b84413acb19d622228fd0496e5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de1b84413acb19d622228fd0496e5b1">&#9670;&nbsp;</a></span>Cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayHandleType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ArrayHandleType viskores::cont::Cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>variant</code> cast to the given <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> type. </p>
<p>Throws <code><a class="el" href="classviskores_1_1cont_1_1ErrorBadType.html" title="This class is thrown when Viskores encounters data of a type that is incompatible with the current op...">ErrorBadType</a></code> if the cast does not work. Use <code>IsType</code> to check if the cast can happen. </p>

</div>
</div>
<a id="a1d52b84a5ad1f3eb5faae1cf1df1bf5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d52b84a5ad1f3eb5faae1cf1df1bf5b">&#9670;&nbsp;</a></span>Cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CellSetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CellSetType viskores::cont::Cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownCellSet.html">viskores::cont::UnknownCellSet</a> &amp;&#160;</td>
          <td class="paramname"><em>unknownCellSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>unknownCellSet</code> cast to the given <code><a class="el" href="classviskores_1_1cont_1_1CellSet.html" title="Defines the topological structure of the data in a DataSet.">CellSet</a></code> type. </p>
<p>Throws <code><a class="el" href="classviskores_1_1cont_1_1ErrorBadType.html" title="This class is thrown when Viskores encounters data of a type that is incompatible with the current op...">ErrorBadType</a></code> if the cast does not work. Use <code>IsType</code> to check if the cast can happen. </p>

</div>
</div>
<a id="a2279e21253fe7d645b4017e9744c7bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2279e21253fe7d645b4017e9744c7bc6">&#9670;&nbsp;</a></span>CastAndCall() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::CastAndCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html">CoordinateSystem</a> &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A specialization of CastAndCall for basic <a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html" title="Manages a coordinate system for a DataSet.">CoordinateSystem</a> to make it be treated just like any other dynamic object. </p>

</div>
</div>
<a id="a2404df9b667b4f6a7d730de52aa414f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2404df9b667b4f6a7d730de52aa414f0">&#9670;&nbsp;</a></span>CastAndCall() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DynamicObject , typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::CastAndCall </td>
          <td>(</td>
          <td class="paramtype">const DynamicObject &amp;&#160;</td>
          <td class="paramname"><em>dynamicObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Generic interface to CastAndCall. </p>
<p>The default implementation simply calls DynamicObject's CastAndCall, but specializations of this function exist for other classes (e.g. <a class="el" href="classviskores_1_1cont_1_1Field.html" title="A Field encapsulates an array on some piece of the mesh, such as the points, a cell set,...">Field</a>, <a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html" title="Manages a coordinate system for a DataSet.">CoordinateSystem</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>). </p>

</div>
</div>
<a id="a4e88c2df25acbdf335ce7c8506c3a0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e88c2df25acbdf335ce7c8506c3a0da">&#9670;&nbsp;</a></span>CastAndCall() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::CastAndCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A specialization of CastAndCall for <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a>. </p>
<p>Since we have no hints on the types, use VISKORES_DEFAULT_TYPE_LIST and VISKORES_DEFAULT_STORAGE_LIST. </p>

</div>
</div>
<a id="a39820aac8443ff3216eb5ccf8b976015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39820aac8443ff3216eb5ccf8b976015">&#9670;&nbsp;</a></span>CastAndCall() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::CastAndCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A specialization of CastAndCall for basic <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> types, Since the type is already known no deduction is needed. </p>
<p>This specialization is used to simplify numerous worklet algorithms </p>

</div>
</div>
<a id="ac682d6864fbb610c90ac5e3f73f95de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac682d6864fbb610c90ac5e3f73f95de6">&#9670;&nbsp;</a></span>CastAndCall() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S , typename U , typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::CastAndCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1CellSetExplicit.html">viskores::cont::CellSetExplicit</a>&lt; T, S, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>cellset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A specialization of CastAndCall for basic <a class="el" href="classviskores_1_1cont_1_1CellSetExplicit.html" title="Defines an irregular collection of cells.">CellSetExplicit</a> types, Since the type is already known no deduction is needed. </p>
<p>This specialization is used to simplify numerous worklet algorithms </p>

</div>
</div>
<a id="a8049006f821e4659207add170166041a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8049006f821e4659207add170166041a">&#9670;&nbsp;</a></span>CastAndCall() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::CastAndCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1CellSetExtrude.html">viskores::cont::CellSetExtrude</a> &amp;&#160;</td>
          <td class="paramname"><em>cellset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A specialization of CastAndCall for basic <a class="el" href="classviskores_1_1cont_1_1CellSetExtrude.html" title="Defines a 3-dimensional extruded mesh representation.">CellSetExtrude</a> types, Since the type is already known no deduction is needed. </p>
<p>This specialization is used to simplify numerous worklet algorithms </p>

</div>
</div>
<a id="ad50eda64663fe6bb4c8f99ee43df7c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50eda64663fe6bb4c8f99ee43df7c8b">&#9670;&nbsp;</a></span>CastAndCall() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PermutationType , typename CellSetType , typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::CastAndCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1CellSetPermutation.html">viskores::cont::CellSetPermutation</a>&lt; PermutationType, CellSetType &gt; &amp;&#160;</td>
          <td class="paramname"><em>cellset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A specialization of CastAndCall for basic <a class="el" href="classviskores_1_1cont_1_1CellSetPermutation.html" title="Rearranges the cells of one cell set to create another cell set.">CellSetPermutation</a> types, Since the type is already known no deduction is needed. </p>
<p>This specialization is used to simplify numerous worklet algorithms </p>

</div>
</div>
<a id="a544e01121683618cd29736dd58f0f7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544e01121683618cd29736dd58f0f7aa">&#9670;&nbsp;</a></span>CastAndCall() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConnectivityStorageTag , typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::CastAndCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1CellSetSingleType.html">viskores::cont::CellSetSingleType</a>&lt; ConnectivityStorageTag &gt; &amp;&#160;</td>
          <td class="paramname"><em>cellset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A specialization of CastAndCall for basic <a class="el" href="classviskores_1_1cont_1_1CellSetSingleType.html" title="An explicit cell set with all cells of the same shape.">CellSetSingleType</a> types, Since the type is already known no deduction is needed. </p>
<p>This specialization is used to simplify numerous worklet algorithms </p>

</div>
</div>
<a id="a81eebb73b96e2e764125aee2e4b919ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81eebb73b96e2e764125aee2e4b919ec">&#9670;&nbsp;</a></span>CastAndCall() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;viskores::IdComponent Dim, typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::CastAndCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html">viskores::cont::CellSetStructured</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cellset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A specialization of CastAndCall for basic <a class="el" href="classviskores_1_1cont_1_1CellSetStructured.html" title="Defines a 1-, 2-, or 3-dimensional structured grid of points.">CellSetStructured</a> types, Since the type is already known no deduction is needed. </p>
<p>This specialization is used to simplify numerous worklet algorithms </p>

</div>
</div>
<a id="a97d1abe80dbb360358f259f4af38ade6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d1abe80dbb360358f259f4af38ade6">&#9670;&nbsp;</a></span>CastAndCall() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::CastAndCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A specialization of CastAndCall for basic <a class="el" href="classviskores_1_1cont_1_1Field.html" title="A Field encapsulates an array on some piece of the mesh, such as the points, a cell set,...">Field</a> to make it be treated just like any other dynamic object. </p>

</div>
</div>
<a id="adf565c37efd1e135bd27eb9be69eb9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf565c37efd1e135bd27eb9be69eb9be">&#9670;&nbsp;</a></span>CastAndCall() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::CastAndCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownCellSet.html">viskores::cont::UnknownCellSet</a> &amp;&#160;</td>
          <td class="paramname"><em>cellSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A specialization of CastAndCall for unknown cell sets. </p>
<p>A specialization of <code>CastAndCall</code> for <code><a class="el" href="classviskores_1_1cont_1_1UnknownCellSet.html" title="A CellSet of an unknown type.">UnknownCellSet</a></code>.</p>
<p>Since we have no hints on the types, use <code>VISKORES_DEFAULT_CELL_SET_LIST</code>. </p>

</div>
</div>
<a id="a8383ef093396d07bd5a92ae130e7e656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8383ef093396d07bd5a92ae130e7e656">&#9670;&nbsp;</a></span>CastAndCallCellLocatorChooser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CellSetType , typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::CastAndCallCellLocatorChooser </td>
          <td>(</td>
          <td class="paramtype">const CellSetType &amp;&#160;</td>
          <td class="paramname"><em>cellSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html">viskores::cont::CoordinateSystem</a> &amp;&#160;</td>
          <td class="paramname"><em>coordinateSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls a functor with the appropriate type of <code>CellLocator</code>. </p>
<p>Given a cell set and a coordinate system of unknown types, calls a functor with an appropriate CellLocator of the given type. The CellLocator is populated with the provided cell set and coordinate system.</p>
<p>Any additional args are passed to the functor. </p>

</div>
</div>
<a id="a043da6a2c77a613c33d9a5b9b4d332ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043da6a2c77a613c33d9a5b9b4d332ba">&#9670;&nbsp;</a></span>CastAndCallCellLocatorChooser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::CastAndCallCellLocatorChooser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dataSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls a functor with the appropriate type of <code>CellLocator</code>. </p>
<p>Given a <code><a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">DataSet</a></code>, calls a functor with an appropriate CellLocator of the given type. The CellLocator is populated with the provided cell set and coordinate system.</p>
<p>Any additional args are passed to the functor. </p>

</div>
</div>
<a id="ab9dcfec7e073e99c85e0542a1d343b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dcfec7e073e99c85e0542a1d343b05">&#9670;&nbsp;</a></span>ColorTableMap() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::ColorTableMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ColorTable.html">viskores::cont::ColorTable</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#afb51ac2f1b928606ed0381cf7470c2c5">viskores::Vec4ui_8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rgbaOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate each value through the color table to generate RGBA colors. </p>
<p>Each value in <code>values</code> will be sampled through the entire color table to determine a color.</p>
<p>Note: This is more costly than using Sample/Map with the generated intermediate lookup table </p>

</div>
</div>
<a id="afe40a526013a27b1fc3518a69281fba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe40a526013a27b1fc3518a69281fba5">&#9670;&nbsp;</a></span>ColorTableMap() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::ColorTableMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ColorTable.html">viskores::cont::ColorTable</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; <a class="el" href="namespaceviskores.html#afea83468f8cfcf7f649b1fd42d117a0d">viskores::UInt8</a>, 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rgbOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate each value through the color table to generate RGB colors. </p>
<p>Each value in <code>values</code> will be sampled through the entire color table to determine a color.</p>
<p>Note: This is more costly than using Sample/Map with the generated intermediate lookup table </p>

</div>
</div>
<a id="a39fd8a764606792aed22c2f14e1eb6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fd8a764606792aed22c2f14e1eb6b1">&#9670;&nbsp;</a></span>ColorTableMap() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::ColorTableMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ColorTableSamplesRGB.html">viskores::cont::ColorTableSamplesRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a75fb5b3cc80b03eaa494d3075a42faca">viskores::Vec3ui_8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rgbOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample each value through an intermediate lookup/sample table to generate RGB colors. </p>
<p>Each value in <code>values</code> is binned based on its value in relationship to the range of the color table and will use the color value at that bin from the <code>samples</code>. To generate the lookup table use <code>Sample</code> .</p>
<p>Here is a simple example. </p><div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ColorTableSamplesRGB.html">viskores::cont::ColorTableSamplesRGB</a> samples;</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ColorTable.html">viskores::cont::ColorTable</a> table(<span class="stringliteral">&quot;black-body radiation&quot;</span>);</div>
<div class="line">table.Sample(256, samples);</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;viskores::Vec3ui_8&gt;</a> colors;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#acb7bee0f87fc44bbd353e2d80a20a234">viskores::cont::ColorTableMap</a>(input, samples, colors);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="acb7bee0f87fc44bbd353e2d80a20a234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7bee0f87fc44bbd353e2d80a20a234">&#9670;&nbsp;</a></span>ColorTableMap() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::ColorTableMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ColorTableSamplesRGBA.html">viskores::cont::ColorTableSamplesRGBA</a> &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#afb51ac2f1b928606ed0381cf7470c2c5">viskores::Vec4ui_8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rgbaOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample each value through an intermediate lookup/sample table to generate RGBA colors. </p>
<p>Each value in <code>values</code> is binned based on its value in relationship to the range of the color table and will use the color value at that bin from the <code>samples</code>. To generate the lookup table use <code>Sample</code> .</p>
<p>Here is a simple example. </p><div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ColorTableSamplesRGBA.html">viskores::cont::ColorTableSamplesRGBA</a> samples;</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ColorTable.html">viskores::cont::ColorTable</a> table(<span class="stringliteral">&quot;black-body radiation&quot;</span>);</div>
<div class="line">table.Sample(256, samples);</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;viskores::Vec4ui_8&gt;</a> colors;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#acb7bee0f87fc44bbd353e2d80a20a234">viskores::cont::ColorTableMap</a>(input, samples, colors);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad1e78a4275eee7daf9f6c3208fad4ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e78a4275eee7daf9f6c3208fad4ec5">&#9670;&nbsp;</a></span>ColorTableMapComponent() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::ColorTableMapComponent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; T, N &gt;, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ColorTable.html">viskores::cont::ColorTable</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#afb51ac2f1b928606ed0381cf7470c2c5">viskores::Vec4ui_8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rgbaOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use a single component of a vector to generate RGBA colors. </p>

</div>
</div>
<a id="a11ae6911cc7fe1e450dbf79dccc24707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ae6911cc7fe1e450dbf79dccc24707">&#9670;&nbsp;</a></span>ColorTableMapComponent() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::ColorTableMapComponent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; T, N &gt;, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ColorTable.html">viskores::cont::ColorTable</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; <a class="el" href="namespaceviskores.html#afea83468f8cfcf7f649b1fd42d117a0d">viskores::UInt8</a>, 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rgbOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use a single component of a vector to generate RGB colors. </p>

</div>
</div>
<a id="a2863f0324200cec0e451279baf63c55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2863f0324200cec0e451279baf63c55e">&#9670;&nbsp;</a></span>ColorTableMapComponent() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::ColorTableMapComponent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; T, N &gt;, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ColorTableSamplesRGB.html">viskores::cont::ColorTableSamplesRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a75fb5b3cc80b03eaa494d3075a42faca">viskores::Vec3ui_8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rgbOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use a single component of a vector with a sample table to generate RGB colors. </p>

</div>
</div>
<a id="aae49cc7431b9ed125161f73f4011554d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae49cc7431b9ed125161f73f4011554d">&#9670;&nbsp;</a></span>ColorTableMapComponent() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::ColorTableMapComponent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; T, N &gt;, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ColorTableSamplesRGBA.html">viskores::cont::ColorTableSamplesRGBA</a> &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#afb51ac2f1b928606ed0381cf7470c2c5">viskores::Vec4ui_8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rgbaOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use a single component of a vector with a sample table to generate RGBA colors. </p>

</div>
</div>
<a id="a093ddf94e800d08fdb5a29120db38b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093ddf94e800d08fdb5a29120db38b9a">&#9670;&nbsp;</a></span>ColorTableMapMagnitude() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::ColorTableMapMagnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; T, N &gt;, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ColorTable.html">viskores::cont::ColorTable</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#afb51ac2f1b928606ed0381cf7470c2c5">viskores::Vec4ui_8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rgbaOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use magnitude of a vector to generate RGBA colors. </p>

</div>
</div>
<a id="ae6d80929a469d0d87e02fba74ace7119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d80929a469d0d87e02fba74ace7119">&#9670;&nbsp;</a></span>ColorTableMapMagnitude() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::ColorTableMapMagnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; T, N &gt;, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ColorTable.html">viskores::cont::ColorTable</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; <a class="el" href="namespaceviskores.html#afea83468f8cfcf7f649b1fd42d117a0d">viskores::UInt8</a>, 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rgbOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use magnitude of a vector to generate RGB colors. </p>

</div>
</div>
<a id="ae7a16cf4dc539de435f6f34d472a542d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a16cf4dc539de435f6f34d472a542d">&#9670;&nbsp;</a></span>ColorTableMapMagnitude() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::ColorTableMapMagnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; T, N &gt;, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ColorTableSamplesRGB.html">viskores::cont::ColorTableSamplesRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a75fb5b3cc80b03eaa494d3075a42faca">viskores::Vec3ui_8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rgbOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use magnitude of a vector with a sample table to generate RGB colors. </p>

</div>
</div>
<a id="ab0f02b48b8e1118034fb44602a59e20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f02b48b8e1118034fb44602a59e20e">&#9670;&nbsp;</a></span>ColorTableMapMagnitude() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::ColorTableMapMagnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; T, N &gt;, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ColorTableSamplesRGBA.html">viskores::cont::ColorTableSamplesRGBA</a> &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#afb51ac2f1b928606ed0381cf7470c2c5">viskores::Vec4ui_8</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rgbaOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use magnitude of a vector with a sample table to generate RGBA colors. </p>

</div>
</div>
<a id="a8177e568c6c5e8e38678b79c5cf6d3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8177e568c6c5e8e38678b79c5cf6d3cd">&#9670;&nbsp;</a></span>ConditionalCastAndCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ConditionalCastAndCall </td>
          <td>(</td>
          <td class="paramtype">std::false_type&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No-op variant since the condition is false. </p>

</div>
</div>
<a id="a622b214ab1f55cd98464104de650b4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622b214ab1f55cd98464104de650b4fa">&#9670;&nbsp;</a></span>ConditionalCastAndCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ConditionalCastAndCall </td>
          <td>(</td>
          <td class="paramtype">std::true_type&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CastAndCall if the condition is true. </p>

</div>
</div>
<a id="a6c40d75b54ede0c5cdc69ed77a9978b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c40d75b54ede0c5cdc69ed77a9978b3">&#9670;&nbsp;</a></span>ConvertNumComponentsToOffsets() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ConvertNumComponentsToOffsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>numComponentsArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsetsArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em> = <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94eb61894ec5cb45eafd588185859b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94eb61894ec5cb45eafd588185859b0a">&#9670;&nbsp;</a></span>ConvertNumComponentsToOffsets() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ConvertNumComponentsToOffsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>numComponentsArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsetsArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &amp;&#160;</td>
          <td class="paramname"><em>componentsArraySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em> = <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>ConvertNumComponentsToOffsets</code> takes an array of <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a> sizes (i.e. </p>
<p>the number of components in each <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code>) and returns an array of offsets to a packed array of such <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code>s. The resulting array can be used with <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleGroupVecVariable.html" title="Fancy array handle that groups values into vectors of different sizes.">ArrayHandleGroupVecVariable</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numComponentsArray</td><td>the input array that specifies the number of components in each group <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">offsetsArray</td><td>(optional) the output <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>, which must have a value type of <code><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216" title="Base type to use to index arrays.">viskores::Id</a></code>. If the output <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> is not given, it is returned.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">componentsArraySize</td><td>(optional) a reference to a <code><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216" title="Base type to use to index arrays.">viskores::Id</a></code> and is filled with the expected size of the component values array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>(optional) specifies the device on which to run the conversion.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that this function is pre-compiled for some set of <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> types. If you get a warning about an inefficient conversion (or the operation fails outright), you might need to use <code>viskores::cont::internal::ConvertNumComponentsToOffsetsTemplate</code>. </p>

</div>
</div>
<a id="a94a2bb43a62e81881293867174d12030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a2bb43a62e81881293867174d12030">&#9670;&nbsp;</a></span>ConvertNumComponentsToOffsets() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&gt; viskores::cont::ConvertNumComponentsToOffsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>numComponentsArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em> = <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca3711a19570a2171d92980381372a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3711a19570a2171d92980381372a5a">&#9670;&nbsp;</a></span>ConvertNumComponentsToOffsets() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&gt; viskores::cont::ConvertNumComponentsToOffsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>numComponentsArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &amp;&#160;</td>
          <td class="paramname"><em>componentsArraySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em> = <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagAny.html">viskores::cont::DeviceAdapterTagAny</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f81f8313381b165bfcf9975611edd8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f81f8313381b165bfcf9975611edd8c">&#9670;&nbsp;</a></span>DIYMasterExchange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::DIYMasterExchange </td>
          <td>(</td>
          <td class="paramtype">viskoresdiy::Master &amp;&#160;</td>
          <td class="paramname"><em>master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remote</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps viskoresdiy::Master::exchange by setting its appropiate viskoresdiy::MemoryManagement. </p>

</div>
</div>
<a id="a1e4edc88b61cce5bed4bad7ab5f33859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4edc88b61cce5bed4bad7ab5f33859">&#9670;&nbsp;</a></span>FieldRangeCompute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="structviskores_1_1Range.html">viskores::Range</a>&gt; viskores::cont::FieldRangeCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a>&#160;</td>
          <td class="paramname"><em>assoc</em> = <code><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bdaed36a1ef76a59ee3f15180e0441188ad">viskores::cont::Field::Association::Any</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute ranges for fields in a <a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">DataSet</a> or <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html" title="Comprises a set of viskores::cont::DataSet objects.">PartitionedDataSet</a>. </p>
<p>These methods to compute ranges for fields in a single dataset or a partitioned dataset. When using Viskores in a hybrid-parallel environment with distributed processing, this class uses ranges for locally available data alone. Use FieldRangeGlobalCompute to compute ranges globally across all ranks even in distributed mode. Returns the range for a field from a dataset. If the field is not present, an empty <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> will be returned. </p>

</div>
</div>
<a id="a6e68c675ab5542a6ba4e3daeb9cf097a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e68c675ab5542a6ba4e3daeb9cf097a">&#9670;&nbsp;</a></span>FieldRangeCompute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="structviskores_1_1Range.html">viskores::Range</a>&gt; viskores::cont::FieldRangeCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>pds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a>&#160;</td>
          <td class="paramname"><em>assoc</em> = <code><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bdaed36a1ef76a59ee3f15180e0441188ad">viskores::cont::Field::Association::Any</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the range for a field from a <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html" title="Comprises a set of viskores::cont::DataSet objects.">PartitionedDataSet</a>. </p>
<p>If the field is not present on any of the partitions, an empty <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> will be returned. If the field is present on some partitions, but not all, those partitions without the field are skipped.</p>
<p>The returned array handle will have as many values as the maximum number of components for the selected field across all partitions. </p>

</div>
</div>
<a id="ad7292ed87a2b2804a3e79f18dfeecec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7292ed87a2b2804a3e79f18dfeecec7">&#9670;&nbsp;</a></span>FieldRangeGlobalCompute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="structviskores_1_1Range.html">viskores::Range</a>&gt; viskores::cont::FieldRangeGlobalCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a>&#160;</td>
          <td class="paramname"><em>assoc</em> = <code><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bdaed36a1ef76a59ee3f15180e0441188ad">viskores::cont::Field::Association::Any</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>utility functions to compute global ranges for dataset fields. </p>
<p>These functions compute global ranges for fields in a single <a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">DataSet</a> or a <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html" title="Comprises a set of viskores::cont::DataSet objects.">PartitionedDataSet</a>. In non-distributed environments, this is exactly same as <code>FieldRangeCompute</code>. In distributed environments, however, the range is computed locally on each rank and then a reduce-all collective is performed to reduces the ranges on all ranks. Returns the range for a field from a dataset. If the field is not present, an empty <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> will be returned. </p>

</div>
</div>
<a id="a3b5cc6f518fd80199b9129d41b95fa15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5cc6f518fd80199b9129d41b95fa15">&#9670;&nbsp;</a></span>FieldRangeGlobalCompute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="structviskores_1_1Range.html">viskores::Range</a>&gt; viskores::cont::FieldRangeGlobalCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>pds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a>&#160;</td>
          <td class="paramname"><em>assoc</em> = <code><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bdaed36a1ef76a59ee3f15180e0441188ad">viskores::cont::Field::Association::Any</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the range for a field from a <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html" title="Comprises a set of viskores::cont::DataSet objects.">PartitionedDataSet</a>. </p>
<p>If the field is not present on any of the partitions, an empty <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> will be returned. If the field is present on some partitions, but not all, those partitions without the field are skipped.</p>
<p>The returned array handle will have as many values as the maximum number of components for the selected field across all partitions. </p>

</div>
</div>
<a id="af9af159713650bc114e7b0566ec0d50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9af159713650bc114e7b0566ec0d50c">&#9670;&nbsp;</a></span>GetDIYDeviceAdapter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a> viskores::cont::GetDIYDeviceAdapter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f6499c1f313b6aeba11a4e5e525dd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6499c1f313b6aeba11a4e5e525dd61">&#9670;&nbsp;</a></span>GetGlobalGhostCellFieldName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; viskores::cont::GetGlobalGhostCellFieldName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f3368505f69c8efd7f5680799947967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3368505f69c8efd7f5680799947967">&#9670;&nbsp;</a></span>GetHumanReadableSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::cont::GetHumanReadableSize </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prec</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb04ffff933d97a1cd9b9c9682285ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb04ffff933d97a1cd9b9c9682285ff2">&#9670;&nbsp;</a></span>GetHumanReadableSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::cont::GetHumanReadableSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#ad73d0fee6a8e525142086920906c2fcf">viskores::UInt64</a>&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prec</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a size in bytes to a human readable string (such as "64 bytes", "1.44 MiB", "128 GiB", etc). </p>
<p><em>prec</em> controls the fixed point precision of the stringified number. </p>

</div>
</div>
<a id="a52908c96372d006b3c4f9d5df719aa42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52908c96372d006b3c4f9d5df719aa42">&#9670;&nbsp;</a></span>GetLogErrorContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::cont::GetLogErrorContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af795c4c6362577e392717edf5115d90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af795c4c6362577e392717edf5115d90f">&#9670;&nbsp;</a></span>GetLogLevelName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::cont::GetLogLevelName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8">viskores::cont::LogLevel</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a human readable name for the log level. </p>
<p>If a name has not been registered via InitLogging or SetLogLevelName, the returned string just contains the integer representation of the level. </p>

</div>
</div>
<a id="aa7e6b8f82fff1abaae1362a277e01562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e6b8f82fff1abaae1362a277e01562">&#9670;&nbsp;</a></span>GetLogThreadName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::cont::GetLogThreadName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a humman-readable name to identify the current thread in the log output. </p>

</div>
</div>
<a id="a8478594b979dc91ca3fe85561fa93575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8478594b979dc91ca3fe85561fa93575">&#9670;&nbsp;</a></span>GetRuntimeDeviceTracker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1RuntimeDeviceTracker.html">viskores::cont::RuntimeDeviceTracker</a>&amp; viskores::cont::GetRuntimeDeviceTracker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <code><a class="el" href="classviskores_1_1cont_1_1RuntimeDeviceTracker.html" title="RuntimeDeviceTracker is the central location for determining which device adapter will be active for ...">RuntimeDeviceTracker</a></code> for the current thread. </p>
<hr  />
<p>Many features in Viskores will attempt to run algorithms on the "best
 available device." This often is determined at runtime as failures in one device are recorded and that device is disabled. To prevent having to check over and over again, Viskores uses per thread runtime device tracker so that these choices are marked and shared. </p>

</div>
</div>
<a id="ad40e04e4fc25155ce0ad5bbeb0b78b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40e04e4fc25155ce0ad5bbeb0b78b4b">&#9670;&nbsp;</a></span>GetSizeString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::cont::GetSizeString </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prec</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61167c31cbdc603aa5abee56e042e7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61167c31cbdc603aa5abee56e042e7e1">&#9670;&nbsp;</a></span>GetSizeString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::cont::GetSizeString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#ad73d0fee6a8e525142086920906c2fcf">viskores::UInt64</a>&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prec</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns "%1 (%2 bytes)" where %1 is the result from GetHumanReadableSize and %2 is the exact number of bytes. </p>

</div>
</div>
<a id="abbc1dfbf84e47cf1006ccb464c3db506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc1dfbf84e47cf1006ccb464c3db506">&#9670;&nbsp;</a></span>GetStackTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::cont::GetStackTrace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a551f985fe2e8dae6c5f03856ecfe0dae">viskores::Int32</a>&#160;</td>
          <td class="paramname"><em>skip</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a stacktrace on supported platforms. </p>
<p>Argument is the number of frames to skip (GetStackTrace and below are already skipped). </p>

</div>
</div>
<a id="a3cbf88926929313f6a8f4d25da8a4f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cbf88926929313f6a8f4d25da8a4f1e">&#9670;&nbsp;</a></span>GetStderrLogLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8">viskores::cont::LogLevel</a> viskores::cont::GetStderrLogLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the active highest log level that will be printed to stderr. </p>

</div>
</div>
<a id="a7c6eea6c6b388ebae82d3e783d40956d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6eea6c6b388ebae82d3e783d40956d">&#9670;&nbsp;</a></span>GlobalGhostCellFieldName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; viskores::cont::GlobalGhostCellFieldName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad28843112a5a792c43bccef317f77e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28843112a5a792c43bccef317f77e54">&#9670;&nbsp;</a></span>Initialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1cont_1_1InitializeResult.html">InitializeResult</a> viskores::cont::Initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the Viskores library, parsing arguments when provided: </p>
<ul>
<li>Sets log level names when logging is configured.</li>
<li>Sets the calling thread as the main thread for logging purposes.</li>
<li>Sets the default log level to the argument provided to <code>--viskores-log-level</code>.</li>
<li>Forces usage of the device name passed to <code>--viskores-device</code>.</li>
<li>Prints usage when <code>-h</code> or <code>--viskores-help</code> is passed.</li>
</ul>
<p>The parameterless version only sets up log level names.</p>
<p>Additional options may be supplied via the <em>opts</em> argument, such as requiring the <code>--viskores-device</code> option.</p>
<p>Results are available in the returned <a class="el" href="structviskores_1_1cont_1_1InitializeResult.html">InitializeResult</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method may call exit() on parse error. </dd></dl>

</div>
</div>
<a id="afef0b0c98b83a46a4cb6d5c557c6f8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef0b0c98b83a46a4cb6d5c557c6f8a0">&#9670;&nbsp;</a></span>Initialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1cont_1_1InitializeResult.html">InitializeResult</a> viskores::cont::Initialize </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590">InitializeOptions</a>&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590a6adf97f83acf6453d4a6a4b1070f3754">InitializeOptions::None</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the Viskores library, parsing arguments when provided: </p>
<ul>
<li>Sets log level names when logging is configured.</li>
<li>Sets the calling thread as the main thread for logging purposes.</li>
<li>Sets the default log level to the argument provided to <code>--viskores-log-level</code>.</li>
<li>Forces usage of the device name passed to <code>--viskores-device</code>.</li>
<li>Prints usage when <code>-h</code> or <code>--viskores-help</code> is passed.</li>
</ul>
<p>The parameterless version only sets up log level names.</p>
<p>Additional options may be supplied via the <em>opts</em> argument, such as requiring the <code>--viskores-device</code> option.</p>
<p>Results are available in the returned <a class="el" href="structviskores_1_1cont_1_1InitializeResult.html">InitializeResult</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method may call exit() on parse error. </dd></dl>

</div>
</div>
<a id="a5db34fa4e79c7ed7fc6100cf726b7d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db34fa4e79c7ed7fc6100cf726b7d83">&#9670;&nbsp;</a></span>InitLogging() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::InitLogging </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This shouldn't be called directly &ndash; prefer calling <a class="el" href="namespaceviskores_1_1cont.html#afef0b0c98b83a46a4cb6d5c557c6f8a0" title="Initialize the Viskores library, parsing arguments when provided:">viskores::cont::Initialize</a>, which takes care of logging as well as other initializations. </p>
<p>Initializes logging. Sets up custom log level and thread names. Parses any "--viskores-log-level [LogLevel]" arguments to set the stderr log level. This argument may be either numeric, or the 4-character string printed in the output. Note that loguru will consume the "--viskores-log-level [LogLevel]" argument and shrink the arg list.</p>
<p>If the parameterless overload is used, the <code>--viskores-log-level</code> parsing is not used, but other functionality should still work.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not threadsafe and should only be called from a single thread (ideally the main thread). </dd></dl>

</div>
</div>
<a id="a4da71fbcd8c187e54949034fd3c9097b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da71fbcd8c187e54949034fd3c9097b">&#9670;&nbsp;</a></span>InitLogging() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::InitLogging </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>loggingFlag</em> = <code>&quot;--viskores-log-level&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>loggingEnv</em> = <code>&quot;VISKORES_LOG_LEVEL&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This shouldn't be called directly &ndash; prefer calling <a class="el" href="namespaceviskores_1_1cont.html#afef0b0c98b83a46a4cb6d5c557c6f8a0" title="Initialize the Viskores library, parsing arguments when provided:">viskores::cont::Initialize</a>, which takes care of logging as well as other initializations. </p>
<p>Initializes logging. Sets up custom log level and thread names. Parses any "--viskores-log-level [LogLevel]" arguments to set the stderr log level. This argument may be either numeric, or the 4-character string printed in the output. Note that loguru will consume the "--viskores-log-level [LogLevel]" argument and shrink the arg list.</p>
<p>If the parameterless overload is used, the <code>--viskores-log-level</code> parsing is not used, but other functionality should still work.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not threadsafe and should only be called from a single thread (ideally the main thread). </dd></dl>

</div>
</div>
<a id="a8681997d87a70fec1cc2ab4e7978bfd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8681997d87a70fec1cc2ab4e7978bfd8">&#9670;&nbsp;</a></span>IsType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayHandleType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::IsType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>variant</code> matches the type of ArrayHandleType. </p>

</div>
</div>
<a id="a503fe9095a711d30ed93abc142ad5165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503fe9095a711d30ed93abc142ad5165">&#9670;&nbsp;</a></span>IsType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CellSetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::IsType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownCellSet.html">viskores::cont::UnknownCellSet</a> &amp;&#160;</td>
          <td class="paramname"><em>unknownCellSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>unknownCellSet</code> matches the type of <code>CellSetType</code>. </p>

</div>
</div>
<a id="a92abf2395bab76ff668252212a614101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92abf2395bab76ff668252212a614101">&#9670;&nbsp;</a></span>LogCond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::LogCond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8">LogLevel</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conditionally logs a message with a printf-like format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Desired LogLevel value for the log message. </td></tr>
    <tr><td class="paramname">cond</td><td>When false this function is no-op. </td></tr>
    <tr><td class="paramname">file</td><td>The source file where the log entry was genearted. </td></tr>
    <tr><td class="paramname">line</td><td>The line in the source file where the log entry was generated. </td></tr>
    <tr><td class="paramname">format</td><td>Printf like format string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9323ddcf2f80047725681a7bb35da537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9323ddcf2f80047725681a7bb35da537">&#9670;&nbsp;</a></span>make_ArrayHandle() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html">viskores::cont::ArrayHandleBasic</a>&lt;T&gt; viskores::cont::make_ArrayHandle </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function for creating an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> from an std::vector. </p>

</div>
</div>
<a id="ab389153eb025c4062d6795e07b078fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab389153eb025c4062d6795e07b078fc1">&#9670;&nbsp;</a></span>make_ArrayHandle() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html">viskores::cont::ArrayHandleBasic</a>&lt;T&gt; viskores::cont::make_ArrayHandle </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function for creating an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> from a standard C array. </p>

</div>
</div>
<a id="a25a484115b48063a7f345e7a27ea99c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a484115b48063a7f345e7a27ea99c0">&#9670;&nbsp;</a></span>make_ArrayHandle() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html">viskores::cont::ArrayHandleBasic</a>&lt;T&gt; viskores::cont::make_ArrayHandle </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> directly from an initializer list of values. </p>

</div>
</div>
<a id="abb669e86987deeb9ee85f1ffeb434cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb669e86987deeb9ee85f1ffeb434cd2">&#9670;&nbsp;</a></span>make_ArrayHandle() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html">viskores::cont::ArrayHandleBasic</a>&lt;T&gt; viskores::cont::make_ArrayHandle </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move an std::vector into an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>

</div>
</div>
<a id="af0abef93dae84c5317296c84050bd715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0abef93dae84c5317296c84050bd715">&#9670;&nbsp;</a></span>make_ArrayHandleBitField() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBitField.html">viskores::cont::ArrayHandleBitField</a> viskores::cont::make_ArrayHandleBitField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1BitField.html">viskores::cont::BitField</a> &amp;&#160;</td>
          <td class="paramname"><em>bitField</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fb895600746f9b97262587f3dcc08a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb895600746f9b97262587f3dcc08a0">&#9670;&nbsp;</a></span>make_ArrayHandleBitField() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBitField.html">viskores::cont::ArrayHandleBitField</a> viskores::cont::make_ArrayHandleBitField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1BitField.html">viskores::cont::BitField</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>bitField</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5aeb92133992e3ffc354f6b6f269dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5aeb92133992e3ffc354f6b6f269dea">&#9670;&nbsp;</a></span>make_ArrayHandleCartesianProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FirstHandleType , typename SecondHandleType , typename ThirdHandleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleCartesianProduct.html">viskores::cont::ArrayHandleCartesianProduct</a>&lt;FirstHandleType, SecondHandleType, ThirdHandleType&gt; viskores::cont::make_ArrayHandleCartesianProduct </td>
          <td>(</td>
          <td class="paramtype">const FirstHandleType &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SecondHandleType &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ThirdHandleType &amp;&#160;</td>
          <td class="paramname"><em>third</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function for creating an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleCartesianProduct.html" title="ArrayHandleCartesianProduct is a specialization of ArrayHandle.">ArrayHandleCartesianProduct</a>. </p>
<p>It takes the two arrays to be zipped together. </p>

</div>
</div>
<a id="ac2762f91983309565e887ce3c7667887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2762f91983309565e887ce3c7667887">&#9670;&nbsp;</a></span>make_ArrayHandleCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ArrayType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::MakeArrayHandleCastImpl&lt;T, typename ArrayType::ValueType, ArrayType&gt;::ReturnType viskores::cont::make_ArrayHandleCast </td>
          <td>(</td>
          <td class="paramtype">const ArrayType &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>make_ArrayHandleCast</code> is convenience function to generate an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleCast.html" title="Cast the values of an array to the specified type, on demand.">ArrayHandleCast</a>. </p>

</div>
</div>
<a id="a08f4f380f83d91f4f23135cddbc639f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f4f380f83d91f4f23135cddbc639f4">&#9670;&nbsp;</a></span>make_ArrayHandleCompositeVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... ArrayTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleCompositeVector.html">ArrayHandleCompositeVector</a>&lt;ArrayTs...&gt; viskores::cont::make_ArrayHandleCompositeVector </td>
          <td>(</td>
          <td class="paramtype">const ArrayTs &amp;...&#160;</td>
          <td class="paramname"><em>arrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a composite vector array from other arrays. </p>

</div>
</div>
<a id="a6a5161f420baf91dfdfc2797479da9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5161f420baf91dfdfc2797479da9de">&#9670;&nbsp;</a></span>make_ArrayHandleConcatenate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayHandleType1 , typename ArrayHandleType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleConcatenate.html">ArrayHandleConcatenate</a>&lt;ArrayHandleType1, ArrayHandleType2&gt; viskores::cont::make_ArrayHandleConcatenate </td>
          <td>(</td>
          <td class="paramtype">const ArrayHandleType1 &amp;&#160;</td>
          <td class="paramname"><em>array1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayHandleType2 &amp;&#160;</td>
          <td class="paramname"><em>array2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a762ec3cad2e668ed2b1f11f97827ddb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762ec3cad2e668ed2b1f11f97827ddb8">&#9670;&nbsp;</a></span>make_ArrayHandleConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleConstant.html">viskores::cont::ArrayHandleConstant</a>&lt;T&gt; viskores::cont::make_ArrayHandleConstant </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>make_ArrayHandleConstant</code> is convenience function to generate an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleImplicit.html" title="An ArrayHandle that computes values on the fly.">ArrayHandleImplicit</a>. </p>

</div>
</div>
<a id="a423c4556489aefed41cfb30903d65b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423c4556489aefed41cfb30903d65b56">&#9670;&nbsp;</a></span>make_ArrayHandleCounting()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CountingValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleCounting.html">viskores::cont::ArrayHandleCounting</a>&lt;CountingValueType&gt; viskores::cont::make_ArrayHandleCounting </td>
          <td>(</td>
          <td class="paramtype">CountingValueType&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CountingValueType&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function for creating an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleCounting.html" title="ArrayHandleCounting is a specialization of ArrayHandle.">ArrayHandleCounting</a>. </p>
<p>It takes the value to start counting from and and the number of times to increment. </p>

</div>
</div>
<a id="a7c05dd5e0089f45842c6d538927d67ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c05dd5e0089f45842c6d538927d67ba">&#9670;&nbsp;</a></span>make_ArrayHandleDecorator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DecoratorImplT , typename... ArrayTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleDecorator.html">ArrayHandleDecorator</a>&lt;typename std::decay&lt;DecoratorImplT&gt;::type, typename std::decay&lt;ArrayTs&gt;::type...&gt; viskores::cont::make_ArrayHandleDecorator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DecoratorImplT &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayTs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleDecorator.html" title="A fancy ArrayHandle that can be used to modify the results from one or more source ArrayHandle.">ArrayHandleDecorator</a> with the specified number of values that uses the provided DecoratorImplT and source ArrayHandles. </p>

</div>
</div>
<a id="aaf74bea375e0d1896932e1edfead56ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf74bea375e0d1896932e1edfead56ed">&#9670;&nbsp;</a></span>make_ArrayHandleExtractComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayHandleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleExtractComponent.html">ArrayHandleExtractComponent</a>&lt;ArrayHandleType&gt; viskores::cont::make_ArrayHandleExtractComponent </td>
          <td>(</td>
          <td class="paramtype">const ArrayHandleType &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>make_ArrayHandleExtractComponent</code> is convenience function to generate an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleExtractComponent.html" title="A fancy ArrayHandle that turns a vector array into a scalar array by slicing out a single component o...">ArrayHandleExtractComponent</a></code>. </p>

</div>
</div>
<a id="a502d3615a4354e56f0dbf518a7e17a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a502d3615a4354e56f0dbf518a7e17a8f">&#9670;&nbsp;</a></span>make_ArrayHandleGroupVec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;viskores::IdComponent NUM_COMPONENTS, typename ArrayHandleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleGroupVec.html">viskores::cont::ArrayHandleGroupVec</a>&lt;ArrayHandleType, NUM_COMPONENTS&gt; viskores::cont::make_ArrayHandleGroupVec </td>
          <td>(</td>
          <td class="paramtype">const ArrayHandleType &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>make_ArrayHandleGroupVec</code> is convenience function to generate an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleGroupVec.html" title="Fancy array handle that groups values into vectors.">ArrayHandleGroupVec</a>. </p>
<p>It takes in an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> and the number of components (as a specified template parameter), and returns an array handle with consecutive entries grouped in a <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a>. </p>

</div>
</div>
<a id="a1c24c18f8d28f0f9fd1b1a2a8b579e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c24c18f8d28f0f9fd1b1a2a8b579e8a">&#9670;&nbsp;</a></span>make_ArrayHandleGroupVecVariable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentsArrayHandleType , typename OffsetsArrayHandleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleGroupVecVariable.html">viskores::cont::ArrayHandleGroupVecVariable</a>&lt;ComponentsArrayHandleType, OffsetsArrayHandleType&gt; viskores::cont::make_ArrayHandleGroupVecVariable </td>
          <td>(</td>
          <td class="paramtype">const ComponentsArrayHandleType &amp;&#160;</td>
          <td class="paramname"><em>componentsArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OffsetsArrayHandleType &amp;&#160;</td>
          <td class="paramname"><em>offsetsArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>make_ArrayHandleGroupVecVariable</code> is convenience function to generate an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleGroupVecVariable.html" title="Fancy array handle that groups values into vectors of different sizes.">ArrayHandleGroupVecVariable</a>. </p>
<p>It takes in an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> of values and an array handle of offsets and returns an array handle with consecutive entries grouped in a <a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a>. </p>

</div>
</div>
<a id="a6ce304a7b9162d2ce78e4a2763c7f79e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce304a7b9162d2ce78e4a2763c7f79e">&#9670;&nbsp;</a></span>make_ArrayHandleImplicit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleImplicit.html">viskores::cont::ArrayHandleImplicit</a>&lt;FunctorType&gt; viskores::cont::make_ArrayHandleImplicit </td>
          <td>(</td>
          <td class="paramtype">FunctorType&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make_ArrayHandleImplicit is convenience function to generate an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleImplicit.html" title="An ArrayHandle that computes values on the fly.">ArrayHandleImplicit</a>. </p>
<p>It takes a functor and the virtual length of the arry. </p>

</div>
</div>
<a id="a9887dd8d2e5ff864172aa3ef52234767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9887dd8d2e5ff864172aa3ef52234767">&#9670;&nbsp;</a></span>make_ArrayHandleIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleIndex.html">viskores::cont::ArrayHandleIndex</a> viskores::cont::make_ArrayHandleIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience function for creating an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleIndex.html" title="An implicit array handle containing the its own indices.">ArrayHandleIndex</a>. </p>
<p>It takes the size of the array and generates an array holding <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216" title="Base type to use to index arrays.">viskores::Id</a> from [0, size - 1] </p>

</div>
</div>
<a id="acb55bb08b6669c629d0ef7ad43a3ab23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb55bb08b6669c629d0ef7ad43a3ab23">&#9670;&nbsp;</a></span>make_ArrayHandleMove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html">viskores::cont::ArrayHandleBasic</a>&lt;T&gt; viskores::cont::make_ArrayHandleMove </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move an std::vector into an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>

</div>
</div>
<a id="a362cd3b4a393fefd5c052762314afb78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362cd3b4a393fefd5c052762314afb78">&#9670;&nbsp;</a></span>make_ArrayHandleMove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html">viskores::cont::ArrayHandleBasic</a>&lt;T&gt; viskores::cont::make_ArrayHandleMove </td>
          <td>(</td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">viskores::cont::internal::BufferInfo::Deleter&#160;</td>
          <td class="paramname"><em>deleter</em> = <code>internal::SimpleArrayDeleter&lt;T&gt;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">viskores::cont::internal::BufferInfo::Reallocater&#160;</td>
          <td class="paramname"><em>reallocater</em> = <code>internal::SimpleArrayReallocater&lt;T&gt;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function to move a user-allocated array into an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>. </p>
<p>The provided array pointer will be reset to <code>nullptr</code>. If the array was not allocated with the <code>new[]</code> operator, then deleter and reallocater functions must be provided. </p>

</div>
</div>
<a id="a9ca556942a4196d16c27174f3b60069d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca556942a4196d16c27174f3b60069d">&#9670;&nbsp;</a></span>make_ArrayHandleOffsetsToNumComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OffsetsStorageTag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleOffsetsToNumComponents.html">viskores::cont::ArrayHandleOffsetsToNumComponents</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, OffsetsStorageTag&gt; &gt; viskores::cont::make_ArrayHandleOffsetsToNumComponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, OffsetsStorageTag &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6f70c9d16e932e0b46ad71450a12d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f70c9d16e932e0b46ad71450a12d62">&#9670;&nbsp;</a></span>make_ArrayHandlePermutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexArrayHandleType , typename ValueArrayHandleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandlePermutation.html">viskores::cont::ArrayHandlePermutation</a>&lt;IndexArrayHandleType, ValueArrayHandleType&gt; viskores::cont::make_ArrayHandlePermutation </td>
          <td>(</td>
          <td class="paramtype">IndexArrayHandleType&#160;</td>
          <td class="paramname"><em>indexArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueArrayHandleType&#160;</td>
          <td class="paramname"><em>valueArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make_ArrayHandleTransform is convenience function to generate an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleTransform.html" title="Implicitly transform values of one array to another with a functor.">ArrayHandleTransform</a>. </p>
<p>It takes in an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> and a functor to apply to each element of the Handle. </p>

</div>
</div>
<a id="a5e58e74bea31ae73b4dbdb493d0bbc83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e58e74bea31ae73b4dbdb493d0bbc83">&#9670;&nbsp;</a></span>make_ArrayHandleReverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename HandleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleReverse.html">ArrayHandleReverse</a>&lt;HandleType&gt; viskores::cont::make_ArrayHandleReverse </td>
          <td>(</td>
          <td class="paramtype">const HandleType &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make_ArrayHandleReverse is convenience function to generate an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleReverse.html" title="Reverse the order of an array, on demand.">ArrayHandleReverse</a>. </p>

</div>
</div>
<a id="aa7f8c501625f7b7ccb60bfa0f63f6974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f8c501625f7b7ccb60bfa0f63f6974">&#9670;&nbsp;</a></span>make_ArrayHandleRuntimeVec() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto viskores::cont::make_ArrayHandleRuntimeVec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>componentsArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a basic array handle into an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">ArrayHandleRuntimeVec</a></code> with 1 component. </p>
<p>The constructed array is essentially equivalent but of a different type. </p>

</div>
</div>
<a id="a9230be84e00a75591dbfc2dde41bf060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9230be84e00a75591dbfc2dde41bf060">&#9670;&nbsp;</a></span>make_ArrayHandleRuntimeVec() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto viskores::cont::make_ArrayHandleRuntimeVec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>numComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function for creating an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">ArrayHandleRuntimeVec</a></code> from an <code>std::vector</code>. </p>

</div>
</div>
<a id="a60f34aba4b592cbbd74d2bc358e5199e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f34aba4b592cbbd74d2bc358e5199e">&#9670;&nbsp;</a></span>make_ArrayHandleRuntimeVec() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto viskores::cont::make_ArrayHandleRuntimeVec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>numComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function for creating an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">ArrayHandleRuntimeVec</a></code> from a standard C array. </p>

</div>
</div>
<a id="afb4c96a0f036b707756c9f27e8d0de35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4c96a0f036b707756c9f27e8d0de35">&#9670;&nbsp;</a></span>make_ArrayHandleRuntimeVec() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto viskores::cont::make_ArrayHandleRuntimeVec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>numComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>componentsArray</em> = <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;T,&#160;<a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>make_ArrayHandleRuntimeVec</code> is convenience function to generate an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">ArrayHandleRuntimeVec</a></code>. </p>
<p>It takes the number of components stored in each value's <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code>, which must be specified on the construction of the <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">ArrayHandleRuntimeVec</a></code>. If not specified, the number of components is set to 1. <code>make_ArrayHandleRuntimeVec</code> can also optionally take an existing array of components, which will be grouped into <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code> values based on the specified number of components. </p>

</div>
</div>
<a id="a7460b16cb15a0ce5d6123e59162a0219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7460b16cb15a0ce5d6123e59162a0219">&#9670;&nbsp;</a></span>make_ArrayHandleRuntimeVec() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto viskores::cont::make_ArrayHandleRuntimeVec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>numComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30c314e346fa64e6c635b825a1e65a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c314e346fa64e6c635b825a1e65a2e">&#9670;&nbsp;</a></span>make_ArrayHandleRuntimeVecMove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto viskores::cont::make_ArrayHandleRuntimeVecMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>numComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move an <code>std::vector</code> into an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">ArrayHandleRuntimeVec</a></code>. </p>

</div>
</div>
<a id="a74811cb476e0c08eda2811191e445a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74811cb476e0c08eda2811191e445a14">&#9670;&nbsp;</a></span>make_ArrayHandleRuntimeVecMove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto viskores::cont::make_ArrayHandleRuntimeVecMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>numComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">viskores::cont::internal::BufferInfo::Deleter&#160;</td>
          <td class="paramname"><em>deleter</em> = <code>internal::SimpleArrayDeleter&lt;T&gt;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">viskores::cont::internal::BufferInfo::Reallocater&#160;</td>
          <td class="paramname"><em>reallocater</em> = <code>internal::SimpleArrayReallocater&lt;T&gt;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function to move a user-allocated array into an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">ArrayHandleRuntimeVec</a></code>. </p>
<p>The provided array pointer will be reset to <code>nullptr</code>. If the array was not allocated with the <code>new[]</code> operator, then deleter and reallocater functions must be provided. </p>

</div>
</div>
<a id="abdb1178562784791f1c2c0263a9485f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb1178562784791f1c2c0263a9485f0">&#9670;&nbsp;</a></span>make_ArrayHandleSOA() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentType , typename... RemainingArrays&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt;ComponentType, internal::VecSizeFromRemaining&lt;RemainingArrays...&gt;::value&gt; &gt; viskores::cont::make_ArrayHandleSOA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; ComponentType, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>componentArray0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RemainingArrays &amp;...&#160;</td>
          <td class="paramname"><em>componentArrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">viskores::cont::ArrayHandleSOA</a></code> with a number of array handles. </p>
<p>This only works if all the templated arguments are of type <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a>&lt;ComponentType&gt;</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> components1;</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> components2;</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> components3;</div>
<div class="line"><span class="comment">// Fill arrays...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> vecarray =</div>
<div class="line">  <a class="code" href="namespaceviskores_1_1cont.html#a3ac73251dfcee427a6d163156caa9a30">viskores::cont::make_ArrayHandleSOA</a>(components1, components2, components3);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2f86d8c702047107966120dd6522a288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f86d8c702047107966120dd6522a288">&#9670;&nbsp;</a></span>make_ArrayHandleSOA() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a>&lt;ValueType&gt; viskores::cont::make_ArrayHandleSOA </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; const typename <a class="el" href="structviskores_1_1VecTraits.html">viskores::VecTraits</a>&lt; ValueType &gt;::ComponentType * &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>componentVectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">viskores::cont::ArrayHandleSOA</a></code> with an initializer list of C arrays. </p>
<div class="fragment"><div class="line">T* components1;</div>
<div class="line">T* components2;</div>
<div class="line">T* components3;</div>
<div class="line"><span class="comment">// Fill arrays...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> vecarray = viskores::cont::make_ArrayHandleSOA&lt;viskores::Vec&lt;T, 3&gt;&gt;(</div>
<div class="line">  { components1, components2, components3 }, size, <a class="code" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3">viskores::CopyFlag::On</a>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac90d3e452ad278deedc88aecfead4927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90d3e452ad278deedc88aecfead4927">&#9670;&nbsp;</a></span>make_ArrayHandleSOA() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a>&lt;ValueType&gt; viskores::cont::make_ArrayHandleSOA </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::vector&lt; typename <a class="el" href="structviskores_1_1VecTraits.html">viskores::VecTraits</a>&lt; ValueType &gt;::ComponentType &gt;&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>componentVectors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">viskores::cont::ArrayHandleSOA</a></code> with an initializer list of <code>std::vector</code>. </p>
<p>The data is copied from the <code>std::vector</code>s to the array handle.</p>
<div class="fragment"><div class="line">std::vector&lt;T&gt; components1;</div>
<div class="line">std::vector&lt;T&gt; components2;</div>
<div class="line">std::vector&lt;T&gt; components3;</div>
<div class="line"><span class="comment">// Fill arrays...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> vecarray = viskores::cont::make_ArrayHandleSOA&lt;viskores::Vec&lt;T, 3&gt;&gt;(</div>
<div class="line">  { components1, components2, components3 });</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3ac73251dfcee427a6d163156caa9a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac73251dfcee427a6d163156caa9a30">&#9670;&nbsp;</a></span>make_ArrayHandleSOA() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a>&lt;ValueType&gt; viskores::cont::make_ArrayHandleSOA </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; typename <a class="el" href="structviskores_1_1VecTraits.html">viskores::VecTraits</a>&lt; ValueType &gt;::ComponentType, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt;&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>componentArrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">viskores::cont::ArrayHandleSOA</a></code> with an initializer list of array handles. </p>
<div class="fragment"><div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> components1;</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> components2;</div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle&lt;T&gt;</a> components3;</div>
<div class="line"><span class="comment">// Fill arrays...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> vecarray = viskores::cont::make_ArrayHandleSOA&lt;viskores::Vec&lt;T, 3&gt;&gt;(</div>
<div class="line">  { components1, components2, components3 });</div>
</div><!-- fragment --> 
</div>
</div>
<a id="abdbf4a34a2143f4a63d5f80e2a8a6de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbf4a34a2143f4a63d5f80e2a8a6de1">&#9670;&nbsp;</a></span>make_ArrayHandleSOA() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentType , typename... RemainingVectors&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt;ComponentType, internal::VecSizeFromRemaining&lt;RemainingVectors...&gt;::value&gt; &gt; viskores::cont::make_ArrayHandleSOA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ComponentType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RemainingVectors &amp;&amp;...&#160;</td>
          <td class="paramname"><em>componentVectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">viskores::cont::ArrayHandleSOA</a></code> with a number of <code>std::vector</code>. </p>
<p>The first argument is a <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94" title="Identifier used to specify whether a function should deep copy data.">viskores::CopyFlag</a></code> to determine whether the input arrays should be copied. The component arrays are listed as arguments. This only works if all the templated arguments are of type <code>std::vector&lt;ComponentType&gt;</code>.</p>
<div class="fragment"><div class="line">std::vector&lt;T&gt; components1;</div>
<div class="line">std::vector&lt;T&gt; components2;</div>
<div class="line">std::vector&lt;T&gt; components3;</div>
<div class="line"><span class="comment">// Fill arrays...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> vecarray = <a class="code" href="namespaceviskores_1_1cont.html#a3ac73251dfcee427a6d163156caa9a30">viskores::cont::make_ArrayHandleSOA</a>(</div>
<div class="line">  <a class="code" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3">viskores::CopyFlag::On</a>, components1, components2, components3);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4229bc02f8fa9e17109c31ecb4b2ce1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4229bc02f8fa9e17109c31ecb4b2ce1b">&#9670;&nbsp;</a></span>make_ArrayHandleSOA() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentType , typename... RemainingVectors&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt;ComponentType, internal::VecSizeFromRemaining&lt;RemainingVectors...&gt;::value&gt; &gt; viskores::cont::make_ArrayHandleSOA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; ComponentType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>vector0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RemainingVectors &amp;&amp;...&#160;</td>
          <td class="paramname"><em>componentVectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">viskores::cont::ArrayHandleSOA</a></code> with a number of <code>std::vector</code>. </p>
<p>The first argument is a <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94" title="Identifier used to specify whether a function should deep copy data.">viskores::CopyFlag</a></code> to determine whether the input arrays should be copied. The component arrays are listed as arguments. This only works if all the templated arguments are rvalues of type <code>std::vector&lt;ComponentType&gt;</code>.</p>
<div class="fragment"><div class="line">std::vector&lt;T&gt; components1;</div>
<div class="line">std::vector&lt;T&gt; components2;</div>
<div class="line">std::vector&lt;T&gt; components3;</div>
<div class="line"><span class="comment">// Fill arrays...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> vecarray = <a class="code" href="namespaceviskores_1_1cont.html#a3ac73251dfcee427a6d163156caa9a30">viskores::cont::make_ArrayHandleSOA</a>(<a class="code" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a>,</div>
<div class="line">                                                std::move(components1),</div>
<div class="line">                                                std::move(components2),</div>
<div class="line">                                                std::move(components3);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af9640cfedbe3a120ed1d7d312cb61261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9640cfedbe3a120ed1d7d312cb61261">&#9670;&nbsp;</a></span>make_ArrayHandleSOA() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentType , typename... RemainingArrays&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt;ComponentType, internal::VecSizeFromRemaining&lt;RemainingArrays...&gt;::value&gt; &gt; viskores::cont::make_ArrayHandleSOA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ComponentType *&#160;</td>
          <td class="paramname"><em>array0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RemainingArrays *...&#160;</td>
          <td class="paramname"><em>componentArrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">viskores::cont::ArrayHandleSOA</a></code> with a number of C arrays. </p>
<p>This only works if all the templated arguments are of type <code>ComponentType*</code>.</p>
<div class="fragment"><div class="line">T* components1;</div>
<div class="line">T* components2;</div>
<div class="line">T* components3;</div>
<div class="line"><span class="comment">// Fill arrays...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> vecarray = <a class="code" href="namespaceviskores_1_1cont.html#a3ac73251dfcee427a6d163156caa9a30">viskores::cont::make_ArrayHandleSOA</a>(</div>
<div class="line">  size, <a class="code" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3">viskores::CopyFlag::On</a>, components1, components2, components3);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9b92f2fe6c3c23da7071c725e9aaceb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b92f2fe6c3c23da7071c725e9aaceb4">&#9670;&nbsp;</a></span>make_ArrayHandleSOAMove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentType , typename... RemainingVectors&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html">ArrayHandleSOA</a>&lt; <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt;ComponentType, internal::VecSizeFromRemaining&lt;RemainingVectors...&gt;::value&gt; &gt; viskores::cont::make_ArrayHandleSOAMove </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; ComponentType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>vector0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RemainingVectors &amp;&amp;...&#160;</td>
          <td class="paramname"><em>componentVectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">viskores::cont::ArrayHandleSOA</a></code> with a number of <code>std::vector</code>. </p>
<p>This only works if all the templated arguments are rvalues of type <code>std::vector&lt;ComponentType&gt;</code>.</p>
<div class="fragment"><div class="line">std::vector&lt;T&gt; components1;</div>
<div class="line">std::vector&lt;T&gt; components2;</div>
<div class="line">std::vector&lt;T&gt; components3;</div>
<div class="line"><span class="comment">// Fill arrays...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> vecarray = <a class="code" href="namespaceviskores_1_1cont.html#a9b92f2fe6c3c23da7071c725e9aaceb4">viskores::cont::make_ArrayHandleSOAMove</a>(</div>
<div class="line">  std::move(components1), std::move(components2), std::move(components3));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7a297b0cd25db294a5a95b64d684d834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a297b0cd25db294a5a95b64d684d834">&#9670;&nbsp;</a></span>make_ArrayHandleStride()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleStride.html">viskores::cont::ArrayHandleStride</a>&lt;T&gt; viskores::cont::make_ArrayHandleStride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>modulo</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>divisor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an array by adding a stride to a basic array. </p>

</div>
</div>
<a id="a5fcfc2146936cf0f210373192492e29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcfc2146936cf0f210373192492e29f">&#9670;&nbsp;</a></span>make_ArrayHandleSwizzle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayHandleType , viskores::IdComponent OutSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSwizzle.html">ArrayHandleSwizzle</a>&lt;ArrayHandleType, OutSize&gt; viskores::cont::make_ArrayHandleSwizzle </td>
          <td>(</td>
          <td class="paramtype">const ArrayHandleType &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1Vec.html">viskores::Vec</a>&lt; <a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>, OutSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSwizzle.html" title="Swizzle the components of the values in an ArrayHandle.">ArrayHandleSwizzle</a></code> from a provided array and swizzle map. </p>
<p>The swizzle map is a <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a></code> containing <code><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40" title="Base type to use to index small lists.">viskores::IdComponent</a></code> components and sized to the number of components in the array. Each value in the map specifies from which component of the input the corresponding component of the output should come from. </p>

</div>
</div>
<a id="a15e6299c6fe97d558a7ebf3bb02b71a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e6299c6fe97d558a7ebf3bb02b71a4">&#9670;&nbsp;</a></span>make_ArrayHandleSwizzle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayHandleType , typename... SwizzleIndexTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto viskores::cont::make_ArrayHandleSwizzle </td>
          <td>(</td>
          <td class="paramtype">const ArrayHandleType &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>swizzleIndex0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SwizzleIndexTypes...&#160;</td>
          <td class="paramname"><em>swizzleIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSwizzle.html" title="Swizzle the components of the values in an ArrayHandle.">ArrayHandleSwizzle</a></code> from a provided array and swizzle map. </p>
<p>The swizzle map is specified as independent function parameters after the array. Each value in the map specifies from which component of the input the corresponding component of the output should come from. </p>

</div>
</div>
<a id="a7b7bada847b66a4d496009aea0efecd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7bada847b66a4d496009aea0efecd8">&#9670;&nbsp;</a></span>make_ArrayHandleTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename HandleType , typename FunctorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleTransform.html">viskores::cont::ArrayHandleTransform</a>&lt;HandleType, FunctorType&gt; viskores::cont::make_ArrayHandleTransform </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctorType&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make_ArrayHandleTransform is convenience function to generate an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleTransform.html" title="Implicitly transform values of one array to another with a functor.">ArrayHandleTransform</a>. </p>
<p>It takes in an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> and a functor to apply to each element of the Handle. </p>

</div>
</div>
<a id="aac93e16240fcbf343100d41df45eda84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac93e16240fcbf343100d41df45eda84">&#9670;&nbsp;</a></span>make_ArrayHandleTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename HandleType , typename FunctorType , typename InverseFunctorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleTransform.html">viskores::cont::ArrayHandleTransform</a>&lt;HandleType, FunctorType, InverseFunctorType&gt; viskores::cont::make_ArrayHandleTransform </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctorType&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InverseFunctorType&#160;</td>
          <td class="paramname"><em>inverseFunctor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac746fa9b831698817aa8637d2be6d4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac746fa9b831698817aa8637d2be6d4f3">&#9670;&nbsp;</a></span>make_ArrayHandleView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayHandleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleView.html">ArrayHandleView</a>&lt;ArrayHandleType&gt; viskores::cont::make_ArrayHandleView </td>
          <td>(</td>
          <td class="paramtype">const ArrayHandleType &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleView.html" title="Provided a windowed view into a viskores::cont::ArrayHandle.">viskores::cont::ArrayHandleView</a></code> from a source array. </p>

</div>
</div>
<a id="a803ca422e84f495e93a5a03e58e51c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803ca422e84f495e93a5a03e58e51c6c">&#9670;&nbsp;</a></span>make_ArrayHandleXGCCoordinates() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleXGCCoordinates.html">viskores::cont::ArrayHandleXGCCoordinates</a>&lt;T&gt; viskores::cont::make_ArrayHandleXGCCoordinates </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfPlanesOwned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cylindrical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfPlanes</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>planeStartId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>copy</em> = <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7172af4530c559215b2f94870d3b8b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7172af4530c559215b2f94870d3b8b8e">&#9670;&nbsp;</a></span>make_ArrayHandleXGCCoordinates() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleXGCCoordinates.html">viskores::cont::ArrayHandleXGCCoordinates</a>&lt;T&gt; viskores::cont::make_ArrayHandleXGCCoordinates </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfPlanesOwned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cylindrical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfPlanes</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>planeStartId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>copy</em> = <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97deb2a2a1e9bc33362a2cd9057e5261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97deb2a2a1e9bc33362a2cd9057e5261">&#9670;&nbsp;</a></span>make_ArrayHandleXGCCoordinates() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleXGCCoordinates.html">viskores::cont::ArrayHandleXGCCoordinates</a>&lt;T&gt; viskores::cont::make_ArrayHandleXGCCoordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfPlanesOwned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cylindrical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfPlanes</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>planeStartId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34460a9d359cdab18e42e447299bc669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34460a9d359cdab18e42e447299bc669">&#9670;&nbsp;</a></span>make_ArrayHandleZip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FirstHandleType , typename SecondHandleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleZip.html">viskores::cont::ArrayHandleZip</a>&lt;FirstHandleType, SecondHandleType&gt; viskores::cont::make_ArrayHandleZip </td>
          <td>(</td>
          <td class="paramtype">const FirstHandleType &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SecondHandleType &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function for creating an <a class="el" href="classviskores_1_1cont_1_1ArrayHandleZip.html" title="ArrayHandleZip is a specialization of ArrayHandle.">ArrayHandleZip</a>. </p>
<p>It takes the two arrays to be zipped together. </p>

</div>
</div>
<a id="a1d1011dac9bd6c523ca8c7e70c5d35da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1011dac9bd6c523ca8c7e70c5d35da">&#9670;&nbsp;</a></span>make_CellSetExtrude() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1CellSetExtrude.html">CellSetExtrude</a> viskores::cont::make_CellSetExtrude </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceviskores.html#a551f985fe2e8dae6c5f03856ecfe0dae">viskores::Int32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandleXGCCoordinates.html">viskores::cont::ArrayHandleXGCCoordinates</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceviskores.html#a551f985fe2e8dae6c5f03856ecfe0dae">viskores::Int32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nextNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>periodic</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a695ba80af4e58edbfbf77e46f3e98e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695ba80af4e58edbfbf77e46f3e98e37">&#9670;&nbsp;</a></span>make_CellSetExtrude() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1CellSetExtrude.html">CellSetExtrude</a> viskores::cont::make_CellSetExtrude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a551f985fe2e8dae6c5f03856ecfe0dae">viskores::Int32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandleXGCCoordinates.html">viskores::cont::ArrayHandleXGCCoordinates</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a551f985fe2e8dae6c5f03856ecfe0dae">viskores::Int32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nextNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>periodic</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeafcd37e4d92c6722c898de96d13be41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafcd37e4d92c6722c898de96d13be41">&#9670;&nbsp;</a></span>make_CellSetExtrude() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1CellSetExtrude.html">CellSetExtrude</a> viskores::cont::make_CellSetExtrude </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceviskores.html#a551f985fe2e8dae6c5f03856ecfe0dae">viskores::Int32</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandleXGCCoordinates.html">viskores::cont::ArrayHandleXGCCoordinates</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceviskores.html#a551f985fe2e8dae6c5f03856ecfe0dae">viskores::Int32</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>periodic</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12f3bcee73f50de8af9b08f3edbbc913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f3bcee73f50de8af9b08f3edbbc913">&#9670;&nbsp;</a></span>make_CellSetPermutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OriginalCellSet , typename PermutationArrayHandleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1CellSetPermutation.html">viskores::cont::CellSetPermutation</a>&lt;OriginalCellSet, PermutationArrayHandleType&gt; viskores::cont::make_CellSetPermutation </td>
          <td>(</td>
          <td class="paramtype">const PermutationArrayHandleType &amp;&#160;</td>
          <td class="paramname"><em>cellIndexMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OriginalCellSet &amp;&#160;</td>
          <td class="paramname"><em>cellSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad348497fd44a00989203358ad7be5109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad348497fd44a00989203358ad7be5109">&#9670;&nbsp;</a></span>make_CoordinateSystem() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html">viskores::cont::CoordinateSystem</a> viskores::cont::make_CoordinateSystem </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>copy</em> = <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93811e3967a5138e0a58f50666845ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93811e3967a5138e0a58f50666845ad0">&#9670;&nbsp;</a></span>make_CoordinateSystem() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html">viskores::cont::CoordinateSystem</a> viskores::cont::make_CoordinateSystem </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>copy</em> = <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2c2693178c33cfbad4a7b8863e4c2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c2693178c33cfbad4a7b8863e4c2d8">&#9670;&nbsp;</a></span>make_DeviceAdapterId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">DeviceAdapterId</a> viskores::cont::make_DeviceAdapterId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceviskores_1_1cont.html#a8915670663a9ef414cf88fce2f4e6ca6">DeviceAdapterNameType</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a device adapter id from a runtime string The string is case-insensitive. </p>
<p>So CUDA will be selected with 'cuda', 'Cuda', or 'CUDA'. </p>

</div>
</div>
<a id="aa438f6a5bf4b16b673aa9f41f0eb5863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa438f6a5bf4b16b673aa9f41f0eb5863">&#9670;&nbsp;</a></span>make_DeviceAdapterId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">DeviceAdapterId</a> viskores::cont::make_DeviceAdapterId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a51c25b092de0dab71d38ba566199f8bf">viskores::Int8</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a device adapter id a <a class="el" href="namespaceviskores.html#a51c25b092de0dab71d38ba566199f8bf" title="Base type to use for 8-bit signed integer numbers.">viskores::Int8</a>. </p>
<p>The mapping of integer value to devices are:</p>
<p><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagSerial.html" title="Tag for a device adapter that performs all computation on the same single thread as the control envir...">DeviceAdapterTagSerial</a> == 1 <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagCuda.html" title="Tag for a device adapter that uses a CUDA capable GPU device.">DeviceAdapterTagCuda</a> == 2 <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagTBB.html" title="Tag for a device adapter that uses the Intel Threading Building Blocks library to run algorithms on m...">DeviceAdapterTagTBB</a> == 3 <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagOpenMP.html" title="Tag for a device adapter that uses OpenMP compiler extensions to run algorithms on multiple threads.">DeviceAdapterTagOpenMP</a> == 4 <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterTagKokkos.html" title="Tag for a device adapter that uses the Kokkos library to run algorithms in parallel.">DeviceAdapterTagKokkos</a> == 5 </p>

</div>
</div>
<a id="a63634ac7ce8ccf7253238f5bcab98625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63634ac7ce8ccf7253238f5bcab98625">&#9670;&nbsp;</a></span>make_Field() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> viskores::cont::make_Field </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">Field::Association</a>&#160;</td>
          <td class="paramname"><em>association</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af31857dd3c95e3edf9820e5e09ed5675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31857dd3c95e3edf9820e5e09ed5675">&#9670;&nbsp;</a></span>make_Field() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> viskores::cont::make_Field </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">Field::Association</a>&#160;</td>
          <td class="paramname"><em>association</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience functions to build fields from C style arrays and std::vector. </p>

</div>
</div>
<a id="a036364ee7500e9262e2bfa31f7f39090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036364ee7500e9262e2bfa31f7f39090">&#9670;&nbsp;</a></span>make_Field() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> viskores::cont::make_Field </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">Field::Association</a>&#160;</td>
          <td class="paramname"><em>association</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30beccb62e53129a535a483376085fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30beccb62e53129a535a483376085fb4">&#9670;&nbsp;</a></span>make_Field() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> viskores::cont::make_Field </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">Field::Association</a>&#160;</td>
          <td class="paramname"><em>association</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e5bd3aa7b00c758cb063b1bc0a70d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5bd3aa7b00c758cb063b1bc0a70d29">&#9670;&nbsp;</a></span>make_FieldCell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> viskores::cont::make_FieldCell </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to build cell fields from <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a>. </p>

</div>
</div>
<a id="a7df7fc9562548b86a669e53143caebf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df7fc9562548b86a669e53143caebf4">&#9670;&nbsp;</a></span>make_FieldCell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> viskores::cont::make_FieldCell </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to build cell fields from <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">viskores::cont::UnknownArrayHandle</a>. </p>

</div>
</div>
<a id="ad92221a3a4468577faa26109c2a7f972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92221a3a4468577faa26109c2a7f972">&#9670;&nbsp;</a></span>make_FieldMove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> viskores::cont::make_FieldMove </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">Field::Association</a>&#160;</td>
          <td class="paramname"><em>association</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a782234106c92a428d5f35b7fa9999dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782234106c92a428d5f35b7fa9999dba">&#9670;&nbsp;</a></span>make_FieldPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> viskores::cont::make_FieldPoint </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to build point fields from <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a>. </p>

</div>
</div>
<a id="af8d22dc8411a14450cad3f9fa7fa4e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d22dc8411a14450cad3f9fa7fa4e08">&#9670;&nbsp;</a></span>make_FieldPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> viskores::cont::make_FieldPoint </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to build point fields from <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">viskores::cont::UnknownArrayHandle</a>. </p>

</div>
</div>
<a id="a2f7476a8729dc6497be943049114b15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7476a8729dc6497be943049114b15d">&#9670;&nbsp;</a></span>MergePartitionedDataSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> viskores::cont::MergePartitionedDataSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>partitionedDataSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a87daa0e8ab1805ee441976f4e334daba">viskores::Float64</a>&#160;</td>
          <td class="paramname"><em>invalidValue</em> = <code>viskores::Nan64()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can merge multiple data sets into on data set. </p>
<p>This function assume all input partitions have the same coordinates systems. If a field does not exist in a specific partition but exists in other partitions, the invalide value will be used to fill the coresponding region of that field in the merged data set. </p>

</div>
</div>
<a id="a719de7feda498e1de433e9f6765109d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719de7feda498e1de433e9f6765109d1">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token_1_1Reference.html">viskores::cont::Token::Reference</a>&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a83c16dd072bbd5e62a2b14662bde00e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c16dd072bbd5e62a2b14662bde00e1">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token_1_1Reference.html">viskores::cont::Token::Reference</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a54a18d541080d09b0de55ea815500e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a54a18d541080d09b0de55ea815500e">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590">InitializeOptions</a> viskores::cont::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590">InitializeOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590">InitializeOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66bd7f4a2c0d643c9c1910c954775a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bd7f4a2c0d643c9c1910c954775a41">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token_1_1Reference.html">viskores::cont::Token::Reference</a>&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad30fc19fd133c816d78529fffbaa189f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30fc19fd133c816d78529fffbaa189f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token_1_1Reference.html">viskores::cont::Token::Reference</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aedbc121e495268abde8188a8f0eab2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbc121e495268abde8188a8f0eab2bf">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590">InitializeOptions</a> viskores::cont::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590">InitializeOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceviskores_1_1cont.html#a80bf92eb36c625655d6326126877b590">InitializeOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f616ecbe79f207ca5872e3821fc6569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f616ecbe79f207ca5872e3821fc6569">&#9670;&nbsp;</a></span>ParticleArrayCopy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParticleType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ParticleArrayCopy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; ParticleType, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#abb422027052141614ec406112a05576d">viskores::Vec3f</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy fields in <a class="el" href="classviskores_1_1Particle.html">viskores::Particle</a> to standard types. </p>
<p>Given a std::vector of <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> of <a class="el" href="classviskores_1_1Particle.html">viskores::Particle</a>, this function copies the position field into an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> of <code>Vec3f</code> objects. </p>

</div>
</div>
<a id="a0ff06db5fd197ac4f0889736f8d89b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff06db5fd197ac4f0889736f8d89b1c">&#9670;&nbsp;</a></span>ParticleArrayCopy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParticleType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ParticleArrayCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; ParticleType, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#abb422027052141614ec406112a05576d">viskores::Vec3f</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>CopyTerminatedOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy fields in <a class="el" href="classviskores_1_1Particle.html">viskores::Particle</a> to standard types. </p>
<p>Given an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> of <a class="el" href="classviskores_1_1Particle.html">viskores::Particle</a>, this function copies the position field into an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> of <code>Vec3f</code> objects. </p>

</div>
</div>
<a id="a8cee37917af66e3e41af0165f0fc9f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cee37917af66e3e41af0165f0fc9f49">&#9670;&nbsp;</a></span>ParticleArrayCopy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParticleType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ParticleArrayCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; ParticleType, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#abb422027052141614ec406112a05576d">viskores::Vec3f</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1ParticleStatus.html">viskores::ParticleStatus</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#af6c632281522d90b3f50ad6396efa1d5">viskores::FloatDefault</a>, <a class="el" href="structviskores_1_1cont_1_1StorageTagBasic.html">viskores::cont::StorageTagBasic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy all fields in <a class="el" href="classviskores_1_1Particle.html">viskores::Particle</a> to standard types. </p>
<p>Given an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> of <a class="el" href="classviskores_1_1Particle.html">viskores::Particle</a>, this function copies the position, ID, number of steps, status and time into a separate <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>. </p>

</div>
</div>
<a id="ad58baac161a1677d77d99945a6a7d497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58baac161a1677d77d99945a6a7d497">&#9670;&nbsp;</a></span>printSummary_ArrayHandle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::printSummary_ArrayHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageT &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4725d93587437375e4560b21e98b425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4725d93587437375e4560b21e98b425">&#9670;&nbsp;</a></span>SetGlobalGhostCellFieldName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::SetGlobalGhostCellFieldName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4867020c06e87e15da99893d978f1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4867020c06e87e15da99893d978f1f5">&#9670;&nbsp;</a></span>SetLogLevelName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::SetLogLevelName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8">viskores::cont::LogLevel</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a custom name to identify a log level. </p>
<p>The name will be truncated to 4 characters internally.</p>
<p>Must not be called after InitLogging. Such calls will fail and log an error.</p>
<p>There is no need to call this for the default viskores::cont::LogLevels. They are populated in InitLogging and will be overwritten. </p>

</div>
</div>
<a id="aec4f7f6500be6eb3a3a89faca64c55d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4f7f6500be6eb3a3a89faca64c55d0">&#9670;&nbsp;</a></span>SetLogThreadName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::SetLogThreadName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a humman-readable name to identify the current thread in the log output. </p>

</div>
</div>
<a id="a68ea95d4e6fe218139a769cba106f3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ea95d4e6fe218139a769cba106f3ba">&#9670;&nbsp;</a></span>SetStderrLogLevel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::SetStderrLogLevel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>verbosity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the range of log levels that will be printed to stderr. </p>
<p>All levels with an enum value less-than-or-equal-to <em>level</em> will be printed. </p>

</div>
</div>
<a id="a2f72e8c0f689d0f54f3b783d1e488633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f72e8c0f689d0f54f3b783d1e488633">&#9670;&nbsp;</a></span>SetStderrLogLevel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::SetStderrLogLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores_1_1cont.html#a24ee7b2f9f91bc845712d68320fb17b8">viskores::cont::LogLevel</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the range of log levels that will be printed to stderr. </p>
<p>All levels with an enum value less-than-or-equal-to <em>level</em> will be printed. </p>

</div>
</div>
<a id="a36f8b1c047e94f6a5566e8179fc8bf75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f8b1c047e94f6a5566e8179fc8bf75">&#9670;&nbsp;</a></span>ThrowArrayRangeComputeFailed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::ThrowArrayRangeComputeFailed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a945f308c83bb2157ee0c7a61ae540632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945f308c83bb2157ee0c7a61ae540632">&#9670;&nbsp;</a></span>throwFailedDynamicCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::throwFailedDynamicCast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>baseType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>derivedType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throws an <a class="el" href="classviskores_1_1cont_1_1ErrorBadType.html" title="This class is thrown when Viskores encounters data of a type that is incompatible with the current op...">ErrorBadType</a> exception with the following message: Cast failed: <code>baseType</code> --&gt; <code>derivedType"</code>. </p>
<p>This is generally caused by asking for a casting of a <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a> or UncertainArrayhandle with an insufficient type list. </p>

</div>
</div>
<a id="a18d414682f81a83ec8a9e31d5927b7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d414682f81a83ec8a9e31d5927b7f0">&#9670;&nbsp;</a></span>throwFailedRuntimeDeviceTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::throwFailedRuntimeDeviceTransfer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>className</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throws an ErrorBadeDevice exception with the following message: "Viskores was unable to transfer <code>className</code> to DeviceAdapter[id,name]. </p>
<p>This is generally caused by asking for execution on a DeviceAdapter that isn't compiled into Viskores. In the case of CUDA it can also be caused by accidentally compiling source files as C++ files instead of CUDA." </p>

</div>
</div>
<a id="acd3c6d772aceeae2817e9623ec7f984e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3c6d772aceeae2817e9623ec7f984e">&#9670;&nbsp;</a></span>TryExecute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::TryExecute </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to execute a functor on a set of devices until one succeeds. </p>
<p>This function takes a functor and optionally a set of devices to compile support. It then tries to run the functor for each device (in the order given in the list) until the execution succeeds.</p>
<p>The TryExecute is also able to perfectly forward arbitrary arguments onto the functor. These arguments must be placed after the optional device adapter list and will passed to the functor in the same order as listed.</p>
<p>The functor must implement the function call operator ( <code>operator()</code> ) with a return type of <code>bool</code> and that is <code>true</code> if the execution succeeds, <code>false</code> if it fails. If an exception is thrown from the functor, then the execution is assumed to have failed. The functor call operator must also take at least one argument being the required <code>DeviceAdapterTag</code> to use.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>TryCallExample</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> DeviceList&gt;</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(DeviceList tags, <span class="keywordtype">int</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Executing without a deviceId, or device list</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#acd3c6d772aceeae2817e9623ec7f984e">viskores::cont::TryExecute</a>(TryCallExample(), <span class="keywordtype">int</span>{42});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Executing with a device list</span></div>
<div class="line"><span class="keyword">using</span> DeviceList = <a class="code" href="structviskores_1_1List.html">viskores::List&lt;viskores::cont::DeviceAdapterTagSerial&gt;</a>;</div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#acd3c6d772aceeae2817e9623ec7f984e">viskores::cont::TryExecute</a>(TryCallExample(), DeviceList(), <span class="keywordtype">int</span>{42});</div>
</div><!-- fragment --><p>This function returns <code>true</code> if the functor succeeded on a device, <code>false</code> otherwise.</p>
<p>If no device list is specified, then <code>VISKORES_DEFAULT_DEVICE_ADAPTER_LIST</code> is used. </p>

</div>
</div>
<a id="a4b80f2a073d16de3e229078f743e3c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b80f2a073d16de3e229078f743e3c7d">&#9670;&nbsp;</a></span>TryExecuteOnDevice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::TryExecuteOnDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>devId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to execute a functor on a specific device selected at runtime. </p>
<p>This function takes a functor and a <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html" title="An object used to specify a device.">DeviceAdapterId</a></code> which represents a specific device to attempt to run on at runtime. It also optionally accepts a set of devices to compile support for.</p>
<p>It then iterates over the set of devices finding which one matches the provided adapter Id and is also enabled in the runtime. The function will return true only if the device adapter was valid, and the task was successfully run.</p>
<p>The TryExecuteOnDevice is also able to perfectly forward arbitrary arguments onto the functor. These arguments must be placed after the optional device adapter list and will passed to the functor in the same order as listed.</p>
<p>The functor must implement the function call operator ( <code>operator()</code> ) with a return type of <code>bool</code> and that is <code>true</code> if the execution succeeds, <code>false</code> if it fails. If an exception is thrown from the functor, then the execution is assumed to have failed. The functor call operator must also take at least one argument being the required <code>DeviceAdapterTag</code> to use.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>TryCallExample</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> DeviceList&gt;</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(DeviceList tags, <span class="keywordtype">int</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Execute only on the device which corresponds to devId</span></div>
<div class="line"><span class="comment">// Will not execute all if devId is</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a4b80f2a073d16de3e229078f743e3c7d">viskores::cont::TryExecuteOnDevice</a>(devId, TryCallExample(), <span class="keywordtype">int</span>{42});</div>
</div><!-- fragment --><p>This function returns <code>true</code> if the functor succeeded on a device, <code>false</code> otherwise.</p>
<p>If no device list is specified, then <code>VISKORES_DEFAULT_DEVICE_ADAPTER_LIST</code> is used. </p>

</div>
</div>
<a id="a089020f02278490190f76562947bcd26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089020f02278490190f76562947bcd26">&#9670;&nbsp;</a></span>TryExecuteOnDevice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename Arg1 , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::TryExecuteOnDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>devId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to execute a functor on a specific device selected at runtime. </p>
<p>This function takes a functor and a <code><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html" title="An object used to specify a device.">DeviceAdapterId</a></code> which represents a specific device to attempt to run on at runtime. It also optionally accepts a set of devices to compile support for.</p>
<p>It then iterates over the set of devices finding which one matches the provided adapter Id and is also enabled in the runtime. The function will return true only if the device adapter was valid, and the task was successfully run.</p>
<p>The TryExecuteOnDevice is also able to perfectly forward arbitrary arguments onto the functor. These arguments must be placed after the optional device adapter list and will passed to the functor in the same order as listed.</p>
<p>The functor must implement the function call operator ( <code>operator()</code> ) with a return type of <code>bool</code> and that is <code>true</code> if the execution succeeds, <code>false</code> if it fails. If an exception is thrown from the functor, then the execution is assumed to have failed. The functor call operator must also take at least one argument being the required <code>DeviceAdapterTag</code> to use.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>TryCallExample</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> DeviceList&gt;</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(DeviceList tags, <span class="keywordtype">int</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Execute only on the device which corresponds to devId</span></div>
<div class="line"><span class="comment">// Will not execute all if devId is</span></div>
<div class="line"><a class="code" href="namespaceviskores_1_1cont.html#a4b80f2a073d16de3e229078f743e3c7d">viskores::cont::TryExecuteOnDevice</a>(devId, TryCallExample(), <span class="keywordtype">int</span>{42});</div>
</div><!-- fragment --><p>This function returns <code>true</code> if the functor succeeded on a device, <code>false</code> otherwise.</p>
<p>If no device list is specified, then <code>VISKORES_DEFAULT_DEVICE_ADAPTER_LIST</code> is used. </p>

</div>
</div>
<a id="a13a2126a7115eef47302129dc57b7d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a2126a7115eef47302129dc57b7d04">&#9670;&nbsp;</a></span>TypeToString() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::cont::TypeToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use RTTI information to retrieve the name of the type T. </p>
<p>If logging is enabled and the platform supports it, the type name will also be demangled. </p>

</div>
</div>
<a id="a64da246b0f23c0c8f24c8e9110e43872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64da246b0f23c0c8f24c8e9110e43872">&#9670;&nbsp;</a></span>TypeToString() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::cont::TypeToString </td>
          <td>(</td>
          <td class="paramtype">const std::type_index &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use RTTI information to retrieve the name of the type T. </p>
<p>If logging is enabled and the platform supports it, the type name will also be demangled. </p>

</div>
</div>
<a id="a5cbb5d72e6df95c0f64aff4aab253add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbb5d72e6df95c0f64aff4aab253add">&#9670;&nbsp;</a></span>TypeToString() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::cont::TypeToString </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use RTTI information to retrieve the name of the type T. </p>
<p>If logging is enabled and the platform supports it, the type name will also be demangled. </p>

</div>
</div>
<a id="a0b7d99f653d743797b834c11fbf168eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7d99f653d743797b834c11fbf168eb">&#9670;&nbsp;</a></span>TypeToString() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::cont::TypeToString </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use RTTI information to retrieve the name of the type T. </p>
<p>If logging is enabled and the platform supports it, the type name will also be demangled. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespaceviskores_html_a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36"><div class="ttname"><a href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a></div><div class="ttdeci">@ Off</div></div>
<div class="ttc" id="anamespaceviskores_1_1cont_html_a25244dd8e50a0973b3d275ed2d67ed00"><div class="ttname"><a href="namespaceviskores_1_1cont.html#a25244dd8e50a0973b3d275ed2d67ed00">viskores::cont::ArraySetValues</a></div><div class="ttdeci">void ArraySetValues(const viskores::cont::ArrayHandle&lt; viskores::Id, SIds &gt; &amp;ids, const viskores::cont::ArrayHandle&lt; T, SValues &gt; &amp;values, const viskores::cont::ArrayHandle&lt; T, SData &gt; &amp;data)</div><div class="ttdoc">Set a small set of values in an ArrayHandle with minimal device transfers.</div><div class="ttdef"><b>Definition:</b> ArraySetValues.h:121</div></div>
<div class="ttc" id="aclassviskores_1_1cont_1_1ArrayHandle_html"><div class="ttname"><a href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a></div><div class="ttdoc">Manages an array-worth of data.</div><div class="ttdef"><b>Definition:</b> ArrayHandle.h:313</div></div>
<div class="ttc" id="anamespaceviskores_1_1cont_html_a41a300337f3f848bd77b125454ac9f00"><div class="ttname"><a href="namespaceviskores_1_1cont.html#a41a300337f3f848bd77b125454ac9f00">viskores::cont::ArrayGetValue</a></div><div class="ttdeci">T ArrayGetValue(viskores::Id id, const viskores::cont::ArrayHandle&lt; T, S &gt; &amp;data)</div><div class="ttdoc">Obtain a small set of values from an ArrayHandle with minimal device transfers.</div><div class="ttdef"><b>Definition:</b> ArrayGetValues.h:270</div></div>
<div class="ttc" id="astructviskores_1_1List_html"><div class="ttname"><a href="structviskores_1_1List.html">viskores::List</a></div><div class="ttdoc">A template used to hold a list of types.</div><div class="ttdef"><b>Definition:</b> List.h:47</div></div>
<div class="ttc" id="anamespaceviskores_html_a8e82cb49e20cef45fbeb58dc58790216"><div class="ttname"><a href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a></div><div class="ttdeci">viskores::Int64 Id</div><div class="ttdoc">Base type to use to index arrays.</div><div class="ttdef"><b>Definition:</b> Types.h:235</div></div>
<div class="ttc" id="anamespaceviskores_1_1cont_html_acd3c6d772aceeae2817e9623ec7f984e"><div class="ttname"><a href="namespaceviskores_1_1cont.html#acd3c6d772aceeae2817e9623ec7f984e">viskores::cont::TryExecute</a></div><div class="ttdeci">bool TryExecute(Functor &amp;&amp;functor, Args &amp;&amp;... args)</div><div class="ttdoc">Try to execute a functor on a set of devices until one succeeds.</div><div class="ttdef"><b>Definition:</b> TryExecute.h:252</div></div>
<div class="ttc" id="anamespaceviskores_html_a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3"><div class="ttname"><a href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3">viskores::CopyFlag::On</a></div><div class="ttdeci">@ On</div></div>
<div class="ttc" id="aclassviskores_1_1cont_1_1ColorTable_html"><div class="ttname"><a href="classviskores_1_1cont_1_1ColorTable.html">viskores::cont::ColorTable</a></div><div class="ttdoc">Color Table for coloring arbitrary fields.</div><div class="ttdef"><b>Definition:</b> cont/ColorTable.h:97</div></div>
<div class="ttc" id="aclassviskores_1_1cont_1_1ArrayHandle_html_ad084795021c8600def1edbc8b1872921"><div class="ttname"><a href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">viskores::cont::ArrayHandle::GetNumberOfValues</a></div><div class="ttdeci">viskores::Id GetNumberOfValues() const</div><div class="ttdoc">Returns the number of entries in the array.</div><div class="ttdef"><b>Definition:</b> ArrayHandle.h:482</div></div>
<div class="ttc" id="anamespaceviskores_1_1cont_html_a4b80f2a073d16de3e229078f743e3c7d"><div class="ttname"><a href="namespaceviskores_1_1cont.html#a4b80f2a073d16de3e229078f743e3c7d">viskores::cont::TryExecuteOnDevice</a></div><div class="ttdeci">bool TryExecuteOnDevice(viskores::cont::DeviceAdapterId devId, Functor &amp;&amp;functor)</div><div class="ttdoc">Try to execute a functor on a specific device selected at runtime.</div><div class="ttdef"><b>Definition:</b> TryExecute.h:186</div></div>
<div class="ttc" id="anamespaceviskores_1_1cont_html_a2a660d002917bda52fe319d3a809a344"><div class="ttname"><a href="namespaceviskores_1_1cont.html#a2a660d002917bda52fe319d3a809a344">viskores::cont::ArrayGetValues</a></div><div class="ttdeci">void ArrayGetValues(const viskores::cont::ArrayHandle&lt; viskores::Id, SIds &gt; &amp;ids, const viskores::cont::ArrayHandle&lt; T, SData &gt; &amp;data, viskores::cont::ArrayHandle&lt; T, SOut &gt; &amp;output)</div><div class="ttdoc">Obtain a small set of values from an ArrayHandle with minimal device transfers.</div><div class="ttdef"><b>Definition:</b> ArrayGetValues.h:127</div></div>
<div class="ttc" id="anamespaceviskores_1_1cont_html_a3ac73251dfcee427a6d163156caa9a30"><div class="ttname"><a href="namespaceviskores_1_1cont.html#a3ac73251dfcee427a6d163156caa9a30">viskores::cont::make_ArrayHandleSOA</a></div><div class="ttdeci">ArrayHandleSOA&lt; ValueType &gt; make_ArrayHandleSOA(std::initializer_list&lt; viskores::cont::ArrayHandle&lt; typename viskores::VecTraits&lt; ValueType &gt;::ComponentType, viskores::cont::StorageTagBasic &gt;&gt; &amp;&amp;componentArrays)</div><div class="ttdoc">Create a viskores::cont::ArrayHandleSOA with an initializer list of array handles.</div><div class="ttdef"><b>Definition:</b> ArrayHandleSOA.h:518</div></div>
<div class="ttc" id="anamespaceviskores_1_1cont_html_a9b92f2fe6c3c23da7071c725e9aaceb4"><div class="ttname"><a href="namespaceviskores_1_1cont.html#a9b92f2fe6c3c23da7071c725e9aaceb4">viskores::cont::make_ArrayHandleSOAMove</a></div><div class="ttdeci">ArrayHandleSOA&lt; viskores::Vec&lt; ComponentType, internal::VecSizeFromRemaining&lt; RemainingVectors... &gt;::value &gt; &gt; make_ArrayHandleSOAMove(std::vector&lt; ComponentType &gt; &amp;&amp;vector0, RemainingVectors &amp;&amp;... componentVectors)</div><div class="ttdoc">Create a viskores::cont::ArrayHandleSOA with a number of std::vector.</div><div class="ttdef"><b>Definition:</b> ArrayHandleSOA.h:651</div></div>
<div class="ttc" id="anamespaceviskores_1_1cont_html_acb7bee0f87fc44bbd353e2d80a20a234"><div class="ttname"><a href="namespaceviskores_1_1cont.html#acb7bee0f87fc44bbd353e2d80a20a234">viskores::cont::ColorTableMap</a></div><div class="ttdeci">bool ColorTableMap(const viskores::cont::ArrayHandle&lt; T, S &gt; &amp;values, const viskores::cont::ColorTableSamplesRGBA &amp;samples, viskores::cont::ArrayHandle&lt; viskores::Vec4ui_8 &gt; &amp;rgbaOut)</div><div class="ttdoc">Sample each value through an intermediate lookup/sample table to generate RGBA colors.</div><div class="ttdef"><b>Definition:</b> ColorTableMap.h:55</div></div>
<div class="ttc" id="aclassviskores_1_1cont_1_1ColorTableSamplesRGBA_html"><div class="ttname"><a href="classviskores_1_1cont_1_1ColorTableSamplesRGBA.html">viskores::cont::ColorTableSamplesRGBA</a></div><div class="ttdoc">Color Sample Table used with viskores::cont::ColorTable for fast coloring.</div><div class="ttdef"><b>Definition:</b> ColorTableSamples.h:40</div></div>
<div class="ttc" id="anamespaceviskores_1_1cont_html_a1e1482b3e7c4cbb782db98b3cc5c86c3"><div class="ttname"><a href="namespaceviskores_1_1cont.html#a1e1482b3e7c4cbb782db98b3cc5c86c3">viskores::cont::ArraySetValue</a></div><div class="ttdeci">void ArraySetValue(viskores::Id id, const T &amp;value, const viskores::cont::ArrayHandle&lt; T, SData &gt; &amp;data)</div><div class="ttdoc">Set a single value in an ArrayHandle at the specified index.</div><div class="ttdef"><b>Definition:</b> ArraySetValues.h:256</div></div>
<div class="ttc" id="aclassviskores_1_1cont_1_1ColorTableSamplesRGB_html"><div class="ttname"><a href="classviskores_1_1cont_1_1ColorTableSamplesRGB.html">viskores::cont::ColorTableSamplesRGB</a></div><div class="ttdoc">Color Sample Table used with viskores::cont::ColorTable for fast coloring.</div><div class="ttdef"><b>Definition:</b> ColorTableSamples.h:60</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
