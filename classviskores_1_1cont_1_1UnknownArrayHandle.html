<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Viskores: viskores::cont::UnknownArrayHandle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Viskores
   &#160;<span id="projectnumber">1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceviskores.html">viskores</a></li><li class="navelem"><a class="el" href="namespaceviskores_1_1cont.html">cont</a></li><li class="navelem"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">UnknownArrayHandle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classviskores_1_1cont_1_1UnknownArrayHandle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">viskores::cont::UnknownArrayHandle Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> of an unknown value type and storage.  
 <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="UnknownArrayHandle_8h_source.html">UnknownArrayHandle.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for viskores::cont::UnknownArrayHandle:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classviskores_1_1cont_1_1UnknownArrayHandle.png" usemap="#viskores::cont::UnknownArrayHandle_map" alt=""/>
  <map id="viskores::cont::UnknownArrayHandle_map" name="viskores::cont::UnknownArrayHandle_map">
<area href="classviskores_1_1cont_1_1UncertainArrayHandle.html" title="An ArrayHandle of an uncertain value type and storage." alt="viskores::cont::UncertainArrayHandle&lt; ValueTypeList, StorageTypeList &gt;" shape="rect" coords="0,56,426,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9d1875f99438cf9a36ba1ffaae261982"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a9d1875f99438cf9a36ba1ffaae261982">UnknownArrayHandle</a> ()=default</td></tr>
<tr class="separator:a9d1875f99438cf9a36ba1ffaae261982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45dbe7fa26d5baf649202c917409ac8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ae45dbe7fa26d5baf649202c917409ac8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#ae45dbe7fa26d5baf649202c917409ac8">UnknownArrayHandle</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;array)</td></tr>
<tr class="separator:ae45dbe7fa26d5baf649202c917409ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fead1f7f9c3554ac0d4d72c009bd872"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a8fead1f7f9c3554ac0d4d72c009bd872">IsValid</a> () const</td></tr>
<tr class="memdesc:a8fead1f7f9c3554ac0d4d72c009bd872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether an array is stored in this <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code>.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a8fead1f7f9c3554ac0d4d72c009bd872">More...</a><br /></td></tr>
<tr class="separator:a8fead1f7f9c3554ac0d4d72c009bd872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0fd912a060b0190376dff095cf35e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">UnknownArrayHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a1a0fd912a060b0190376dff095cf35e9">NewInstance</a> () const</td></tr>
<tr class="memdesc:a1a0fd912a060b0190376dff095cf35e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new array of the same type as this array.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a1a0fd912a060b0190376dff095cf35e9">More...</a><br /></td></tr>
<tr class="separator:a1a0fd912a060b0190376dff095cf35e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b9ed2310ddce8693905ac54b24f8eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">UnknownArrayHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a43b9ed2310ddce8693905ac54b24f8eb">NewInstanceBasic</a> () const</td></tr>
<tr class="memdesc:a43b9ed2310ddce8693905ac54b24f8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html" title="Basic array storage for an array handle.">ArrayHandleBasic</a></code> with the same <code>ValueType</code> as this array.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a43b9ed2310ddce8693905ac54b24f8eb">More...</a><br /></td></tr>
<tr class="separator:a43b9ed2310ddce8693905ac54b24f8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1ddf962dc8f5daca8f25ca92e402f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">UnknownArrayHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a5e1ddf962dc8f5daca8f25ca92e402f5">NewInstanceFloatBasic</a> () const</td></tr>
<tr class="memdesc:a5e1ddf962dc8f5daca8f25ca92e402f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html" title="Basic array storage for an array handle.">ArrayHandleBasic</a></code> with the base component of <code><a class="el" href="namespaceviskores.html#af6c632281522d90b3f50ad6396efa1d5" title="The floating point type to use when no other precision is specified.">viskores::FloatDefault</a></code>  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a5e1ddf962dc8f5daca8f25ca92e402f5">More...</a><br /></td></tr>
<tr class="separator:a5e1ddf962dc8f5daca8f25ca92e402f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4e9bda420b2c9542557dc63c908338"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6e4e9bda420b2c9542557dc63c908338">GetValueTypeName</a> () const</td></tr>
<tr class="memdesc:a6e4e9bda420b2c9542557dc63c908338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the value type stored in the array.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6e4e9bda420b2c9542557dc63c908338">More...</a><br /></td></tr>
<tr class="separator:a6e4e9bda420b2c9542557dc63c908338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aff2d8dacf2a7f49e6a9bfa72c8bb84"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a4aff2d8dacf2a7f49e6a9bfa72c8bb84">GetBaseComponentTypeName</a> () const</td></tr>
<tr class="memdesc:a4aff2d8dacf2a7f49e6a9bfa72c8bb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the base component of the value type stored in the array.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a4aff2d8dacf2a7f49e6a9bfa72c8bb84">More...</a><br /></td></tr>
<tr class="separator:a4aff2d8dacf2a7f49e6a9bfa72c8bb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3c0b554ba03205f2e4bb8571dac794"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#acd3c0b554ba03205f2e4bb8571dac794">GetStorageTypeName</a> () const</td></tr>
<tr class="memdesc:acd3c0b554ba03205f2e4bb8571dac794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the storage tag for the array.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#acd3c0b554ba03205f2e4bb8571dac794">More...</a><br /></td></tr>
<tr class="separator:acd3c0b554ba03205f2e4bb8571dac794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f5cdbe0191c81c02f3c0ec5a69da8e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a00f5cdbe0191c81c02f3c0ec5a69da8e">GetArrayTypeName</a> () const</td></tr>
<tr class="memdesc:a00f5cdbe0191c81c02f3c0ec5a69da8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of the underlying data type.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a00f5cdbe0191c81c02f3c0ec5a69da8e">More...</a><br /></td></tr>
<tr class="separator:a00f5cdbe0191c81c02f3c0ec5a69da8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6815aa320fc676485ff64cd0d6a7efcf"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a6815aa320fc676485ff64cd0d6a7efcf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6815aa320fc676485ff64cd0d6a7efcf">IsValueType</a> () const</td></tr>
<tr class="memdesc:a6815aa320fc676485ff64cd0d6a7efcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this array matches the ValueType template argument.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6815aa320fc676485ff64cd0d6a7efcf">More...</a><br /></td></tr>
<tr class="separator:a6815aa320fc676485ff64cd0d6a7efcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e9651b39c31109d02b68cd9e1e0b40"><td class="memTemplParams" colspan="2">template&lt;typename StorageType &gt; </td></tr>
<tr class="memitem:ae6e9651b39c31109d02b68cd9e1e0b40"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#ae6e9651b39c31109d02b68cd9e1e0b40">IsStorageType</a> () const</td></tr>
<tr class="memdesc:ae6e9651b39c31109d02b68cd9e1e0b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this array matches the StorageType template argument.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#ae6e9651b39c31109d02b68cd9e1e0b40">More...</a><br /></td></tr>
<tr class="separator:ae6e9651b39c31109d02b68cd9e1e0b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a88cf3dd7e33eac5a6057c80c933512"><td class="memTemplParams" colspan="2">template&lt;typename BaseComponentType &gt; </td></tr>
<tr class="memitem:a8a88cf3dd7e33eac5a6057c80c933512"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a8a88cf3dd7e33eac5a6057c80c933512">IsBaseComponentType</a> () const</td></tr>
<tr class="memdesc:a8a88cf3dd7e33eac5a6057c80c933512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this array's <code>ValueType</code> has the provided base component type.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a8a88cf3dd7e33eac5a6057c80c933512">More...</a><br /></td></tr>
<tr class="separator:a8a88cf3dd7e33eac5a6057c80c933512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3947b5b80c3cd41d487c14efaec61e4"><td class="memTemplParams" colspan="2">template&lt;typename ArrayHandleType &gt; </td></tr>
<tr class="memitem:aa3947b5b80c3cd41d487c14efaec61e4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#aa3947b5b80c3cd41d487c14efaec61e4">IsType</a> () const</td></tr>
<tr class="memdesc:aa3947b5b80c3cd41d487c14efaec61e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this array matches the ArrayHandleType template argument.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#aa3947b5b80c3cd41d487c14efaec61e4">More...</a><br /></td></tr>
<tr class="separator:aa3947b5b80c3cd41d487c14efaec61e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1d1daa5a6dcb5500d4e9e4b9eb6639"><td class="memTemplParams" colspan="2">template&lt;typename NewValueTypeList , typename NewStorageTypeList &gt; </td></tr>
<tr class="memitem:aac1d1daa5a6dcb5500d4e9e4b9eb6639"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1UncertainArrayHandle.html">viskores::cont::UncertainArrayHandle</a>&lt; NewValueTypeList, NewStorageTypeList &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#aac1d1daa5a6dcb5500d4e9e4b9eb6639">ResetTypes</a> (NewValueTypeList=NewValueTypeList{}, NewStorageTypeList=NewStorageTypeList{}) const</td></tr>
<tr class="memdesc:aac1d1daa5a6dcb5500d4e9e4b9eb6639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns potential value and storage types.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#aac1d1daa5a6dcb5500d4e9e4b9eb6639">More...</a><br /></td></tr>
<tr class="separator:aac1d1daa5a6dcb5500d4e9e4b9eb6639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d04e21709749ed2608d3a8d3337f7ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a7d04e21709749ed2608d3a8d3337f7ef">GetNumberOfValues</a> () const</td></tr>
<tr class="memdesc:a7d04e21709749ed2608d3a8d3337f7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of values in the array.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a7d04e21709749ed2608d3a8d3337f7ef">More...</a><br /></td></tr>
<tr class="separator:a7d04e21709749ed2608d3a8d3337f7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10147f1ed38a3773f7336148cf3f3e20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a10147f1ed38a3773f7336148cf3f3e20">GetNumberOfComponents</a> () const</td></tr>
<tr class="memdesc:a10147f1ed38a3773f7336148cf3f3e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of components for each value in the array.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a10147f1ed38a3773f7336148cf3f3e20">More...</a><br /></td></tr>
<tr class="separator:a10147f1ed38a3773f7336148cf3f3e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efb94483dfb57715fe36512a638e2a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a2efb94483dfb57715fe36512a638e2a2">GetNumberOfComponentsFlat</a> () const</td></tr>
<tr class="memdesc:a2efb94483dfb57715fe36512a638e2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of components for each value in the array.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a2efb94483dfb57715fe36512a638e2a2">More...</a><br /></td></tr>
<tr class="separator:a2efb94483dfb57715fe36512a638e2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e42721611983b4b1b871f098d49204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a56e42721611983b4b1b871f098d49204">Allocate</a> (<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numValues, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> preserve, <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;token) const</td></tr>
<tr class="memdesc:a56e42721611983b4b1b871f098d49204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate the data in the array.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a56e42721611983b4b1b871f098d49204">More...</a><br /></td></tr>
<tr class="separator:a56e42721611983b4b1b871f098d49204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f737366eb595e11bf121c93007f9f0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a9f737366eb595e11bf121c93007f9f0a">Allocate</a> (<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numValues, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> preserve=<a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a>) const</td></tr>
<tr class="memdesc:a9f737366eb595e11bf121c93007f9f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate the data in the array.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a9f737366eb595e11bf121c93007f9f0a">More...</a><br /></td></tr>
<tr class="separator:a9f737366eb595e11bf121c93007f9f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1d9c840e6654f38772a2620f0e597d"><td class="memTemplParams" colspan="2">template&lt;typename ArrayHandleType &gt; </td></tr>
<tr class="memitem:a6f1d9c840e6654f38772a2620f0e597d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6f1d9c840e6654f38772a2620f0e597d">CanConvert</a> () const</td></tr>
<tr class="memdesc:a6f1d9c840e6654f38772a2620f0e597d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the contained array can be passed to the given array type.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6f1d9c840e6654f38772a2620f0e597d">More...</a><br /></td></tr>
<tr class="separator:a6f1d9c840e6654f38772a2620f0e597d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd19cc2cefd571d9106340cd4ec85fb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a5bd19cc2cefd571d9106340cd4ec85fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a5bd19cc2cefd571d9106340cd4ec85fb">AsArrayHandle</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;array) const</td></tr>
<tr class="memdesc:a5bd19cc2cefd571d9106340cd4ec85fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this array cast appropriately and stored in the given <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> type.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a5bd19cc2cefd571d9106340cd4ec85fb">More...</a><br /></td></tr>
<tr class="separator:a5bd19cc2cefd571d9106340cd4ec85fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce6bffd5bedd1d891a941d048fb7ae3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ce6bffd5bedd1d891a941d048fb7ae3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6ce6bffd5bedd1d891a941d048fb7ae3">AsArrayHandle</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T &gt; &amp;array) const</td></tr>
<tr class="memdesc:a6ce6bffd5bedd1d891a941d048fb7ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this array cast appropriately and stored in the given <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> type.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6ce6bffd5bedd1d891a941d048fb7ae3">More...</a><br /></td></tr>
<tr class="separator:a6ce6bffd5bedd1d891a941d048fb7ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072dc7bd1b12283984a33193aef68ecc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ss&gt; </td></tr>
<tr class="memitem:a072dc7bd1b12283984a33193aef68ecc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a072dc7bd1b12283984a33193aef68ecc">AsArrayHandle</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1StorageTagMultiplexer.html">viskores::cont::StorageTagMultiplexer</a>&lt; Ss... &gt;&gt; &amp;array) const</td></tr>
<tr class="memdesc:a072dc7bd1b12283984a33193aef68ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this array cast appropriately and stored in the given <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> type.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a072dc7bd1b12283984a33193aef68ecc">More...</a><br /></td></tr>
<tr class="separator:a072dc7bd1b12283984a33193aef68ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9af375303b927bd099edb34de88011"><td class="memTemplParams" colspan="2">template&lt;typename TargetT , typename SourceT , typename SourceS &gt; </td></tr>
<tr class="memitem:a6d9af375303b927bd099edb34de88011"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6d9af375303b927bd099edb34de88011">AsArrayHandle</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; TargetT, <a class="el" href="structviskores_1_1cont_1_1StorageTagCast.html">viskores::cont::StorageTagCast</a>&lt; SourceT, SourceS &gt;&gt; &amp;array) const</td></tr>
<tr class="memdesc:a6d9af375303b927bd099edb34de88011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this array cast appropriately and stored in the given <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> type.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6d9af375303b927bd099edb34de88011">More...</a><br /></td></tr>
<tr class="separator:a6d9af375303b927bd099edb34de88011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b22736c7201f05dbfe5f7e2926f7d04"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b22736c7201f05dbfe5f7e2926f7d04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a0b22736c7201f05dbfe5f7e2926f7d04">AsArrayHandle</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1StorageTagRuntimeVec.html">viskores::cont::StorageTagRuntimeVec</a> &gt; &amp;array) const</td></tr>
<tr class="memdesc:a0b22736c7201f05dbfe5f7e2926f7d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this array cast appropriately and stored in the given <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> type.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a0b22736c7201f05dbfe5f7e2926f7d04">More...</a><br /></td></tr>
<tr class="separator:a0b22736c7201f05dbfe5f7e2926f7d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a51d448ee9944dc3d53d7436bcbd16"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06a51d448ee9944dc3d53d7436bcbd16"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a06a51d448ee9944dc3d53d7436bcbd16">AsArrayHandle</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1StorageTagSOAStride.html">viskores::cont::StorageTagSOAStride</a> &gt; &amp;array) const</td></tr>
<tr class="memdesc:a06a51d448ee9944dc3d53d7436bcbd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this array cast appropriately and stored in the given <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> type.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a06a51d448ee9944dc3d53d7436bcbd16">More...</a><br /></td></tr>
<tr class="separator:a06a51d448ee9944dc3d53d7436bcbd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e5956f8378be870582063e7cee62ce"><td class="memTemplParams" colspan="2">template&lt;typename ArrayType &gt; </td></tr>
<tr class="memitem:a81e5956f8378be870582063e7cee62ce"><td class="memTemplItemLeft" align="right" valign="top">ArrayType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a81e5956f8378be870582063e7cee62ce">AsArrayHandle</a> () const</td></tr>
<tr class="memdesc:a81e5956f8378be870582063e7cee62ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this array cast appropriately and stored in the given <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> type.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a81e5956f8378be870582063e7cee62ce">More...</a><br /></td></tr>
<tr class="separator:a81e5956f8378be870582063e7cee62ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08c75fc53700b44c81f088e5aa1ab37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#ad08c75fc53700b44c81f088e5aa1ab37">DeepCopyFrom</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;source)</td></tr>
<tr class="memdesc:ad08c75fc53700b44c81f088e5aa1ab37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copies data from another <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code>.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#ad08c75fc53700b44c81f088e5aa1ab37">More...</a><br /></td></tr>
<tr class="separator:ad08c75fc53700b44c81f088e5aa1ab37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d34a596c8b167f9c0ef7fa9e98bb4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a76d34a596c8b167f9c0ef7fa9e98bb4d">DeepCopyFrom</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;source) const</td></tr>
<tr class="memdesc:a76d34a596c8b167f9c0ef7fa9e98bb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copies data from another <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code>.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a76d34a596c8b167f9c0ef7fa9e98bb4d">More...</a><br /></td></tr>
<tr class="separator:a76d34a596c8b167f9c0ef7fa9e98bb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbb666a783d2edbc1e7143b81446015"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#accbb666a783d2edbc1e7143b81446015">CopyShallowIfPossible</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;source)</td></tr>
<tr class="memdesc:accbb666a783d2edbc1e7143b81446015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts a shallow copy of an array or a deep copy if that is not possible.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#accbb666a783d2edbc1e7143b81446015">More...</a><br /></td></tr>
<tr class="separator:accbb666a783d2edbc1e7143b81446015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb095150dde32160fdc99fa0b78858c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a8cb095150dde32160fdc99fa0b78858c">CopyShallowIfPossible</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;source) const</td></tr>
<tr class="memdesc:a8cb095150dde32160fdc99fa0b78858c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts a shallow copy of an array or a deep copy if that is not possible.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a8cb095150dde32160fdc99fa0b78858c">More...</a><br /></td></tr>
<tr class="separator:a8cb095150dde32160fdc99fa0b78858c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3b4ec6b0153f6f6e006b0882d63ba4"><td class="memTemplParams" colspan="2">template&lt;typename BaseComponentType &gt; </td></tr>
<tr class="memitem:a3e3b4ec6b0153f6f6e006b0882d63ba4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleStride.html">viskores::cont::ArrayHandleStride</a>&lt; BaseComponentType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a3e3b4ec6b0153f6f6e006b0882d63ba4">ExtractComponent</a> (<a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> componentIndex, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> allowCopy=<a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3">viskores::CopyFlag::On</a>) const</td></tr>
<tr class="memdesc:a3e3b4ec6b0153f6f6e006b0882d63ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a component of the array.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a3e3b4ec6b0153f6f6e006b0882d63ba4">More...</a><br /></td></tr>
<tr class="separator:a3e3b4ec6b0153f6f6e006b0882d63ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3031d78f00569e963a0011ee1d287483"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a3031d78f00569e963a0011ee1d287483">ExtractIsInefficient</a> () const</td></tr>
<tr class="memdesc:a3031d78f00569e963a0011ee1d287483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a call to <code>ExtractComponent</code> or a related method is inefficient.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a3031d78f00569e963a0011ee1d287483">More...</a><br /></td></tr>
<tr class="separator:a3031d78f00569e963a0011ee1d287483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69817a433bae60cdf3649d96090971b8"><td class="memTemplParams" colspan="2">template&lt;typename BaseComponentType &gt; </td></tr>
<tr class="memitem:a69817a433bae60cdf3649d96090971b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRecombineVec.html">viskores::cont::ArrayHandleRecombineVec</a>&lt; BaseComponentType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a69817a433bae60cdf3649d96090971b8">ExtractArrayFromComponents</a> (<a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> allowCopy=<a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3">viskores::CopyFlag::On</a>) const</td></tr>
<tr class="memdesc:a69817a433bae60cdf3649d96090971b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the array knowing only the component type of the array.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a69817a433bae60cdf3649d96090971b8">More...</a><br /></td></tr>
<tr class="separator:a69817a433bae60cdf3649d96090971b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4025fd0aeb7713db9adc79bd85b3b266"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a4025fd0aeb7713db9adc79bd85b3b266"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOAStride.html">viskores::cont::ArrayHandleSOAStride</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a4025fd0aeb7713db9adc79bd85b3b266">ExtractArrayWithValueType</a> (<a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> allowCopy=<a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3">viskores::CopyFlag::On</a>) const</td></tr>
<tr class="memdesc:a4025fd0aeb7713db9adc79bd85b3b266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract an array with any storage for a given value type.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a4025fd0aeb7713db9adc79bd85b3b266">More...</a><br /></td></tr>
<tr class="separator:a4025fd0aeb7713db9adc79bd85b3b266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4814b53bff37eb59187dd374ce3ac2f7"><td class="memTemplParams" colspan="2">template&lt;typename TypeList , typename StorageList , typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a4814b53bff37eb59187dd374ce3ac2f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a4814b53bff37eb59187dd374ce3ac2f7">CastAndCallForTypes</a> (Functor &amp;&amp;functor, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a4814b53bff37eb59187dd374ce3ac2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a functor using the underlying array type.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a4814b53bff37eb59187dd374ce3ac2f7">More...</a><br /></td></tr>
<tr class="separator:a4814b53bff37eb59187dd374ce3ac2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb6c8a9580516949494bc7e0ed64394"><td class="memTemplParams" colspan="2">template&lt;typename TypeList , typename StorageList , typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a7bb6c8a9580516949494bc7e0ed64394"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a7bb6c8a9580516949494bc7e0ed64394">CastAndCallForTypesWithFloatFallback</a> (Functor &amp;&amp;functor, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a7bb6c8a9580516949494bc7e0ed64394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a functor using the underlying array type with a float cast fallback.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a7bb6c8a9580516949494bc7e0ed64394">More...</a><br /></td></tr>
<tr class="separator:a7bb6c8a9580516949494bc7e0ed64394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f002c6ac04e515c1d4dc5012ed2c5d"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a33f002c6ac04e515c1d4dc5012ed2c5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a33f002c6ac04e515c1d4dc5012ed2c5d">CastAndCallWithExtractedArray</a> (Functor &amp;&amp;functor, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a33f002c6ac04e515c1d4dc5012ed2c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a functor on an array extracted from the components.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a33f002c6ac04e515c1d4dc5012ed2c5d">More...</a><br /></td></tr>
<tr class="separator:a33f002c6ac04e515c1d4dc5012ed2c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c35618c67998aadd795763deea1221"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a75c35618c67998aadd795763deea1221">ReleaseResourcesExecution</a> () const</td></tr>
<tr class="memdesc:a75c35618c67998aadd795763deea1221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases any resources being used in the execution environment (that are not being shared by the control environment).  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a75c35618c67998aadd795763deea1221">More...</a><br /></td></tr>
<tr class="separator:a75c35618c67998aadd795763deea1221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae864caddac62f53717c934d2496f828e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#ae864caddac62f53717c934d2496f828e">ReleaseResources</a> () const</td></tr>
<tr class="memdesc:ae864caddac62f53717c934d2496f828e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases all resources in both the control and execution environments.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#ae864caddac62f53717c934d2496f828e">More...</a><br /></td></tr>
<tr class="separator:ae864caddac62f53717c934d2496f828e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a9407e114e1be4bb85898dec71d606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#ad1a9407e114e1be4bb85898dec71d606">PrintSummary</a> (std::ostream &amp;out, bool full=false) const</td></tr>
<tr class="memdesc:ad1a9407e114e1be4bb85898dec71d606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a summary of the array's type, size, and contents.  <a href="classviskores_1_1cont_1_1UnknownArrayHandle.html#ad1a9407e114e1be4bb85898dec71d606">More...</a><br /></td></tr>
<tr class="separator:ad1a9407e114e1be4bb85898dec71d606"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a31de41eed5afc0a7f86a5f9da0fe245e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a31de41eed5afc0a7f86a5f9da0fe245e">IsValueTypeImpl</a> (std::type_index type) const</td></tr>
<tr class="separator:a31de41eed5afc0a7f86a5f9da0fe245e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637f66e393e256a0703951e6839ea3f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a637f66e393e256a0703951e6839ea3f3">IsStorageTypeImpl</a> (std::type_index type) const</td></tr>
<tr class="separator:a637f66e393e256a0703951e6839ea3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620c5cc6fba5c2f1d0f34d2fd7f599fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a620c5cc6fba5c2f1d0f34d2fd7f599fd">IsBaseComponentTypeImpl</a> (const detail::UnknownAHComponentInfo &amp;type) const</td></tr>
<tr class="separator:a620c5cc6fba5c2f1d0f34d2fd7f599fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78721563269cdf385652ee04780aae5d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a78721563269cdf385652ee04780aae5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a78721563269cdf385652ee04780aae5d">BaseAsArrayHandle</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;array) const</td></tr>
<tr class="separator:a78721563269cdf385652ee04780aae5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a50959a4873ba99c2145ba797a0347ac4"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; detail::UnknownAHContainer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a50959a4873ba99c2145ba797a0347ac4">Container</a></td></tr>
<tr class="separator:a50959a4873ba99c2145ba797a0347ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> of an unknown value type and storage. </p>
<p><code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code> holds an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> object using runtime polymorphism to manage different value and storage types rather than compile-time templates. This adds a programming convenience that helps avoid a proliferation of templates. It also provides the management necessary to interface Viskores with data sources where types will not be known until runtime and is the storage mechanism for classes like <code><a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">DataSet</a></code> and <code><a class="el" href="classviskores_1_1cont_1_1Field.html" title="A Field encapsulates an array on some piece of the mesh, such as the points, a cell set,...">Field</a></code> that can hold numerous types.</p>
<p>To interface between the runtime polymorphism and the templated algorithms in Viskores, <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code> contains a method named <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a4814b53bff37eb59187dd374ce3ac2f7" title="Call a functor using the underlying array type.">CastAndCallForTypes()</a></code> that determines the correct type from some known list of value types and storage. This mechanism is used internally by Viskores's worklet invocation mechanism to determine the type when running algorithms.</p>
<p>If the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code> is used in a context where the possible array types can be whittled down to a finite list (or you have to), you can specify lists of value types and storage using the <code>ResetTypesAndStorage()</code> method. This will convert this object to an <code><a class="el" href="classviskores_1_1cont_1_1UncertainArrayHandle.html" title="An ArrayHandle of an uncertain value type and storage.">UncertainArrayHandle</a></code> of the given types. In cases where a finite set of types need to specified but there is no known subset, <code>VISKORES_DEFAULT_TYPE_LIST</code> and <code>VISKORES_DEFAULT_STORAGE_LIST</code> can be used.</p>
<p><code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleCast.html" title="Cast the values of an array to the specified type, on demand.">ArrayHandleCast</a></code> and <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleMultiplexer.html" title="An ArrayHandle that can behave like several other handles.">ArrayHandleMultiplexer</a></code> are treated special. If the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code> is set to an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> of one of these types, it will actually store the <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> contained. Likewise, if the <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> is retrieved as one of these types, it will automatically convert it if possible. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9d1875f99438cf9a36ba1ffaae261982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1875f99438cf9a36ba1ffaae261982">&#9670;&nbsp;</a></span>UnknownArrayHandle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">viskores::cont::UnknownArrayHandle::UnknownArrayHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae45dbe7fa26d5baf649202c917409ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45dbe7fa26d5baf649202c917409ac8">&#9670;&nbsp;</a></span>UnknownArrayHandle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">viskores::cont::UnknownArrayHandle::UnknownArrayHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a56e42721611983b4b1b871f098d49204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e42721611983b4b1b871f098d49204">&#9670;&nbsp;</a></span>Allocate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::Allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>preserve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate the data in the array. </p>
<p>The allocation works the same as the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a56e42721611983b4b1b871f098d49204" title="Reallocate the data in the array.">Allocate()</a></code> method of <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a></code>. </p>

</div>
</div>
<a id="a9f737366eb595e11bf121c93007f9f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f737366eb595e11bf121c93007f9f0a">&#9670;&nbsp;</a></span>Allocate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::Allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>preserve</em> = <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate the data in the array. </p>
<p>The allocation works the same as the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a56e42721611983b4b1b871f098d49204" title="Reallocate the data in the array.">Allocate()</a></code> method of <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a></code>. </p>

</div>
</div>
<a id="a81e5956f8378be870582063e7cee62ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e5956f8378be870582063e7cee62ce">&#9670;&nbsp;</a></span>AsArrayHandle() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ArrayType viskores::cont::UnknownArrayHandle::AsArrayHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this array cast appropriately and stored in the given <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> type. </p>
<p>Throws a <code><a class="el" href="classviskores_1_1cont_1_1ErrorBadType.html" title="This class is thrown when Viskores encounters data of a type that is incompatible with the current op...">viskores::cont::ErrorBadType</a></code> if the stored array cannot be stored in the given array type. Use the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6f1d9c840e6654f38772a2620f0e597d" title="Determine if the contained array can be passed to the given array type.">CanConvert()</a></code> method to determine if the array can be returned with the given type. </p>

</div>
</div>
<a id="a6ce6bffd5bedd1d891a941d048fb7ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce6bffd5bedd1d891a941d048fb7ae3">&#9670;&nbsp;</a></span>AsArrayHandle() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::AsArrayHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this array cast appropriately and stored in the given <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> type. </p>
<p>Throws a <code><a class="el" href="classviskores_1_1cont_1_1ErrorBadType.html" title="This class is thrown when Viskores encounters data of a type that is incompatible with the current op...">viskores::cont::ErrorBadType</a></code> if the stored array cannot be stored in the given array type. Use the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6f1d9c840e6654f38772a2620f0e597d" title="Determine if the contained array can be passed to the given array type.">CanConvert()</a></code> method to determine if the array can be returned with the given type. </p>

</div>
</div>
<a id="a5bd19cc2cefd571d9106340cd4ec85fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd19cc2cefd571d9106340cd4ec85fb">&#9670;&nbsp;</a></span>AsArrayHandle() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::AsArrayHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this array cast appropriately and stored in the given <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> type. </p>
<p>Throws a <code><a class="el" href="classviskores_1_1cont_1_1ErrorBadType.html" title="This class is thrown when Viskores encounters data of a type that is incompatible with the current op...">viskores::cont::ErrorBadType</a></code> if the stored array cannot be stored in the given array type. Use the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6f1d9c840e6654f38772a2620f0e597d" title="Determine if the contained array can be passed to the given array type.">CanConvert()</a></code> method to determine if the array can be returned with the given type. </p>

</div>
</div>
<a id="a072dc7bd1b12283984a33193aef68ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072dc7bd1b12283984a33193aef68ecc">&#9670;&nbsp;</a></span>AsArrayHandle() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ss&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::AsArrayHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1StorageTagMultiplexer.html">viskores::cont::StorageTagMultiplexer</a>&lt; Ss... &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this array cast appropriately and stored in the given <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> type. </p>
<p>Throws a <code><a class="el" href="classviskores_1_1cont_1_1ErrorBadType.html" title="This class is thrown when Viskores encounters data of a type that is incompatible with the current op...">viskores::cont::ErrorBadType</a></code> if the stored array cannot be stored in the given array type. Use the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6f1d9c840e6654f38772a2620f0e597d" title="Determine if the contained array can be passed to the given array type.">CanConvert()</a></code> method to determine if the array can be returned with the given type. </p>

</div>
</div>
<a id="a0b22736c7201f05dbfe5f7e2926f7d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b22736c7201f05dbfe5f7e2926f7d04">&#9670;&nbsp;</a></span>AsArrayHandle() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::AsArrayHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1StorageTagRuntimeVec.html">viskores::cont::StorageTagRuntimeVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this array cast appropriately and stored in the given <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> type. </p>
<p>Throws a <code><a class="el" href="classviskores_1_1cont_1_1ErrorBadType.html" title="This class is thrown when Viskores encounters data of a type that is incompatible with the current op...">viskores::cont::ErrorBadType</a></code> if the stored array cannot be stored in the given array type. Use the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6f1d9c840e6654f38772a2620f0e597d" title="Determine if the contained array can be passed to the given array type.">CanConvert()</a></code> method to determine if the array can be returned with the given type. </p>

</div>
</div>
<a id="a06a51d448ee9944dc3d53d7436bcbd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a51d448ee9944dc3d53d7436bcbd16">&#9670;&nbsp;</a></span>AsArrayHandle() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::AsArrayHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1StorageTagSOAStride.html">viskores::cont::StorageTagSOAStride</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this array cast appropriately and stored in the given <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> type. </p>
<p>Throws a <code><a class="el" href="classviskores_1_1cont_1_1ErrorBadType.html" title="This class is thrown when Viskores encounters data of a type that is incompatible with the current op...">viskores::cont::ErrorBadType</a></code> if the stored array cannot be stored in the given array type. Use the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6f1d9c840e6654f38772a2620f0e597d" title="Determine if the contained array can be passed to the given array type.">CanConvert()</a></code> method to determine if the array can be returned with the given type. </p>

</div>
</div>
<a id="a6d9af375303b927bd099edb34de88011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9af375303b927bd099edb34de88011">&#9670;&nbsp;</a></span>AsArrayHandle() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT , typename SourceT , typename SourceS &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::AsArrayHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; TargetT, <a class="el" href="structviskores_1_1cont_1_1StorageTagCast.html">viskores::cont::StorageTagCast</a>&lt; SourceT, SourceS &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this array cast appropriately and stored in the given <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> type. </p>
<p>Throws a <code><a class="el" href="classviskores_1_1cont_1_1ErrorBadType.html" title="This class is thrown when Viskores encounters data of a type that is incompatible with the current op...">viskores::cont::ErrorBadType</a></code> if the stored array cannot be stored in the given array type. Use the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6f1d9c840e6654f38772a2620f0e597d" title="Determine if the contained array can be passed to the given array type.">CanConvert()</a></code> method to determine if the array can be returned with the given type. </p>

</div>
</div>
<a id="a78721563269cdf385652ee04780aae5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78721563269cdf385652ee04780aae5d">&#9670;&nbsp;</a></span>BaseAsArrayHandle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::BaseAsArrayHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f1d9c840e6654f38772a2620f0e597d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1d9c840e6654f38772a2620f0e597d">&#9670;&nbsp;</a></span>CanConvert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayHandleType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::UnknownArrayHandle::CanConvert</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the contained array can be passed to the given array type. </p>
<p>This method will return true if calling <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a5bd19cc2cefd571d9106340cd4ec85fb" title="Returns this array cast appropriately and stored in the given ArrayHandle type.">AsArrayHandle()</a></code> of the given type will succeed. The result is similar to <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#aa3947b5b80c3cd41d487c14efaec61e4" title="Returns true if this array matches the ArrayHandleType template argument.">IsType()</a></code>, and if <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#aa3947b5b80c3cd41d487c14efaec61e4" title="Returns true if this array matches the ArrayHandleType template argument.">IsType()</a></code> returns true, then this will return true. However, this method will also return true for other types such as an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleMultiplexer.html" title="An ArrayHandle that can behave like several other handles.">ArrayHandleMultiplexer</a></code> that can contain the array. </p>

</div>
</div>
<a id="a4814b53bff37eb59187dd374ce3ac2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4814b53bff37eb59187dd374ce3ac2f7">&#9670;&nbsp;</a></span>CastAndCallForTypes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeList , typename StorageTagList , typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::CastAndCallForTypes </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a functor using the underlying array type. </p>
<p><code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a4814b53bff37eb59187dd374ce3ac2f7" title="Call a functor using the underlying array type.">CastAndCallForTypes()</a></code> attempts to cast the held array to a specific value type, and then calls the given functor with the cast array. You must specify the <code>TypeList</code> and <code>StorageList</code> as template arguments.</p>
<p>After the functor argument you may add any number of arguments that will be passed to the functor after the converted <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>. </p>

</div>
</div>
<a id="a7bb6c8a9580516949494bc7e0ed64394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb6c8a9580516949494bc7e0ed64394">&#9670;&nbsp;</a></span>CastAndCallForTypesWithFloatFallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeList , typename StorageTagList , typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::CastAndCallForTypesWithFloatFallback </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a functor using the underlying array type with a float cast fallback. </p>
<p><code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a7bb6c8a9580516949494bc7e0ed64394" title="Call a functor using the underlying array type with a float cast fallback.">CastAndCallForTypesWithFloatFallback()</a></code> attempts to cast the held array to a specific value type, and then calls the given functor with the cast array. You must specify the <code>TypeList</code> and <code>StorageList</code> as template arguments.</p>
<p>After the functor argument you may add any number of arguments that will be passed to the functor after the converted <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>.</p>
<p>If the underlying array does not match any of the requested array types, the array is copied to a new <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html" title="Basic array storage for an array handle.">ArrayHandleBasic</a></code> with <code><a class="el" href="namespaceviskores.html#af6c632281522d90b3f50ad6396efa1d5" title="The floating point type to use when no other precision is specified.">viskores::FloatDefault</a></code> components in its value and attempts to cast to those types. </p>

</div>
</div>
<a id="a33f002c6ac04e515c1d4dc5012ed2c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f002c6ac04e515c1d4dc5012ed2c5d">&#9670;&nbsp;</a></span>CastAndCallWithExtractedArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::CastAndCallWithExtractedArray </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a functor on an array extracted from the components. </p>
<p><code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a33f002c6ac04e515c1d4dc5012ed2c5d" title="Call a functor on an array extracted from the components.">CastAndCallWithExtractedArray()</a></code> behaves similarly to <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a4814b53bff37eb59187dd374ce3ac2f7" title="Call a functor using the underlying array type.">CastAndCallForTypes()</a></code>. It converts the contained data to an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> and calls a functor with that <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> (and any number of optionally specified arguments).</p>
<p>The advantage of <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a33f002c6ac04e515c1d4dc5012ed2c5d" title="Call a functor on an array extracted from the components.">CastAndCallWithExtractedArray()</a></code> is that you do not need to specify any <code>TypeList</code> or <code>StorageList</code>. Instead, it internally uses <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a69817a433bae60cdf3649d96090971b8" title="Extract the array knowing only the component type of the array.">ExtractArrayFromComponents()</a></code> to work with most <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> types with only about 10 instances of the functor. In contrast, calling <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a4814b53bff37eb59187dd374ce3ac2f7" title="Call a functor using the underlying array type.">CastAndCallForTypes()</a></code> with, for example, <code>VISKORES_DEFAULT_TYPE_LIST</code> and <code>VISKORES_DEFAULT_STORAGE_LIST</code> results in many more instances of the functor but handling many fewer types of <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>.</p>
<p>There are, however, costs to using this method. Details of these costs are documented for the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a69817a433bae60cdf3649d96090971b8" title="Extract the array knowing only the component type of the array.">ExtractArrayFromComponents()</a></code> method, but briefly they are that <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code> types get flattened, the resulting array has a strange <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code>-like value type that has many limitations on its use, there is an overhead for retrieving each value from the array, and there is a potential that data must be copied. </p>

</div>
</div>
<a id="accbb666a783d2edbc1e7143b81446015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbb666a783d2edbc1e7143b81446015">&#9670;&nbsp;</a></span>CopyShallowIfPossible() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::CopyShallowIfPossible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts a shallow copy of an array or a deep copy if that is not possible. </p>
<p>This method takes an <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code> and attempts to perform a shallow copy. This shallow copy occurs if this object points to an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> of the same type or does not point to any <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> at all. If this is not possible, then the array is deep copied.</p>
<p>This method is roughly equivalent to the <code><a class="el" href="namespaceviskores_1_1cont.html#a10609ea9407d6237ca1dec8669a511f3" title="Copies from an unknown to a known array type.">viskores::cont::ArrayCopyShallowIfPossible()</a></code> function (defined in <code><a class="el" href="ArrayCopy_8h.html">viskores/cont/ArrayCopy.h</a></code>). This form allows you to copy into a type defined elsewhere (and hidden in the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code>) whereas <code><a class="el" href="namespaceviskores_1_1cont.html#a10609ea9407d6237ca1dec8669a511f3" title="Copies from an unknown to a known array type.">ArrayCopyShallowIfPossible()</a></code> must be copied into an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> of a known type. </p>

</div>
</div>
<a id="a8cb095150dde32160fdc99fa0b78858c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb095150dde32160fdc99fa0b78858c">&#9670;&nbsp;</a></span>CopyShallowIfPossible() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::CopyShallowIfPossible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts a shallow copy of an array or a deep copy if that is not possible. </p>
<p>This method takes an <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code> and attempts to perform a shallow copy. This shallow copy occurs if this object points to an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> of the same type. If the types are incompatible, then the array is deep copied.</p>
<p>If this object does not point to an existing <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>, this const version of <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#accbb666a783d2edbc1e7143b81446015" title="Attempts a shallow copy of an array or a deep copy if that is not possible.">CopyShallowIfPossible()</a></code> throws an exception.</p>
<p>This method is roughly equivalent to the <code><a class="el" href="namespaceviskores_1_1cont.html#a10609ea9407d6237ca1dec8669a511f3" title="Copies from an unknown to a known array type.">viskores::cont::ArrayCopyShallowIfPossible()</a></code> function (defined in <code><a class="el" href="ArrayCopy_8h.html">viskores/cont/ArrayCopy.h</a></code>). This form allows you to copy into a type defined elsewhere (and hidden in the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code>) whereas <code><a class="el" href="namespaceviskores_1_1cont.html#a10609ea9407d6237ca1dec8669a511f3" title="Copies from an unknown to a known array type.">ArrayCopyShallowIfPossible()</a></code> must be copied into an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> of a known type. </p>

</div>
</div>
<a id="ad08c75fc53700b44c81f088e5aa1ab37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08c75fc53700b44c81f088e5aa1ab37">&#9670;&nbsp;</a></span>DeepCopyFrom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::DeepCopyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep copies data from another <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code>. </p>
<p>This method takes an <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code> and deep copies data from it.</p>
<p>If this object does not point to an existing <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>, a new <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html" title="Basic array storage for an array handle.">ArrayHandleBasic</a></code> with the same value type of the <code>source</code> is created. </p>

</div>
</div>
<a id="a76d34a596c8b167f9c0ef7fa9e98bb4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d34a596c8b167f9c0ef7fa9e98bb4d">&#9670;&nbsp;</a></span>DeepCopyFrom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::DeepCopyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep copies data from another <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code>. </p>
<p>This method takes an <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code> and deep copies data from it.</p>
<p>If this object does not point to an existing <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>, this const version of <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#ad08c75fc53700b44c81f088e5aa1ab37" title="Deep copies data from another UnknownArrayHandle.">DeepCopyFrom()</a></code> throws an exception. </p>

</div>
</div>
<a id="a69817a433bae60cdf3649d96090971b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69817a433bae60cdf3649d96090971b8">&#9670;&nbsp;</a></span>ExtractArrayFromComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseComponentType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRecombineVec.html">viskores::cont::ArrayHandleRecombineVec</a>&lt;BaseComponentType&gt; viskores::cont::UnknownArrayHandle::ExtractArrayFromComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>allowCopy</em> = <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3">viskores::CopyFlag::On</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the array knowing only the component type of the array. </p>
<p>This method returns an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> that points to the data in the array. This method differs from <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a5bd19cc2cefd571d9106340cd4ec85fb" title="Returns this array cast appropriately and stored in the given ArrayHandle type.">AsArrayHandle()</a></code> because you do not need to know the exact <code>ValueType</code> and <code>StorageTag</code> of the array. Instead, you only need to know the base component type.</p>
<p><code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a69817a433bae60cdf3649d96090971b8" title="Extract the array knowing only the component type of the array.">ExtractArrayFromComponents()</a></code> works by calling the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a3e3b4ec6b0153f6f6e006b0882d63ba4" title="Extract a component of the array.">ExtractComponent()</a></code> method and then combining them together in a fancy <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>. This allows you to ignore the storage type of the underlying array as well as any <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code> structure of the value type. However, it also places some limitations on how the data can be pulled from the data.</p>
<p>First, you have to specify the base component type. This must match the data in the underlying array (as reported by <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a8a88cf3dd7e33eac5a6057c80c933512" title="Returns true if this array&#39;s ValueType has the provided base component type.">IsBaseComponentType()</a></code>).</p>
<p>Second, the array returned will have the <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code>s flattened. For example, if the underlying array has a <code>ValueType</code> of <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a>&lt;<a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a>&lt;T, 3&gt;, 3&gt;</code>, then this method will treat the data as if it was <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a>&lt;T, 9&gt;</code>. There is no way to get an array with <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a></code> of <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a></code> values.</p>
<p>Third, because the <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code> length of the values in the returned <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> must be determined at runtime, that can break many assumptions of using <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a></code> objects. The type is not going to be a <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a>&lt;T,N&gt;</code> type but rather an internal class that is intended to behave like that. The type should behave mostly like a <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a></code>, but will have some differences that can lead to unexpected behavior. For example, this <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code>-like object will not have a <code>NUM_COMPONENTS</code> constant static expression because it is not known at compile time. (Use the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a10147f1ed38a3773f7336148cf3f3e20" title="Returns the number of components for each value in the array.">GetNumberOfComponents()</a></code> method instead.) And for the same reason you will not be able to pass these objects to classes overloaded or templated on the <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code> type. Also, these <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code>-like objects cannot be created as new instances. Thus, you will likely have to iterate over all components rather than do operations on the whole <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code>.</p>
<p>Fourth, because <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a69817a433bae60cdf3649d96090971b8" title="Extract the array knowing only the component type of the array.">ExtractArrayFromComponents()</a></code> uses <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a3e3b4ec6b0153f6f6e006b0882d63ba4" title="Extract a component of the array.">ExtractComponent()</a></code> to pull data from the array (which in turn uses <code><a class="el" href="namespaceviskores_1_1cont.html#a2331ab862cd8447e45bb20f465412857" title="Pulls a component out of an ArrayHandle.">ArrayExtractComponent()</a></code>), there are some <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> types that will require copying data to a new array. This could be problematic in cases where you want to write to the array. To prevent data from being copied, set the optional <code>allowCopy</code> to <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a></code>. This will cause an exception to be thrown if the resulting array cannot reference the memory held in this <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code>.</p>
<p>Fifth, component arrays are extracted using <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleStride.html" title="An ArrayHandle that accesses a basic array with strides and offsets.">ArrayHandleStride</a></code> as the representation for each component. This array adds a slight overhead for each lookup as it performs the arithmetic for finding the index of each component.</p>
<p>This method is similar to <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a4025fd0aeb7713db9adc79bd85b3b266" title="Extract an array with any storage for a given value type.">ExtractArrayWithValueType()</a></code> except that the number of components need not be specified at compile time. However, because the components cannot be specified, you get many of the aforementioned limitations of the returned array.</p>
<p>Note that the template argument between this method and <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a4025fd0aeb7713db9adc79bd85b3b266" title="Extract an array with any storage for a given value type.">ExtractArrayWithValueType()</a></code> is different. For this method, provide the type of the base component. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> extractedArray = unknownArray.ExtractArrayFromComponents&lt;<a class="code" href="namespaceviskores.html#af6c632281522d90b3f50ad6396efa1d5">viskores::FloatDefault</a>&gt;();</div>
</div><!-- fragment --><p>However, to extract the same array with <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a4025fd0aeb7713db9adc79bd85b3b266" title="Extract an array with any storage for a given value type.">ExtractArrayWithValueType()</a></code>, you would use this full <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code> type. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> extractedArray = unknownArray.ExtractArrayWithValue&lt;<a class="code" href="classviskores_1_1Vec.html">viskores::Vec3f</a>&gt;();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4025fd0aeb7713db9adc79bd85b3b266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4025fd0aeb7713db9adc79bd85b3b266">&#9670;&nbsp;</a></span>ExtractArrayWithValueType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOAStride.html">viskores::cont::ArrayHandleSOAStride</a>&lt;ValueType&gt; viskores::cont::UnknownArrayHandle::ExtractArrayWithValueType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>allowCopy</em> = <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3">viskores::CopyFlag::On</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract an array with any storage for a given value type. </p>
<p>If you can determine the type of each value in the array, which can be verified with the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6815aa320fc676485ff64cd0d6a7efcf" title="Returns true if this array matches the ValueType template argument.">IsValueType()</a></code> method, then this method can extract that array into a flexible <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOAStride.html" title="An ArrayHandle that stores each component in a separate physical array with striding.">ArrayHandleSOAStride</a></code>. Most arrays can do so efficiently. You can check the <code>ExtractionIsInefficient()</code> method to check to see if a very inefficient copy would be required (and hence should not be used). Regardless, some arrays may be efficiently extracted but require a some amount of copying to match the <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOAStride.html" title="An ArrayHandle that stores each component in a separate physical array with striding.">ArrayHandleSOAStride</a></code> structure. This would mean that writing to the extracted array will not be reflected in the array held by this <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code>. To prevent such problems, you can use the <code>allowCopy</code> parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of each value in the array. This must match <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6815aa320fc676485ff64cd0d6a7efcf" title="Returns true if this array matches the ValueType template argument.">IsValueType()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allowCopy</td><td>Determines whether the data is allowed to be copied or it must reference the data from the original array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>viskores::cont::ArrayHandleSOSStride</code> containing the array. </dd></dl>

</div>
</div>
<a id="a3e3b4ec6b0153f6f6e006b0882d63ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3b4ec6b0153f6f6e006b0882d63ba4">&#9670;&nbsp;</a></span>ExtractComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseComponentType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandleStride.html">viskores::cont::ArrayHandleStride</a>&lt;BaseComponentType&gt; viskores::cont::UnknownArrayHandle::ExtractComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>componentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>allowCopy</em> = <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3">viskores::CopyFlag::On</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a component of the array. </p>
<p>This method returns an array that holds the data for a given flat component of the data. The <code>BaseComponentType</code> has to be specified and must match the contained array (i.e. the result of <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a8a88cf3dd7e33eac5a6057c80c933512" title="Returns true if this array&#39;s ValueType has the provided base component type.">IsBaseComponentType()</a></code> must succeed for the given type).</p>
<p>This method treats each value in the array as a flat <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a></code> even if it is a <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a></code> of <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code>s. For example, if the array actually holds values of type <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a>&lt;<a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a>&lt;T, 3&gt;, 2&gt;</code>, it is treated as if it holds a <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a>&lt;T, 6&gt;</code>. See <code><a class="el" href="classviskores_1_1VecFlat.html" title="Treat a Vec or Vec-like object as a flat Vec.">viskores::VecFlat</a></code> for details on how vectors are flattened.</p>
<p>The point of using <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a3e3b4ec6b0153f6f6e006b0882d63ba4" title="Extract a component of the array.">ExtractComponent()</a></code> over <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a5bd19cc2cefd571d9106340cd4ec85fb" title="Returns this array cast appropriately and stored in the given ArrayHandle type.">AsArrayHandle()</a></code> is that it drastically reduces the amount of types you have to try. Most of the time the base component type is one of the basic C types (i.e. <code>int</code>, <code>long</code>, <code>float</code>, etc.). You do not need to know what shape the containing <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a></code> is in, nor do you need to know the actual storage of the array.</p>
<p>Note that the type of the array returned is <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleStride.html" title="An ArrayHandle that accesses a basic array with strides and offsets.">ArrayHandleStride</a></code>. Using this type of array handle has a slight overhead over basic arrays like <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html" title="Basic array storage for an array handle.">ArrayHandleBasic</a></code> and <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleSOA.html" title="An ArrayHandle that for Vecs stores each component in a separate physical array.">ArrayHandleSOA</a></code>.</p>
<p>When extracting a component of an array, a shallow pointer to the data is returned whenever possible. However, in some circumstances it is impossible to conform the array. In these cases, the data are by default copied. If copying the data would cause problems (for example, you are writing into the array), you can select the optional <code>allowCopy</code> flag to <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a></code>. In this case, an exception will be thrown if the result cannot be represented by a shallow copy. </p>

</div>
</div>
<a id="a3031d78f00569e963a0011ee1d287483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3031d78f00569e963a0011ee1d287483">&#9670;&nbsp;</a></span>ExtractIsInefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::UnknownArrayHandle::ExtractIsInefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a call to <code>ExtractComponent</code> or a related method is inefficient. </p>
<p>It is usually efficient to extract components from array handles. However, some array handle types are inefficient. If the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code> holds an array with this type of storage, this method will return true. Note that if the array returns false, an array extract may still require a copy. The main consequence of the copy is that the extracted array will not point to the same space as the original array. </p>

</div>
</div>
<a id="a00f5cdbe0191c81c02f3c0ec5a69da8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f5cdbe0191c81c02f3c0ec5a69da8e">&#9670;&nbsp;</a></span>GetArrayTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::cont::UnknownArrayHandle::GetArrayTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of the underlying data type. </p>
<p>The returned string will be of the form <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a>&lt;T, S&gt;</code> rather than the name of an actual subclass. If no array is stored, an empty string is returned. </p>

</div>
</div>
<a id="a4aff2d8dacf2a7f49e6a9bfa72c8bb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aff2d8dacf2a7f49e6a9bfa72c8bb84">&#9670;&nbsp;</a></span>GetBaseComponentTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::cont::UnknownArrayHandle::GetBaseComponentTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the base component of the value type stored in the array. </p>
<p>Returns an empty string if no array is stored. </p>

</div>
</div>
<a id="a10147f1ed38a3773f7336148cf3f3e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10147f1ed38a3773f7336148cf3f3e20">&#9670;&nbsp;</a></span>GetNumberOfComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> viskores::cont::UnknownArrayHandle::GetNumberOfComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of components for each value in the array. </p>
<p>If the array holds <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a></code> objects, this will return the number of components in each value. If the array holds a basic C type (such as <code>float</code>), this will return 1. If the array holds <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code>-like objects that have the number of components that can vary at runtime, this method will return 0 (because there is no consistent answer). </p>

</div>
</div>
<a id="a2efb94483dfb57715fe36512a638e2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efb94483dfb57715fe36512a638e2a2">&#9670;&nbsp;</a></span>GetNumberOfComponentsFlat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> viskores::cont::UnknownArrayHandle::GetNumberOfComponentsFlat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of components for each value in the array. </p>
<p>If the array holds <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a></code> objects, this will return the total number of components in each value assuming the object is flattened out to one level of <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code> objects. If the array holds a basic C type (such as <code>float</code>), this will return 1. If the array holds a simple <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code> (such as <code><a class="el" href="namespaceviskores.html#abb422027052141614ec406112a05576d" title="Vec3f corresponds to a 3-dimensional vector of floating point values.">viskores::Vec3f</a></code>), this will return the number of components (in this case 3). If the array holds a hierarchy of <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code>s (such as <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a>&lt;<a class="el" href="namespaceviskores.html#abb422027052141614ec406112a05576d" title="Vec3f corresponds to a 3-dimensional vector of floating point values.">viskores::Vec3f</a>, 2&gt;</code>), this will return the total number of vecs (in this case 6).</p>
<p>If this object is holding an array where the number of components can be selected at runtime (for example, <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">viskores::cont::ArrayHandleRuntimeVec</a></code>), this method will still return the correct number of components. However, if each value in the array can be a <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code> of a different size (such as <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleGroupVecVariable.html" title="Fancy array handle that groups values into vectors of different sizes.">viskores::cont::ArrayHandleGroupVecVariable</a></code>), this method will return 0 (because there is no consistent answer). </p>

</div>
</div>
<a id="a7d04e21709749ed2608d3a8d3337f7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d04e21709749ed2608d3a8d3337f7ef">&#9670;&nbsp;</a></span>GetNumberOfValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> viskores::cont::UnknownArrayHandle::GetNumberOfValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of values in the array. </p>

</div>
</div>
<a id="acd3c0b554ba03205f2e4bb8571dac794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3c0b554ba03205f2e4bb8571dac794">&#9670;&nbsp;</a></span>GetStorageTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::cont::UnknownArrayHandle::GetStorageTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the storage tag for the array. </p>
<p>Returns an empty string if no array is stored. </p>

</div>
</div>
<a id="a6e4e9bda420b2c9542557dc63c908338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4e9bda420b2c9542557dc63c908338">&#9670;&nbsp;</a></span>GetValueTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::cont::UnknownArrayHandle::GetValueTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the value type stored in the array. </p>
<p>Returns an empty string if no array is stored. </p>

</div>
</div>
<a id="a8a88cf3dd7e33eac5a6057c80c933512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a88cf3dd7e33eac5a6057c80c933512">&#9670;&nbsp;</a></span>IsBaseComponentType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseComponentType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::UnknownArrayHandle::IsBaseComponentType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this array's <code>ValueType</code> has the provided base component type. </p>
<p>The base component type is the recursive component type of any <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code>-like object. So if the array's <code>ValueType</code> is <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a>&lt;<a class="el" href="namespaceviskores.html#afcbbc86b7129a2612785d217e77a633a" title="Base type to use for 32-bit floating-point numbers.">viskores::Float32</a>, 3&gt;</code>, then the base component type will be <code><a class="el" href="namespaceviskores.html#afcbbc86b7129a2612785d217e77a633a" title="Base type to use for 32-bit floating-point numbers.">viskores::Float32</a></code>. Likewise, if the <code>ValueType</code> is <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a>&lt;<a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a>&lt;<a class="el" href="namespaceviskores.html#afcbbc86b7129a2612785d217e77a633a" title="Base type to use for 32-bit floating-point numbers.">viskores::Float32</a>, 3&gt;, 2&gt;</code>, then the base component type is still <code><a class="el" href="namespaceviskores.html#afcbbc86b7129a2612785d217e77a633a" title="Base type to use for 32-bit floating-point numbers.">viskores::Float32</a></code>.</p>
<p>If the <code>ValueType</code> is not <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code>-like type, then the base component type is the same. So a <code>ValueType</code> of <code><a class="el" href="namespaceviskores.html#afcbbc86b7129a2612785d217e77a633a" title="Base type to use for 32-bit floating-point numbers.">viskores::Float32</a></code> has a base component type of <code><a class="el" href="namespaceviskores.html#afcbbc86b7129a2612785d217e77a633a" title="Base type to use for 32-bit floating-point numbers.">viskores::Float32</a></code>. </p>

</div>
</div>
<a id="a620c5cc6fba5c2f1d0f34d2fd7f599fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620c5cc6fba5c2f1d0f34d2fd7f599fd">&#9670;&nbsp;</a></span>IsBaseComponentTypeImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::UnknownArrayHandle::IsBaseComponentTypeImpl </td>
          <td>(</td>
          <td class="paramtype">const detail::UnknownAHComponentInfo &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6e9651b39c31109d02b68cd9e1e0b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e9651b39c31109d02b68cd9e1e0b40">&#9670;&nbsp;</a></span>IsStorageType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::UnknownArrayHandle::IsStorageType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this array matches the StorageType template argument. </p>

</div>
</div>
<a id="a637f66e393e256a0703951e6839ea3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637f66e393e256a0703951e6839ea3f3">&#9670;&nbsp;</a></span>IsStorageTypeImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::UnknownArrayHandle::IsStorageTypeImpl </td>
          <td>(</td>
          <td class="paramtype">std::type_index&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3947b5b80c3cd41d487c14efaec61e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3947b5b80c3cd41d487c14efaec61e4">&#9670;&nbsp;</a></span>IsType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayHandleType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::UnknownArrayHandle::IsType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this array matches the ArrayHandleType template argument. </p>
<p>Note that <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code> has some special handling for <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleCast.html" title="Cast the values of an array to the specified type, on demand.">ArrayHandleCast</a></code> and <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleMultiplexer.html" title="An ArrayHandle that can behave like several other handles.">ArrayHandleMultiplexer</a></code>. If you stored an array of one of these types into an <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code>, the type of the underlying array will change and <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#aa3947b5b80c3cd41d487c14efaec61e4" title="Returns true if this array matches the ArrayHandleType template argument.">IsType()</a></code> will fail. However, you can still get the array back out as that type using <code>AsArrayHandle</code>.</p>
<p>Use the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6f1d9c840e6654f38772a2620f0e597d" title="Determine if the contained array can be passed to the given array type.">CanConvert()</a></code> method instead to determine if the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code> contains an array that "matches" the array of a given type. Under most circumstances, you should prefer <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#a6f1d9c840e6654f38772a2620f0e597d" title="Determine if the contained array can be passed to the given array type.">CanConvert()</a></code> over <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html#aa3947b5b80c3cd41d487c14efaec61e4" title="Returns true if this array matches the ArrayHandleType template argument.">IsType()</a></code>. </p>

</div>
</div>
<a id="a8fead1f7f9c3554ac0d4d72c009bd872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fead1f7f9c3554ac0d4d72c009bd872">&#9670;&nbsp;</a></span>IsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::UnknownArrayHandle::IsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether an array is stored in this <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code>. </p>
<p>If the <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code> is constructed without an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>, it will not have an underlying type, and therefore the operations will be invalid. It is still possible to set this <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code> to an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>. </p>

</div>
</div>
<a id="a6815aa320fc676485ff64cd0d6a7efcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6815aa320fc676485ff64cd0d6a7efcf">&#9670;&nbsp;</a></span>IsValueType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::UnknownArrayHandle::IsValueType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this array matches the ValueType template argument. </p>

</div>
</div>
<a id="a31de41eed5afc0a7f86a5f9da0fe245e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31de41eed5afc0a7f86a5f9da0fe245e">&#9670;&nbsp;</a></span>IsValueTypeImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::UnknownArrayHandle::IsValueTypeImpl </td>
          <td>(</td>
          <td class="paramtype">std::type_index&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a0fd912a060b0190376dff095cf35e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0fd912a060b0190376dff095cf35e9">&#9670;&nbsp;</a></span>NewInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">UnknownArrayHandle</a> viskores::cont::UnknownArrayHandle::NewInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new array of the same type as this array. </p>
<p>This method creates a new array that is the same type as this one and returns a new <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code> for it. This method is convenient when creating output arrays that should be the same type as some input array. </p>

</div>
</div>
<a id="a43b9ed2310ddce8693905ac54b24f8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b9ed2310ddce8693905ac54b24f8eb">&#9670;&nbsp;</a></span>NewInstanceBasic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">UnknownArrayHandle</a> viskores::cont::UnknownArrayHandle::NewInstanceBasic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html" title="Basic array storage for an array handle.">ArrayHandleBasic</a></code> with the same <code>ValueType</code> as this array. </p>
<p>This method creates a new <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html" title="Basic array storage for an array handle.">ArrayHandleBasic</a></code> that has the same <code>ValueType</code> as the array held by this one and returns a new <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code> for it. This method is convenient when creating output arrays that should have the same types of values of the input, but the input might not be a writable array. </p>

</div>
</div>
<a id="a5e1ddf962dc8f5daca8f25ca92e402f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1ddf962dc8f5daca8f25ca92e402f5">&#9670;&nbsp;</a></span>NewInstanceFloatBasic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">UnknownArrayHandle</a> viskores::cont::UnknownArrayHandle::NewInstanceFloatBasic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html" title="Basic array storage for an array handle.">ArrayHandleBasic</a></code> with the base component of <code><a class="el" href="namespaceviskores.html#af6c632281522d90b3f50ad6396efa1d5" title="The floating point type to use when no other precision is specified.">viskores::FloatDefault</a></code> </p>
<p>This method creates a new <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html" title="Basic array storage for an array handle.">ArrayHandleBasic</a></code> that has a <code>ValueType</code> that is similar to the array held by this one except that the base component type is replaced with <code><a class="el" href="namespaceviskores.html#af6c632281522d90b3f50ad6396efa1d5" title="The floating point type to use when no other precision is specified.">viskores::FloatDefault</a></code>. For example, if the contained array has <code><a class="el" href="namespaceviskores.html#a551f985fe2e8dae6c5f03856ecfe0dae" title="Base type to use for 32-bit signed integer numbers.">viskores::Int32</a></code> value types, the returned array will have <code><a class="el" href="namespaceviskores.html#af6c632281522d90b3f50ad6396efa1d5" title="The floating point type to use when no other precision is specified.">viskores::FloatDefault</a></code> value types. If the contained array has <code><a class="el" href="namespaceviskores.html#a3cc22c6be2f1935ef8a64c21a1196528" title="Id3 corresponds to a 3-dimensional index for 3d arrays.">viskores::Id3</a></code> value types, the returned array will have <code><a class="el" href="namespaceviskores.html#abb422027052141614ec406112a05576d" title="Vec3f corresponds to a 3-dimensional vector of floating point values.">viskores::Vec3f</a></code> value types. If the contained array already has <code><a class="el" href="namespaceviskores.html#af6c632281522d90b3f50ad6396efa1d5" title="The floating point type to use when no other precision is specified.">viskores::FloatDefault</a></code> as the base component (e.g. <code><a class="el" href="namespaceviskores.html#af6c632281522d90b3f50ad6396efa1d5" title="The floating point type to use when no other precision is specified.">viskores::FloatDefault</a></code>, <code><a class="el" href="namespaceviskores.html#abb422027052141614ec406112a05576d" title="Vec3f corresponds to a 3-dimensional vector of floating point values.">viskores::Vec3f</a></code>, <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a>&lt;<a class="el" href="namespaceviskores.html#a5f3a3fa4b107c8b7a004c0e523926c34" title="Vec2f corresponds to a 2-dimensional vector of floating point values.">viskores::Vec2f</a>, 3&gt;</code>), then the value type will be preserved.</p>
<p>The created array is returned in a new <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">UnknownArrayHandle</a></code>.</p>
<p>This method is used to convert an array of an unknown type to an array of an almost known type. </p>

</div>
</div>
<a id="ad1a9407e114e1be4bb85898dec71d606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a9407e114e1be4bb85898dec71d606">&#9670;&nbsp;</a></span>PrintSummary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::PrintSummary </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a summary of the array's type, size, and contents. </p>

</div>
</div>
<a id="ae864caddac62f53717c934d2496f828e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae864caddac62f53717c934d2496f828e">&#9670;&nbsp;</a></span>ReleaseResources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::ReleaseResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases all resources in both the control and execution environments. </p>

</div>
</div>
<a id="a75c35618c67998aadd795763deea1221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c35618c67998aadd795763deea1221">&#9670;&nbsp;</a></span>ReleaseResourcesExecution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::UnknownArrayHandle::ReleaseResourcesExecution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases any resources being used in the execution environment (that are not being shared by the control environment). </p>

</div>
</div>
<a id="aac1d1daa5a6dcb5500d4e9e4b9eb6639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1d1daa5a6dcb5500d4e9e4b9eb6639">&#9670;&nbsp;</a></span>ResetTypes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NewValueTypeList , typename NewStorageTypeList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1UncertainArrayHandle.html">viskores::cont::UncertainArrayHandle</a>&lt; NewValueTypeList, NewStorageTypeList &gt; viskores::cont::UnknownArrayHandle::ResetTypes </td>
          <td>(</td>
          <td class="paramtype">NewValueTypeList&#160;</td>
          <td class="paramname"> = <code>NewValueTypeList{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NewStorageTypeList&#160;</td>
          <td class="paramname"> = <code>NewStorageTypeList{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns potential value and storage types. </p>
<p>Calling this method will return an <code><a class="el" href="classviskores_1_1cont_1_1UncertainArrayHandle.html" title="An ArrayHandle of an uncertain value type and storage.">UncertainArrayHandle</a></code> with the provided value and storage type lists. The returned object will hold the same <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>, but <code>CastAndCall</code>s on the returned object will be constrained to the given types. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a50959a4873ba99c2145ba797a0347ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50959a4873ba99c2145ba797a0347ac4">&#9670;&nbsp;</a></span>Container</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;detail::UnknownAHContainer&gt; viskores::cont::UnknownArrayHandle::Container</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="UnknownArrayHandle_8h_source.html">UnknownArrayHandle.h</a></li>
<li><a class="el" href="UncertainArrayHandle_8h_source.html">UncertainArrayHandle.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="anamespaceviskores_html_af6c632281522d90b3f50ad6396efa1d5"><div class="ttname"><a href="namespaceviskores.html#af6c632281522d90b3f50ad6396efa1d5">viskores::FloatDefault</a></div><div class="ttdeci">viskores::Float32 FloatDefault</div><div class="ttdoc">The floating point type to use when no other precision is specified.</div><div class="ttdef"><b>Definition:</b> Types.h:244</div></div>
<div class="ttc" id="aclassviskores_1_1Vec_html"><div class="ttname"><a href="classviskores_1_1Vec.html">viskores::Vec&lt; viskores::FloatDefault, 3 &gt;</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
