<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Viskores: viskores::filter::Filter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Viskores
   &#160;<span id="projectnumber">0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceviskores.html">viskores</a></li><li class="navelem"><a class="el" href="namespaceviskores_1_1filter.html">filter</a></li><li class="navelem"><a class="el" href="classviskores_1_1filter_1_1Filter.html">Filter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classviskores_1_1filter_1_1Filter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">viskores::filter::Filter Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for all filters.  
 <a href="classviskores_1_1filter_1_1Filter.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Filter_8h_source.html">Filter.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for viskores::filter::Filter:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classviskores_1_1filter_1_1Filter.png" usemap="#viskores::filter::Filter_map" alt=""/>
  <map id="viskores::filter::Filter_map" name="viskores::filter::Filter_map">
<area href="classviskores_1_1filter_1_1clean__grid_1_1CleanGrid.html" title="Clean a mesh to an unstructured grid." alt="viskores::filter::clean_grid::CleanGrid" shape="rect" coords="414,56,818,80"/>
<area href="classviskores_1_1filter_1_1connected__components_1_1CellSetConnectivity.html" title="Finds and labels groups of cells that are connected together through their topology." alt="viskores::filter::connected_components::CellSetConnectivity" shape="rect" coords="414,112,818,136"/>
<area href="classviskores_1_1filter_1_1connected__components_1_1ImageConnectivity.html" alt="viskores::filter::connected_components::ImageConnectivity" shape="rect" coords="414,168,818,192"/>
<area href="classviskores_1_1filter_1_1contour_1_1AbstractContour.html" title="Contour filter interface." alt="viskores::filter::contour::AbstractContour" shape="rect" coords="414,224,818,248"/>
<area href="classviskores_1_1filter_1_1contour_1_1ClipWithField.html" title="Clip a dataset using a field." alt="viskores::filter::contour::ClipWithField" shape="rect" coords="414,280,818,304"/>
<area href="classviskores_1_1filter_1_1contour_1_1ClipWithImplicitFunction.html" title="Clip a dataset using an implicit function." alt="viskores::filter::contour::ClipWithImplicitFunction" shape="rect" coords="414,336,818,360"/>
<area href="classviskores_1_1filter_1_1contour_1_1MIRFilter.html" title="Calculates and subdivides a mesh based on the material interface reconstruction algorithm." alt="viskores::filter::contour::MIRFilter" shape="rect" coords="414,392,818,416"/>
<area href="classviskores_1_1filter_1_1density__estimate_1_1ContinuousScatterPlot.html" title="Constructs the continuous scatterplot for two given scalar point fields of a mesh." alt="viskores::filter::density_estimate::ContinuousScatterPlot" shape="rect" coords="414,448,818,472"/>
<area href="classviskores_1_1filter_1_1density__estimate_1_1Entropy.html" title="Construct the entropy histogram of a given Field." alt="viskores::filter::density_estimate::Entropy" shape="rect" coords="414,504,818,528"/>
<area href="classviskores_1_1filter_1_1density__estimate_1_1Histogram.html" title="Construct the histogram of a given field." alt="viskores::filter::density_estimate::Histogram" shape="rect" coords="414,560,818,584"/>
<area href="classviskores_1_1filter_1_1density__estimate_1_1NDEntropy.html" title="Calculate the entropy of input N-Dims fields." alt="viskores::filter::density_estimate::NDEntropy" shape="rect" coords="414,616,818,640"/>
<area href="classviskores_1_1filter_1_1density__estimate_1_1NDHistogram.html" title="Generate a N-Dims histogram from input fields." alt="viskores::filter::density_estimate::NDHistogram" shape="rect" coords="414,672,818,696"/>
<area href="classviskores_1_1filter_1_1density__estimate_1_1ParticleDensityBase.html" alt="viskores::filter::density_estimate::ParticleDensityBase" shape="rect" coords="414,728,818,752"/>
<area href="classviskores_1_1filter_1_1density__estimate_1_1Statistics.html" title="Computes descriptive statistics of an input field." alt="viskores::filter::density_estimate::Statistics" shape="rect" coords="414,784,818,808"/>
<area href="classviskores_1_1filter_1_1entity__extraction_1_1ExternalFaces.html" title="Extract external faces of a geometry." alt="viskores::filter::entity_extraction::ExternalFaces" shape="rect" coords="414,840,818,864"/>
<area href="classviskores_1_1filter_1_1entity__extraction_1_1ExtractGeometry.html" title="Extract a subset of geometry based on an implicit function." alt="viskores::filter::entity_extraction::ExtractGeometry" shape="rect" coords="414,896,818,920"/>
<area href="classviskores_1_1filter_1_1entity__extraction_1_1ExtractPoints.html" title="Extract only points from a geometry using an implicit function." alt="viskores::filter::entity_extraction::ExtractPoints" shape="rect" coords="414,952,818,976"/>
<area href="classviskores_1_1filter_1_1entity__extraction_1_1ExtractStructured.html" title="Select a piece (e.g., volume of interest) and/or subsample structured points dataset." alt="viskores::filter::entity_extraction::ExtractStructured" shape="rect" coords="414,1008,818,1032"/>
<area href="classviskores_1_1filter_1_1entity__extraction_1_1GhostCellRemove.html" title="Removes cells marked as ghost cells." alt="viskores::filter::entity_extraction::GhostCellRemove" shape="rect" coords="414,1064,818,1088"/>
<area href="classviskores_1_1filter_1_1entity__extraction_1_1Mask.html" title="Subselect cells using a stride." alt="viskores::filter::entity_extraction::Mask" shape="rect" coords="414,1120,818,1144"/>
<area href="classviskores_1_1filter_1_1entity__extraction_1_1MaskPoints.html" title="Subselect points using a stride." alt="viskores::filter::entity_extraction::MaskPoints" shape="rect" coords="414,1176,818,1200"/>
<area href="classviskores_1_1filter_1_1entity__extraction_1_1Threshold.html" title="Extracts cells that satisfy a threshold criterion." alt="viskores::filter::entity_extraction::Threshold" shape="rect" coords="414,1232,818,1256"/>
<area href="classviskores_1_1filter_1_1entity__extraction_1_1ThresholdPoints.html" alt="viskores::filter::entity_extraction::ThresholdPoints" shape="rect" coords="414,1288,818,1312"/>
<area href="classviskores_1_1filter_1_1field__conversion_1_1CellAverage.html" title="Point to cell interpolation filter." alt="viskores::filter::field_conversion::CellAverage" shape="rect" coords="414,1344,818,1368"/>
<area href="classviskores_1_1filter_1_1field__conversion_1_1PointAverage.html" title="Cell to Point interpolation filter." alt="viskores::filter::field_conversion::PointAverage" shape="rect" coords="414,1400,818,1424"/>
<area href="classviskores_1_1filter_1_1field__transform_1_1CompositeVectors.html" title="Combine multiple scalar fields into a single vector field." alt="viskores::filter::field_transform::CompositeVectors" shape="rect" coords="414,1456,818,1480"/>
<area href="classviskores_1_1filter_1_1field__transform_1_1CylindricalCoordinateTransform.html" title="Transform coordinates between Cartesian and cylindrical." alt="viskores::filter::field_transform::CylindricalCoordinateTransform" shape="rect" coords="414,1512,818,1536"/>
<area href="classviskores_1_1filter_1_1field__transform_1_1FieldToColors.html" title="Convert an arbitrary field to an RGB or RGBA field." alt="viskores::filter::field_transform::FieldToColors" shape="rect" coords="414,1568,818,1592"/>
<area href="classviskores_1_1filter_1_1field__transform_1_1GenerateIds.html" title="Adds fields to a viskores::cont::DataSet that give the ids for the points and cells." alt="viskores::filter::field_transform::GenerateIds" shape="rect" coords="414,1624,818,1648"/>
<area href="classviskores_1_1filter_1_1field__transform_1_1LogValues.html" title="Adds field to a viskores::cont::DataSet that gives the log values for the user specified field." alt="viskores::filter::field_transform::LogValues" shape="rect" coords="414,1680,818,1704"/>
<area href="classviskores_1_1filter_1_1field__transform_1_1PointElevation.html" title="Generate a scalar field along a specified direction." alt="viskores::filter::field_transform::PointElevation" shape="rect" coords="414,1736,818,1760"/>
<area href="classviskores_1_1filter_1_1field__transform_1_1PointTransform.html" title="Perform affine transforms to point coordinates or vector fields." alt="viskores::filter::field_transform::PointTransform" shape="rect" coords="414,1792,818,1816"/>
<area href="classviskores_1_1filter_1_1field__transform_1_1SphericalCoordinateTransform.html" title="Transform coordinates between Cartesian and spherical." alt="viskores::filter::field_transform::SphericalCoordinateTransform" shape="rect" coords="414,1848,818,1872"/>
<area href="classviskores_1_1filter_1_1field__transform_1_1Warp.html" title="Modify points by moving points along scaled direction vectors." alt="viskores::filter::field_transform::Warp" shape="rect" coords="414,1904,818,1928"/>
<area href="classviskores_1_1filter_1_1FilterField.html" alt="viskores::filter::FilterField" shape="rect" coords="414,1960,818,1984"/>
<area href="classviskores_1_1filter_1_1flow_1_1FilterParticleAdvection.html" title="base class for advecting particles in a vector field." alt="viskores::filter::flow::FilterParticleAdvection" shape="rect" coords="414,2016,818,2040"/>
<area href="classviskores_1_1filter_1_1flow_1_1Lagrangian.html" alt="viskores::filter::flow::Lagrangian" shape="rect" coords="414,2072,818,2096"/>
<area href="classviskores_1_1filter_1_1flow_1_1LagrangianStructures.html" title="Compute the finite time Lyapunov exponent (FTLE) of a vector field." alt="viskores::filter::flow::LagrangianStructures" shape="rect" coords="414,2128,818,2152"/>
<area href="classviskores_1_1filter_1_1flow_1_1StreamSurface.html" title="Generate stream surfaces from a vector field." alt="viskores::filter::flow::StreamSurface" shape="rect" coords="414,2184,818,2208"/>
<area href="classviskores_1_1filter_1_1geometry__refinement_1_1ConvertToPointCloud.html" title="Convert a DataSet to a point cloud." alt="viskores::filter::geometry_refinement::ConvertToPointCloud" shape="rect" coords="414,2240,818,2264"/>
<area href="classviskores_1_1filter_1_1geometry__refinement_1_1Shrink.html" title="Shrink cells of an arbitrary dataset by a constant factor." alt="viskores::filter::geometry_refinement::Shrink" shape="rect" coords="414,2296,818,2320"/>
<area href="classviskores_1_1filter_1_1geometry__refinement_1_1SplitSharpEdges.html" title="Split sharp polygon mesh edges with a large feature angle between the adjacent cells." alt="viskores::filter::geometry_refinement::SplitSharpEdges" shape="rect" coords="414,2352,818,2376"/>
<area href="classviskores_1_1filter_1_1geometry__refinement_1_1Tetrahedralize.html" title="Convert all polyhedra of a viskores::cont::DataSet into tetrahedra." alt="viskores::filter::geometry_refinement::Tetrahedralize" shape="rect" coords="414,2408,818,2432"/>
<area href="classviskores_1_1filter_1_1geometry__refinement_1_1Triangulate.html" title="Convert all polygons of a viskores::cont::DataSet into triangles." alt="viskores::filter::geometry_refinement::Triangulate" shape="rect" coords="414,2464,818,2488"/>
<area href="classviskores_1_1filter_1_1geometry__refinement_1_1Tube.html" title="Generate a tube around each line and polyline." alt="viskores::filter::geometry_refinement::Tube" shape="rect" coords="414,2520,818,2544"/>
<area href="classviskores_1_1filter_1_1geometry__refinement_1_1VertexClustering.html" title="Reduce the number of triangles in a mesh." alt="viskores::filter::geometry_refinement::VertexClustering" shape="rect" coords="414,2576,818,2600"/>
<area href="classviskores_1_1filter_1_1image__processing_1_1ComputeMoments.html" alt="viskores::filter::image_processing::ComputeMoments" shape="rect" coords="414,2632,818,2656"/>
<area href="classviskores_1_1filter_1_1image__processing_1_1ImageDifference.html" title="Construct an ImageDifference of a given DataSet." alt="viskores::filter::image_processing::ImageDifference" shape="rect" coords="414,2688,818,2712"/>
<area href="classviskores_1_1filter_1_1image__processing_1_1ImageMedian.html" alt="viskores::filter::image_processing::ImageMedian" shape="rect" coords="414,2744,818,2768"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1CellMeasures.html" title="Compute the size measure of each cell in a dataset." alt="viskores::filter::mesh_info::CellMeasures" shape="rect" coords="414,2800,818,2824"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1GhostCellClassify.html" title="Determines which cells should be considered ghost cells in a structured data set." alt="viskores::filter::mesh_info::GhostCellClassify" shape="rect" coords="414,2856,818,2880"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQuality.html" title="Computes the quality of an unstructured cell-based mesh." alt="viskores::filter::mesh_info::MeshQuality" shape="rect" coords="414,2912,818,2936"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityArea.html" title="Compute the area of each cell." alt="viskores::filter::mesh_info::MeshQualityArea" shape="rect" coords="414,2968,818,2992"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityAspectGamma.html" title="For each cell, compute the normalized root-mean-square of the edge lengths." alt="viskores::filter::mesh_info::MeshQualityAspectGamma" shape="rect" coords="414,3024,818,3048"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityAspectRatio.html" title="Compute for each cell the ratio of its longest edge to its circumradius." alt="viskores::filter::mesh_info::MeshQualityAspectRatio" shape="rect" coords="414,3080,818,3104"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityCondition.html" title="Compute for each cell the condition number of the weighted Jacobian matrix." alt="viskores::filter::mesh_info::MeshQualityCondition" shape="rect" coords="414,3136,818,3160"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityDiagonalRatio.html" title="Compute for each cell the ratio of the maximum diagonal to the minimum diagonal." alt="viskores::filter::mesh_info::MeshQualityDiagonalRatio" shape="rect" coords="414,3192,818,3216"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityDimension.html" title="Compute for each cell a metric specifically designed for Sandia&#39;s Pronto code." alt="viskores::filter::mesh_info::MeshQualityDimension" shape="rect" coords="414,3248,818,3272"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityJacobian.html" title="Compute for each cell the minimum determinant of the Jacobian matrix, over corners and cell center." alt="viskores::filter::mesh_info::MeshQualityJacobian" shape="rect" coords="414,3304,818,3328"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityMaxAngle.html" title="Computes the maximum angle within each cell in degrees." alt="viskores::filter::mesh_info::MeshQualityMaxAngle" shape="rect" coords="414,3360,818,3384"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityMaxDiagonal.html" title="Computes the maximum diagonal length within each cell in degrees." alt="viskores::filter::mesh_info::MeshQualityMaxDiagonal" shape="rect" coords="414,3416,818,3440"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityMinAngle.html" title="Computes the minimum angle within each cell in degrees." alt="viskores::filter::mesh_info::MeshQualityMinAngle" shape="rect" coords="414,3472,818,3496"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityMinDiagonal.html" title="Computes the minimal diagonal length within each cell in degrees." alt="viskores::filter::mesh_info::MeshQualityMinDiagonal" shape="rect" coords="414,3528,818,3552"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityOddy.html" title="Compute for each cell the maximum deviation of a metric tensor from an identity matrix,..." alt="viskores::filter::mesh_info::MeshQualityOddy" shape="rect" coords="414,3584,818,3608"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityRelativeSizeSquared.html" title="Compute for each cell the ratio of area or volume to the mesh average." alt="viskores::filter::mesh_info::MeshQualityRelativeSizeSquared" shape="rect" coords="414,3640,818,3664"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityScaledJacobian.html" title="Compute for each cell a metric derived from the Jacobian matric with normalization involving edge len..." alt="viskores::filter::mesh_info::MeshQualityScaledJacobian" shape="rect" coords="414,3696,818,3720"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityShape.html" title="Compute a shape-based metric for each cell." alt="viskores::filter::mesh_info::MeshQualityShape" shape="rect" coords="414,3752,818,3776"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityShapeAndSize.html" title="Compute a metric for each cell based on the shape scaled by the cell size." alt="viskores::filter::mesh_info::MeshQualityShapeAndSize" shape="rect" coords="414,3808,818,3832"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityShear.html" title="Compute the shear of each cell." alt="viskores::filter::mesh_info::MeshQualityShear" shape="rect" coords="414,3864,818,3888"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualitySkew.html" title="Compute the skew of each cell." alt="viskores::filter::mesh_info::MeshQualitySkew" shape="rect" coords="414,3920,818,3944"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityStretch.html" title="Compute the stretch of each cell." alt="viskores::filter::mesh_info::MeshQualityStretch" shape="rect" coords="414,3976,818,4000"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityTaper.html" title="Compute the taper of each cell." alt="viskores::filter::mesh_info::MeshQualityTaper" shape="rect" coords="414,4032,818,4056"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityVolume.html" title="Compute the volume each cell." alt="viskores::filter::mesh_info::MeshQualityVolume" shape="rect" coords="414,4088,818,4112"/>
<area href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityWarpage.html" title="Compute the flatness of cells." alt="viskores::filter::mesh_info::MeshQualityWarpage" shape="rect" coords="414,4144,818,4168"/>
<area href="classviskores_1_1filter_1_1multi__block_1_1AmrArrays.html" title="Generate arrays describing the AMR structure in a partitioned data set." alt="viskores::filter::multi_block::AmrArrays" shape="rect" coords="414,4200,818,4224"/>
<area href="classviskores_1_1filter_1_1multi__block_1_1MergeDataSets.html" title="Merging multiple data sets into one data set." alt="viskores::filter::multi_block::MergeDataSets" shape="rect" coords="414,4256,818,4280"/>
<area href="classviskores_1_1filter_1_1resampling_1_1HistSampling.html" title="Adaptively sample points to preserve tail features." alt="viskores::filter::resampling::HistSampling" shape="rect" coords="414,4312,818,4336"/>
<area href="classviskores_1_1filter_1_1resampling_1_1Probe.html" title="Sample the fields of a data set at specified locations." alt="viskores::filter::resampling::Probe" shape="rect" coords="414,4368,818,4392"/>
<area href="classviskores_1_1filter_1_1scalar__topology_1_1ContourTreeAugmented.html" title="Construct the Contour Tree for a 2D or 3D regular mesh." alt="viskores::filter::scalar_topology::ContourTreeAugmented" shape="rect" coords="414,4424,818,4448"/>
<area href="classviskores_1_1filter_1_1scalar__topology_1_1ContourTreeMesh2D.html" title="Construct the ContourTree for a 2D Mesh." alt="viskores::filter::scalar_topology::ContourTreeMesh2D" shape="rect" coords="414,4480,818,4504"/>
<area href="classviskores_1_1filter_1_1scalar__topology_1_1ContourTreeMesh3D.html" title="Construct the ContourTree for a 3D Mesh." alt="viskores::filter::scalar_topology::ContourTreeMesh3D" shape="rect" coords="414,4536,818,4560"/>
<area href="classviskores_1_1filter_1_1scalar__topology_1_1ContourTreeUniformDistributed.html" title="Construct the Contour Tree for a 2D or 3D regular mesh." alt="viskores::filter::scalar_topology::ContourTreeUniformDistributed" shape="rect" coords="414,4592,818,4616"/>
<area href="classviskores_1_1filter_1_1scalar__topology_1_1DistributedBranchDecompositionFilter.html" title="Compute branch decompostion from distributed contour tree." alt="viskores::filter::scalar_topology::DistributedBranchDecompositionFilter" shape="rect" coords="414,4648,818,4672"/>
<area href="classviskores_1_1filter_1_1scalar__topology_1_1ExtractTopVolumeContoursFilter.html" title="Compute branch decompostion from distributed contour tree." alt="viskores::filter::scalar_topology::ExtractTopVolumeContoursFilter" shape="rect" coords="414,4704,818,4728"/>
<area href="classviskores_1_1filter_1_1scalar__topology_1_1SelectTopVolumeBranchesFilter.html" title="Compute branch decompostion from distributed contour tree." alt="viskores::filter::scalar_topology::SelectTopVolumeBranchesFilter" shape="rect" coords="414,4760,818,4784"/>
<area href="classviskores_1_1filter_1_1uncertainty_1_1ContourUncertainUniform.html" title="Visualize isosurface uncertainty for uniform distributed data." alt="viskores::filter::uncertainty::ContourUncertainUniform" shape="rect" coords="414,4816,818,4840"/>
<area href="classviskores_1_1filter_1_1uncertainty_1_1ContourUncertainUniformMonteCarlo.html" title="Visualize isosurface uncertainty using Monte Carlo approach for uniformly distributed data." alt="viskores::filter::uncertainty::ContourUncertainUniformMonteCarlo" shape="rect" coords="414,4872,818,4896"/>
<area href="classviskores_1_1filter_1_1vector__analysis_1_1CrossProduct.html" title="Compute the cross product of 3D vector fields." alt="viskores::filter::vector_analysis::CrossProduct" shape="rect" coords="414,4928,818,4952"/>
<area href="classviskores_1_1filter_1_1vector__analysis_1_1DotProduct.html" title="Compute the dot product of vector fields." alt="viskores::filter::vector_analysis::DotProduct" shape="rect" coords="414,4984,818,5008"/>
<area href="classviskores_1_1filter_1_1vector__analysis_1_1Gradient.html" title="A general filter for gradient estimation." alt="viskores::filter::vector_analysis::Gradient" shape="rect" coords="414,5040,818,5064"/>
<area href="classviskores_1_1filter_1_1vector__analysis_1_1SurfaceNormals.html" title="Computes normals for polygonal mesh." alt="viskores::filter::vector_analysis::SurfaceNormals" shape="rect" coords="414,5096,818,5120"/>
<area href="classviskores_1_1filter_1_1vector__analysis_1_1VectorMagnitude.html" title="Compute the magnitudes of a vector field." alt="viskores::filter::vector_analysis::VectorMagnitude" shape="rect" coords="414,5152,818,5176"/>
<area href="classviskores_1_1filter_1_1zfp_1_1ZFPCompressor1D.html" title="Compress a scalar field using ZFP." alt="viskores::filter::zfp::ZFPCompressor1D" shape="rect" coords="414,5208,818,5232"/>
<area href="classviskores_1_1filter_1_1zfp_1_1ZFPCompressor2D.html" title="Compress a scalar field using ZFP." alt="viskores::filter::zfp::ZFPCompressor2D" shape="rect" coords="414,5264,818,5288"/>
<area href="classviskores_1_1filter_1_1zfp_1_1ZFPCompressor3D.html" title="Compress a scalar field using ZFP." alt="viskores::filter::zfp::ZFPCompressor3D" shape="rect" coords="414,5320,818,5344"/>
<area href="classviskores_1_1filter_1_1zfp_1_1ZFPDecompressor1D.html" title="Decompress a scalar field using ZFP." alt="viskores::filter::zfp::ZFPDecompressor1D" shape="rect" coords="414,5376,818,5400"/>
<area href="classviskores_1_1filter_1_1zfp_1_1ZFPDecompressor2D.html" title="Decompress a scalar field using ZFP." alt="viskores::filter::zfp::ZFPDecompressor2D" shape="rect" coords="414,5432,818,5456"/>
<area href="classviskores_1_1filter_1_1zfp_1_1ZFPDecompressor3D.html" title="Decompress a scalar field using ZFP." alt="viskores::filter::zfp::ZFPDecompressor3D" shape="rect" coords="414,5488,818,5512"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1filter_1_1Filter_1_1ScalarToVec.html">ScalarToVec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa47718833f3adf8dd6df04a8e8bf8b93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#aa47718833f3adf8dd6df04a8e8bf8b93">Filter</a> ()</td></tr>
<tr class="separator:aa47718833f3adf8dd6df04a8e8bf8b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee64bae3e8c4d54fb5ca208871f8e2a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a2ee64bae3e8c4d54fb5ca208871f8e2a">~Filter</a> ()</td></tr>
<tr class="separator:a2ee64bae3e8c4d54fb5ca208871f8e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a860f4a72ae4b6330d1082cdbedfe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#aa9a860f4a72ae4b6330d1082cdbedfe1">Execute</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;input)</td></tr>
<tr class="memdesc:aa9a860f4a72ae4b6330d1082cdbedfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the filter on the input and produces a result dataset.  <a href="classviskores_1_1filter_1_1Filter.html#aa9a860f4a72ae4b6330d1082cdbedfe1">More...</a><br /></td></tr>
<tr class="separator:aa9a860f4a72ae4b6330d1082cdbedfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3680ceaaa184d3c4ef12bb5da7cc95d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#ab3680ceaaa184d3c4ef12bb5da7cc95d">Execute</a> (const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;input)</td></tr>
<tr class="memdesc:ab3680ceaaa184d3c4ef12bb5da7cc95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the filter on the input PartitionedDataSet and produces a result PartitionedDataSet.  <a href="classviskores_1_1filter_1_1Filter.html#ab3680ceaaa184d3c4ef12bb5da7cc95d">More...</a><br /></td></tr>
<tr class="separator:ab3680ceaaa184d3c4ef12bb5da7cc95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a4dc01cbe1230075cdad9467a1e9e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a40a4dc01cbe1230075cdad9467a1e9e5">SetFieldsToPass</a> (const <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html">viskores::filter::FieldSelection</a> &amp;fieldsToPass)</td></tr>
<tr class="memdesc:a40a4dc01cbe1230075cdad9467a1e9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify which fields get passed from input to output.  <a href="classviskores_1_1filter_1_1Filter.html#a40a4dc01cbe1230075cdad9467a1e9e5">More...</a><br /></td></tr>
<tr class="separator:a40a4dc01cbe1230075cdad9467a1e9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e744f004cb1e408b80e143da87b7732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a7e744f004cb1e408b80e143da87b7732">SetFieldsToPass</a> (<a class="el" href="classviskores_1_1filter_1_1FieldSelection.html">viskores::filter::FieldSelection</a> &amp;&amp;fieldsToPass)</td></tr>
<tr class="memdesc:a7e744f004cb1e408b80e143da87b7732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify which fields get passed from input to output.  <a href="classviskores_1_1filter_1_1Filter.html#a7e744f004cb1e408b80e143da87b7732">More...</a><br /></td></tr>
<tr class="separator:a7e744f004cb1e408b80e143da87b7732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9fcfbff4e50921c90f6a633216c8f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a4d9fcfbff4e50921c90f6a633216c8f3">SetFieldsToPass</a> (const <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html">viskores::filter::FieldSelection</a> &amp;fieldsToPass, <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7">viskores::filter::FieldSelection::Mode</a> mode)</td></tr>
<tr class="separator:a4d9fcfbff4e50921c90f6a633216c8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540ebc458e434da096a71471e22eb2fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a540ebc458e434da096a71471e22eb2fc">SetFieldsToPass</a> (std::initializer_list&lt; std::string &gt; fields, <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7">viskores::filter::FieldSelection::Mode</a> mode=<a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7ae0626222614bdee31951d84c64e5e9ff">viskores::filter::FieldSelection::Mode::Select</a>)</td></tr>
<tr class="memdesc:a540ebc458e434da096a71471e22eb2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify which fields get passed from input to output.  <a href="classviskores_1_1filter_1_1Filter.html#a540ebc458e434da096a71471e22eb2fc">More...</a><br /></td></tr>
<tr class="separator:a540ebc458e434da096a71471e22eb2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66de3cad6dac78a51571d061895547ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a66de3cad6dac78a51571d061895547ec">SetFieldsToPass</a> (std::initializer_list&lt; std::pair&lt; std::string, <a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a> &gt;&gt; fields, <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7">viskores::filter::FieldSelection::Mode</a> mode=<a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7ae0626222614bdee31951d84c64e5e9ff">viskores::filter::FieldSelection::Mode::Select</a>)</td></tr>
<tr class="memdesc:a66de3cad6dac78a51571d061895547ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify which fields get passed from input to output.  <a href="classviskores_1_1filter_1_1Filter.html#a66de3cad6dac78a51571d061895547ec">More...</a><br /></td></tr>
<tr class="separator:a66de3cad6dac78a51571d061895547ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730f729313e02e0764d75c889b0cec9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a730f729313e02e0764d75c889b0cec9e">SetFieldsToPass</a> (const std::string &amp;fieldname, <a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a> association, <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7">viskores::filter::FieldSelection::Mode</a> mode=<a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7ae0626222614bdee31951d84c64e5e9ff">viskores::filter::FieldSelection::Mode::Select</a>)</td></tr>
<tr class="memdesc:a730f729313e02e0764d75c889b0cec9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify which fields get passed from input to output.  <a href="classviskores_1_1filter_1_1Filter.html#a730f729313e02e0764d75c889b0cec9e">More...</a><br /></td></tr>
<tr class="separator:a730f729313e02e0764d75c889b0cec9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9891d36816b7461e022e3301d8eac56c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a9891d36816b7461e022e3301d8eac56c">SetFieldsToPass</a> (const std::string &amp;fieldname, <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7">viskores::filter::FieldSelection::Mode</a> mode)</td></tr>
<tr class="memdesc:a9891d36816b7461e022e3301d8eac56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify which fields get passed from input to output.  <a href="classviskores_1_1filter_1_1Filter.html#a9891d36816b7461e022e3301d8eac56c">More...</a><br /></td></tr>
<tr class="separator:a9891d36816b7461e022e3301d8eac56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e13f0b1257deb056d46979ef3e9e1f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html">viskores::filter::FieldSelection</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a60e13f0b1257deb056d46979ef3e9e1f">GetFieldsToPass</a> () const</td></tr>
<tr class="memdesc:a60e13f0b1257deb056d46979ef3e9e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify which fields get passed from input to output.  <a href="classviskores_1_1filter_1_1Filter.html#a60e13f0b1257deb056d46979ef3e9e1f">More...</a><br /></td></tr>
<tr class="separator:a60e13f0b1257deb056d46979ef3e9e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aef83ae99b2dc7d8c0bdd549f947da3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1filter_1_1FieldSelection.html">viskores::filter::FieldSelection</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a0aef83ae99b2dc7d8c0bdd549f947da3">GetFieldsToPass</a> ()</td></tr>
<tr class="memdesc:a0aef83ae99b2dc7d8c0bdd549f947da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify which fields get passed from input to output.  <a href="classviskores_1_1filter_1_1Filter.html#a0aef83ae99b2dc7d8c0bdd549f947da3">More...</a><br /></td></tr>
<tr class="separator:a0aef83ae99b2dc7d8c0bdd549f947da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aeebaa3e10c7649f78d89ca3a56cd19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a6aeebaa3e10c7649f78d89ca3a56cd19">SetPassCoordinateSystems</a> (bool flag)</td></tr>
<tr class="memdesc:a6aeebaa3e10c7649f78d89ca3a56cd19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether to always pass coordinate systems.  <a href="classviskores_1_1filter_1_1Filter.html#a6aeebaa3e10c7649f78d89ca3a56cd19">More...</a><br /></td></tr>
<tr class="separator:a6aeebaa3e10c7649f78d89ca3a56cd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1fa9dcbd16d3e51a6001210be0c431"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a2a1fa9dcbd16d3e51a6001210be0c431">GetPassCoordinateSystems</a> () const</td></tr>
<tr class="memdesc:a2a1fa9dcbd16d3e51a6001210be0c431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether to always pass coordinate systems.  <a href="classviskores_1_1filter_1_1Filter.html#a2a1fa9dcbd16d3e51a6001210be0c431">More...</a><br /></td></tr>
<tr class="separator:a2a1fa9dcbd16d3e51a6001210be0c431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337a15fc9298d0edaae5dc7b9502d27e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a337a15fc9298d0edaae5dc7b9502d27e">SetOutputFieldName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a337a15fc9298d0edaae5dc7b9502d27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the name of the output field generated.  <a href="classviskores_1_1filter_1_1Filter.html#a337a15fc9298d0edaae5dc7b9502d27e">More...</a><br /></td></tr>
<tr class="separator:a337a15fc9298d0edaae5dc7b9502d27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86f7468798f9483610ddd4c5135bdd4"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#ab86f7468798f9483610ddd4c5135bdd4">GetOutputFieldName</a> () const</td></tr>
<tr class="memdesc:ab86f7468798f9483610ddd4c5135bdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the name of the output field generated.  <a href="classviskores_1_1filter_1_1Filter.html#ab86f7468798f9483610ddd4c5135bdd4">More...</a><br /></td></tr>
<tr class="separator:ab86f7468798f9483610ddd4c5135bdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a3b66fc0d7bd5a60b8ee17606f780e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a80a3b66fc0d7bd5a60b8ee17606f780e">SetActiveField</a> (const std::string &amp;name, <a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a> association=<a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bdaed36a1ef76a59ee3f15180e0441188ad">viskores::cont::Field::Association::Any</a>)</td></tr>
<tr class="memdesc:a80a3b66fc0d7bd5a60b8ee17606f780e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a field to operate on.  <a href="classviskores_1_1filter_1_1Filter.html#a80a3b66fc0d7bd5a60b8ee17606f780e">More...</a><br /></td></tr>
<tr class="separator:a80a3b66fc0d7bd5a60b8ee17606f780e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45f9d93d75896829c6f661cc104b639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#ac45f9d93d75896829c6f661cc104b639">SetActiveField</a> (<a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> index, const std::string &amp;name, <a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a> association=<a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bdaed36a1ef76a59ee3f15180e0441188ad">viskores::cont::Field::Association::Any</a>)</td></tr>
<tr class="memdesc:ac45f9d93d75896829c6f661cc104b639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a field to operate on.  <a href="classviskores_1_1filter_1_1Filter.html#ac45f9d93d75896829c6f661cc104b639">More...</a><br /></td></tr>
<tr class="separator:ac45f9d93d75896829c6f661cc104b639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1eb94b67dec54c5455b915b9fa262a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a4d1eb94b67dec54c5455b915b9fa262a">GetActiveFieldName</a> (<a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> index=0) const</td></tr>
<tr class="memdesc:a4d1eb94b67dec54c5455b915b9fa262a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a field to operate on.  <a href="classviskores_1_1filter_1_1Filter.html#a4d1eb94b67dec54c5455b915b9fa262a">More...</a><br /></td></tr>
<tr class="separator:a4d1eb94b67dec54c5455b915b9fa262a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bfd1ea8b44574b3263ab662514f6f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#ac3bfd1ea8b44574b3263ab662514f6f5">GetActiveFieldAssociation</a> (<a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> index=0) const</td></tr>
<tr class="memdesc:ac3bfd1ea8b44574b3263ab662514f6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a field to operate on.  <a href="classviskores_1_1filter_1_1Filter.html#ac3bfd1ea8b44574b3263ab662514f6f5">More...</a><br /></td></tr>
<tr class="separator:ac3bfd1ea8b44574b3263ab662514f6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e349933e2462b9ff713ed5be03498f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a36e349933e2462b9ff713ed5be03498f">SetActiveCoordinateSystem</a> (<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> coord_idx)</td></tr>
<tr class="memdesc:a36e349933e2462b9ff713ed5be03498f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the coordinate system index to make active to use when processing the input <code><a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">viskores::cont::DataSet</a></code>.  <a href="classviskores_1_1filter_1_1Filter.html#a36e349933e2462b9ff713ed5be03498f">More...</a><br /></td></tr>
<tr class="separator:a36e349933e2462b9ff713ed5be03498f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0368295acf4a60c5e4183185db3743"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#aeb0368295acf4a60c5e4183185db3743">SetActiveCoordinateSystem</a> (<a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> index, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> coord_idx)</td></tr>
<tr class="memdesc:aeb0368295acf4a60c5e4183185db3743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the coordinate system index to make active to use when processing the input <code><a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">viskores::cont::DataSet</a></code>.  <a href="classviskores_1_1filter_1_1Filter.html#aeb0368295acf4a60c5e4183185db3743">More...</a><br /></td></tr>
<tr class="separator:aeb0368295acf4a60c5e4183185db3743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274ba00026b4ed9f577dd34e2c440d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a274ba00026b4ed9f577dd34e2c440d1e">GetActiveCoordinateSystemIndex</a> (<a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> index=0) const</td></tr>
<tr class="memdesc:a274ba00026b4ed9f577dd34e2c440d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the coordinate system index to make active to use when processing the input <code><a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">viskores::cont::DataSet</a></code>.  <a href="classviskores_1_1filter_1_1Filter.html#a274ba00026b4ed9f577dd34e2c440d1e">More...</a><br /></td></tr>
<tr class="separator:a274ba00026b4ed9f577dd34e2c440d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ecffbe06ddfeef4b05d126795474cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a95ecffbe06ddfeef4b05d126795474cd">SetUseCoordinateSystemAsField</a> (bool val)</td></tr>
<tr class="memdesc:a95ecffbe06ddfeef4b05d126795474cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to use point coordinates as the input field.  <a href="classviskores_1_1filter_1_1Filter.html#a95ecffbe06ddfeef4b05d126795474cd">More...</a><br /></td></tr>
<tr class="separator:a95ecffbe06ddfeef4b05d126795474cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e82e0de463f8ffb4ce758858a60849c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a0e82e0de463f8ffb4ce758858a60849c">SetUseCoordinateSystemAsField</a> (<a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> index, bool val)</td></tr>
<tr class="memdesc:a0e82e0de463f8ffb4ce758858a60849c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to use point coordinates as the input field.  <a href="classviskores_1_1filter_1_1Filter.html#a0e82e0de463f8ffb4ce758858a60849c">More...</a><br /></td></tr>
<tr class="separator:a0e82e0de463f8ffb4ce758858a60849c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d47bb1b58cf07941c904ec5b3f43d35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a5d47bb1b58cf07941c904ec5b3f43d35">GetUseCoordinateSystemAsField</a> (<a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> index=0) const</td></tr>
<tr class="memdesc:a5d47bb1b58cf07941c904ec5b3f43d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to use point coordinates as the input field.  <a href="classviskores_1_1filter_1_1Filter.html#a5d47bb1b58cf07941c904ec5b3f43d35">More...</a><br /></td></tr>
<tr class="separator:a5d47bb1b58cf07941c904ec5b3f43d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4582630898b66bf518dab0a7c9ca8eb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a4582630898b66bf518dab0a7c9ca8eb3">GetNumberOfActiveFields</a> () const</td></tr>
<tr class="memdesc:a4582630898b66bf518dab0a7c9ca8eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of active fields currently set.  <a href="classviskores_1_1filter_1_1Filter.html#a4582630898b66bf518dab0a7c9ca8eb3">More...</a><br /></td></tr>
<tr class="separator:a4582630898b66bf518dab0a7c9ca8eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83357015ad2df06b7ab181a75c3662b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#af83357015ad2df06b7ab181a75c3662b">CanThread</a> () const</td></tr>
<tr class="memdesc:af83357015ad2df06b7ab181a75c3662b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the filter can execute on partitions in concurrent threads.  <a href="classviskores_1_1filter_1_1Filter.html#af83357015ad2df06b7ab181a75c3662b">More...</a><br /></td></tr>
<tr class="separator:af83357015ad2df06b7ab181a75c3662b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbf6ee581d811552650786200f550bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#adbbf6ee581d811552650786200f550bd">SetThreadsPerCPU</a> (<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numThreads)</td></tr>
<tr class="separator:adbbf6ee581d811552650786200f550bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6202c185e6773d7450b12605c7da7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#add6202c185e6773d7450b12605c7da7c">SetThreadsPerGPU</a> (<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numThreads)</td></tr>
<tr class="separator:add6202c185e6773d7450b12605c7da7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c180327e6837ccfec582fa8a5abcbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a81c180327e6837ccfec582fa8a5abcbd">GetThreadsPerCPU</a> () const</td></tr>
<tr class="separator:a81c180327e6837ccfec582fa8a5abcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429ef4ca7f45a4ed42ed25dc2564c310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a429ef4ca7f45a4ed42ed25dc2564c310">GetThreadsPerGPU</a> () const</td></tr>
<tr class="separator:a429ef4ca7f45a4ed42ed25dc2564c310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e39eecdfc999f4cfc28b4784d72f193"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a0e39eecdfc999f4cfc28b4784d72f193">GetRunMultiThreadedFilter</a> () const</td></tr>
<tr class="separator:a0e39eecdfc999f4cfc28b4784d72f193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab0ac78734df9709e8af0025ed21fbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a0ab0ac78734df9709e8af0025ed21fbd">SetRunMultiThreadedFilter</a> (bool val)</td></tr>
<tr class="separator:a0ab0ac78734df9709e8af0025ed21fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036a2822a21ac92b1c0266a9277bffa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a036a2822a21ac92b1c0266a9277bffa0">SetInvoker</a> (<a class="el" href="structviskores_1_1cont_1_1Invoker.html">viskores::cont::Invoker</a> inv)</td></tr>
<tr class="memdesc:a036a2822a21ac92b1c0266a9277bffa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the <a class="el" href="structviskores_1_1cont_1_1Invoker.html" title="Allows launching any worklet without a dispatcher.">viskores::cont::Invoker</a> to be used to execute worklets by this filter instance.  <a href="classviskores_1_1filter_1_1Filter.html#a036a2822a21ac92b1c0266a9277bffa0">More...</a><br /></td></tr>
<tr class="separator:a036a2822a21ac92b1c0266a9277bffa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6f56120132ad471ae092feedad608118"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a6f56120132ad471ae092feedad608118">CreateResult</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;inDataSet) const</td></tr>
<tr class="memdesc:a6f56120132ad471ae092feedad608118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the output data set for <code>DoExecute</code>.  <a href="classviskores_1_1filter_1_1Filter.html#a6f56120132ad471ae092feedad608118">More...</a><br /></td></tr>
<tr class="separator:a6f56120132ad471ae092feedad608118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d9cd432e624c6995d88cb379f33bd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a51d9cd432e624c6995d88cb379f33bd8">CreateResultField</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;inDataSet, const <a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> &amp;resultField) const</td></tr>
<tr class="memdesc:a51d9cd432e624c6995d88cb379f33bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the output data set for <code>DoExecute</code>  <a href="classviskores_1_1filter_1_1Filter.html#a51d9cd432e624c6995d88cb379f33bd8">More...</a><br /></td></tr>
<tr class="separator:a51d9cd432e624c6995d88cb379f33bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab352d4c1439c22e40e88658ea41d6322"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#ab352d4c1439c22e40e88658ea41d6322">CreateResultField</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;inDataSet, const std::string &amp;resultFieldName, <a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a> resultFieldAssociation, const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;resultFieldArray) const</td></tr>
<tr class="memdesc:ab352d4c1439c22e40e88658ea41d6322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the output data set for <code>DoExecute</code>  <a href="classviskores_1_1filter_1_1Filter.html#ab352d4c1439c22e40e88658ea41d6322">More...</a><br /></td></tr>
<tr class="separator:ab352d4c1439c22e40e88658ea41d6322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe86079ed8dd3d5a6665b0c118885d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#abe86079ed8dd3d5a6665b0c118885d54">CreateResultFieldPoint</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;inDataSet, const std::string &amp;resultFieldName, const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;resultFieldArray) const</td></tr>
<tr class="memdesc:abe86079ed8dd3d5a6665b0c118885d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the output data set for <code>DoExecute</code>  <a href="classviskores_1_1filter_1_1Filter.html#abe86079ed8dd3d5a6665b0c118885d54">More...</a><br /></td></tr>
<tr class="separator:abe86079ed8dd3d5a6665b0c118885d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527b9d9cb733738b5bf1afa1120c904a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a527b9d9cb733738b5bf1afa1120c904a">CreateResultFieldCell</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;inDataSet, const std::string &amp;resultFieldName, const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;resultFieldArray) const</td></tr>
<tr class="memdesc:a527b9d9cb733738b5bf1afa1120c904a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the output data set for <code>DoExecute</code>  <a href="classviskores_1_1filter_1_1Filter.html#a527b9d9cb733738b5bf1afa1120c904a">More...</a><br /></td></tr>
<tr class="separator:a527b9d9cb733738b5bf1afa1120c904a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838ec247e6d25281eecffe26374961a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a838ec247e6d25281eecffe26374961a3">CreateResult</a> (const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;input, const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;resultPartitions) const</td></tr>
<tr class="memdesc:a838ec247e6d25281eecffe26374961a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the output data set for <code>DoExecute</code>.  <a href="classviskores_1_1filter_1_1Filter.html#a838ec247e6d25281eecffe26374961a3">More...</a><br /></td></tr>
<tr class="separator:a838ec247e6d25281eecffe26374961a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f45fbc5edc7a0cb9a99fc8af4e5d369"><td class="memTemplParams" colspan="2">template&lt;typename FieldMapper &gt; </td></tr>
<tr class="memitem:a3f45fbc5edc7a0cb9a99fc8af4e5d369"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a3f45fbc5edc7a0cb9a99fc8af4e5d369">CreateResult</a> (const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;input, const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;resultPartitions, FieldMapper &amp;&amp;fieldMapper) const</td></tr>
<tr class="memdesc:a3f45fbc5edc7a0cb9a99fc8af4e5d369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the output data set for <code>DoExecute</code>.  <a href="classviskores_1_1filter_1_1Filter.html#a3f45fbc5edc7a0cb9a99fc8af4e5d369">More...</a><br /></td></tr>
<tr class="separator:a3f45fbc5edc7a0cb9a99fc8af4e5d369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0292134ef6d642d852fc5e17f46f280c"><td class="memTemplParams" colspan="2">template&lt;typename FieldMapper &gt; </td></tr>
<tr class="memitem:a0292134ef6d642d852fc5e17f46f280c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a0292134ef6d642d852fc5e17f46f280c">CreateResult</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;inDataSet, const <a class="el" href="classviskores_1_1cont_1_1UnknownCellSet.html">viskores::cont::UnknownCellSet</a> &amp;resultCellSet, FieldMapper &amp;&amp;fieldMapper) const</td></tr>
<tr class="memdesc:a0292134ef6d642d852fc5e17f46f280c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the output data set for <code>DoExecute</code>.  <a href="classviskores_1_1filter_1_1Filter.html#a0292134ef6d642d852fc5e17f46f280c">More...</a><br /></td></tr>
<tr class="separator:a0292134ef6d642d852fc5e17f46f280c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a3adeb07b3ffd9cef4ebb562f0ef5c"><td class="memTemplParams" colspan="2">template&lt;typename FieldMapper &gt; </td></tr>
<tr class="memitem:a09a3adeb07b3ffd9cef4ebb562f0ef5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a09a3adeb07b3ffd9cef4ebb562f0ef5c">CreateResultCoordinateSystem</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;inDataSet, const <a class="el" href="classviskores_1_1cont_1_1UnknownCellSet.html">viskores::cont::UnknownCellSet</a> &amp;resultCellSet, const <a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html">viskores::cont::CoordinateSystem</a> &amp;resultCoordSystem, FieldMapper &amp;&amp;fieldMapper) const</td></tr>
<tr class="memdesc:a09a3adeb07b3ffd9cef4ebb562f0ef5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the output data set for <code>DoExecute</code>.  <a href="classviskores_1_1filter_1_1Filter.html#a09a3adeb07b3ffd9cef4ebb562f0ef5c">More...</a><br /></td></tr>
<tr class="separator:a09a3adeb07b3ffd9cef4ebb562f0ef5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac166dc462d825cffb35701017d912099"><td class="memTemplParams" colspan="2">template&lt;typename FieldMapper &gt; </td></tr>
<tr class="memitem:ac166dc462d825cffb35701017d912099"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#ac166dc462d825cffb35701017d912099">CreateResultCoordinateSystem</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;inDataSet, const <a class="el" href="classviskores_1_1cont_1_1UnknownCellSet.html">viskores::cont::UnknownCellSet</a> &amp;resultCellSet, const std::string &amp;coordsName, const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;coordsData, FieldMapper &amp;&amp;fieldMapper) const</td></tr>
<tr class="memdesc:ac166dc462d825cffb35701017d912099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the output data set for <code>DoExecute</code>.  <a href="classviskores_1_1filter_1_1Filter.html#ac166dc462d825cffb35701017d912099">More...</a><br /></td></tr>
<tr class="separator:ac166dc462d825cffb35701017d912099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01866782b46fb387b11192cdbefa1ca6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a01866782b46fb387b11192cdbefa1ca6">GetFieldFromDataSet</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;input) const</td></tr>
<tr class="memdesc:a01866782b46fb387b11192cdbefa1ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an input field from a <code><a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">viskores::cont::DataSet</a></code> object.  <a href="classviskores_1_1filter_1_1Filter.html#a01866782b46fb387b11192cdbefa1ca6">More...</a><br /></td></tr>
<tr class="separator:a01866782b46fb387b11192cdbefa1ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08454a8acc7224b8ee4f7481a390c23a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a08454a8acc7224b8ee4f7481a390c23a">GetFieldFromDataSet</a> (<a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> index, const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;input) const</td></tr>
<tr class="memdesc:a08454a8acc7224b8ee4f7481a390c23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an input field from a <code><a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">viskores::cont::DataSet</a></code> object.  <a href="classviskores_1_1filter_1_1Filter.html#a08454a8acc7224b8ee4f7481a390c23a">More...</a><br /></td></tr>
<tr class="separator:a08454a8acc7224b8ee4f7481a390c23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed1cf9cb66af903ab03e4157f3032af"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a9ed1cf9cb66af903ab03e4157f3032af">DoExecute</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;inData)=0</td></tr>
<tr class="separator:a9ed1cf9cb66af903ab03e4157f3032af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352e61e711e070ef54291e970bf145dc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a352e61e711e070ef54291e970bf145dc">DoExecutePartitions</a> (const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;inData)</td></tr>
<tr class="separator:a352e61e711e070ef54291e970bf145dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc8781cad13719eddfd02b84480833c"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a5fc8781cad13719eddfd02b84480833c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a5fc8781cad13719eddfd02b84480833c">CastAndCallScalarField</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;fieldArray, Functor &amp;&amp;functor, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a5fc8781cad13719eddfd02b84480833c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to get the array from a filter's input scalar field.  <a href="classviskores_1_1filter_1_1Filter.html#a5fc8781cad13719eddfd02b84480833c">More...</a><br /></td></tr>
<tr class="separator:a5fc8781cad13719eddfd02b84480833c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b5bee38aeb26a87641c9ecef4ff510"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a23b5bee38aeb26a87641c9ecef4ff510"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a23b5bee38aeb26a87641c9ecef4ff510">CastAndCallScalarField</a> (const <a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> &amp;field, Functor &amp;&amp;functor, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a23b5bee38aeb26a87641c9ecef4ff510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to get the array from a filter's input scalar field.  <a href="classviskores_1_1filter_1_1Filter.html#a23b5bee38aeb26a87641c9ecef4ff510">More...</a><br /></td></tr>
<tr class="separator:a23b5bee38aeb26a87641c9ecef4ff510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e2041e42cad019f261c2f53d2ae2b6"><td class="memTemplParams" colspan="2">template&lt;viskores::IdComponent VecSize, typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a16e2041e42cad019f261c2f53d2ae2b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a16e2041e42cad019f261c2f53d2ae2b6">CastAndCallVecField</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;fieldArray, Functor &amp;&amp;functor, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a16e2041e42cad019f261c2f53d2ae2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to get the array from a filter's input vector field.  <a href="classviskores_1_1filter_1_1Filter.html#a16e2041e42cad019f261c2f53d2ae2b6">More...</a><br /></td></tr>
<tr class="separator:a16e2041e42cad019f261c2f53d2ae2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ab194a602c04481083cfb94ba6c045"><td class="memTemplParams" colspan="2">template&lt;viskores::IdComponent VecSize, typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a37ab194a602c04481083cfb94ba6c045"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a37ab194a602c04481083cfb94ba6c045">CastAndCallVecField</a> (const <a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> &amp;field, Functor &amp;&amp;functor, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a37ab194a602c04481083cfb94ba6c045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to get the array from a filter's input vector field.  <a href="classviskores_1_1filter_1_1Filter.html#a37ab194a602c04481083cfb94ba6c045">More...</a><br /></td></tr>
<tr class="separator:a37ab194a602c04481083cfb94ba6c045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eeb38eb36eb5fc65f40277c1226e8e9"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a6eeb38eb36eb5fc65f40277c1226e8e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a6eeb38eb36eb5fc65f40277c1226e8e9">CastAndCallVariableVecField</a> (const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;fieldArray, Functor &amp;&amp;functor, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a6eeb38eb36eb5fc65f40277c1226e8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is like <code>CastAndCallVecField</code> except that it can be used for a field of unknown vector size (or scalars).  <a href="classviskores_1_1filter_1_1Filter.html#a6eeb38eb36eb5fc65f40277c1226e8e9">More...</a><br /></td></tr>
<tr class="separator:a6eeb38eb36eb5fc65f40277c1226e8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1442151fef2c1a08bd862a259f7f6cc4"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a1442151fef2c1a08bd862a259f7f6cc4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a1442151fef2c1a08bd862a259f7f6cc4">CastAndCallVariableVecField</a> (const <a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> &amp;field, Functor &amp;&amp;functor, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a1442151fef2c1a08bd862a259f7f6cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is like <code>CastAndCallVecField</code> except that it can be used for a field of unknown vector size (or scalars).  <a href="classviskores_1_1filter_1_1Filter.html#a1442151fef2c1a08bd862a259f7f6cc4">More...</a><br /></td></tr>
<tr class="separator:a1442151fef2c1a08bd862a259f7f6cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a122f8d1ef77b7bb7f87c5279bc8f8f12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structviskores_1_1cont_1_1Invoker.html">viskores::cont::Invoker</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a122f8d1ef77b7bb7f87c5279bc8f8f12">Invoke</a></td></tr>
<tr class="separator:a122f8d1ef77b7bb7f87c5279bc8f8f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac746ba8f4227c8b708dd4cb44f42c81d"><td class="memTemplParams" colspan="2">template&lt;typename FieldMapper &gt; </td></tr>
<tr class="memitem:ac746ba8f4227c8b708dd4cb44f42c81d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#ac746ba8f4227c8b708dd4cb44f42c81d">MapFieldsOntoOutput</a> (const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;input, const <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html">viskores::filter::FieldSelection</a> &amp;fieldSelection, <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;output, FieldMapper &amp;&amp;fieldMapper) const</td></tr>
<tr class="separator:ac746ba8f4227c8b708dd4cb44f42c81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da1903bd412bfed514cea6e8253b545"><td class="memTemplParams" colspan="2">template&lt;typename FieldMapper &gt; </td></tr>
<tr class="memitem:a9da1903bd412bfed514cea6e8253b545"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a9da1903bd412bfed514cea6e8253b545">MapFieldsOntoOutput</a> (const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;input, const <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html">viskores::filter::FieldSelection</a> &amp;fieldSelection, <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;output, FieldMapper &amp;&amp;fieldMapper) const</td></tr>
<tr class="separator:a9da1903bd412bfed514cea6e8253b545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab2c182b32a3eab286e6be8a77c651a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a8ab2c182b32a3eab286e6be8a77c651a">DetermineNumberOfThreads</a> (const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;input)</td></tr>
<tr class="separator:a8ab2c182b32a3eab286e6be8a77c651a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b70e2191ed595134f2a3887e1a49eb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a1b70e2191ed595134f2a3887e1a49eb8">ResizeIfNeeded</a> (size_t index_st)</td></tr>
<tr class="separator:a1b70e2191ed595134f2a3887e1a49eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:adc67addff0017aa61269e66e901c097a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1filter_1_1FieldSelection.html">viskores::filter::FieldSelection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#adc67addff0017aa61269e66e901c097a">FieldsToPass</a> = <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7ab1c94ca2fbc3e78fc30069c8d0f01680">viskores::filter::FieldSelection::Mode::All</a></td></tr>
<tr class="separator:adc67addff0017aa61269e66e901c097a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d58f563d76dc6333edf88462f77e773"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a7d58f563d76dc6333edf88462f77e773">PassCoordinateSystems</a> = true</td></tr>
<tr class="separator:a7d58f563d76dc6333edf88462f77e773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dce4a6f133924ae99e1f51736122c6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a3dce4a6f133924ae99e1f51736122c6e">RunFilterWithMultipleThreads</a> = false</td></tr>
<tr class="separator:a3dce4a6f133924ae99e1f51736122c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44ac016e520929fbf7fd7b814a873ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#af44ac016e520929fbf7fd7b814a873ae">NumThreadsPerCPU</a> = 4</td></tr>
<tr class="separator:af44ac016e520929fbf7fd7b814a873ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c893882e8ba18986e605902a600dfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a33c893882e8ba18986e605902a600dfd">NumThreadsPerGPU</a> = 8</td></tr>
<tr class="separator:a33c893882e8ba18986e605902a600dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6077d8d2d079d389807586da7f3d8924"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a6077d8d2d079d389807586da7f3d8924">OutputFieldName</a></td></tr>
<tr class="separator:a6077d8d2d079d389807586da7f3d8924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42a23f42d4cfef371ad179952f45bda"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#ac42a23f42d4cfef371ad179952f45bda">ActiveFieldNames</a></td></tr>
<tr class="separator:ac42a23f42d4cfef371ad179952f45bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5dc9917652a94eb89bc70fb0cac3c7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a0f5dc9917652a94eb89bc70fb0cac3c7">ActiveFieldAssociation</a></td></tr>
<tr class="separator:a0f5dc9917652a94eb89bc70fb0cac3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8387639f912e86ddb160776d4f9d968f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a8387639f912e86ddb160776d4f9d968f">UseCoordinateSystemAsField</a></td></tr>
<tr class="separator:a8387639f912e86ddb160776d4f9d968f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ffaf24d517115ca572a9add34d5171"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1filter_1_1Filter.html#a83ffaf24d517115ca572a9add34d5171">ActiveCoordinateSystemIndices</a></td></tr>
<tr class="separator:a83ffaf24d517115ca572a9add34d5171"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for all filters. </p>
<p>This is the base class for all filters. To add a new filter, one can subclass this and implement relevant methods.</p>
<p><b>FilterUsage Usage</b></p>
<p>To execute a filter, one typically calls the <code>auto result = filter.Execute(input)</code>. Typical usage is as follows:</p>
<div class="fragment"><div class="line"><span class="comment">// create the concrete subclass (e.g. Contour).</span></div>
<div class="line"><a class="code" href="classviskores_1_1filter_1_1contour_1_1Contour.html">viskores::filter::contour::Contour</a> contour;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// select fields to map to the output, if different from default which is to map all input</span></div>
<div class="line"><span class="comment">// fields.</span></div>
<div class="line">contour.<a class="code" href="classviskores_1_1filter_1_1Filter.html#a40a4dc01cbe1230075cdad9467a1e9e5">SetFieldsToPass</a>({<span class="stringliteral">&quot;var1&quot;</span>, <span class="stringliteral">&quot;var2&quot;</span>});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// execute the filter on viskores::cont::DataSet.</span></div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> dsInput = ...</div>
<div class="line">auto outputDS = contour.<a class="code" href="classviskores_1_1filter_1_1Filter.html#aa9a860f4a72ae4b6330d1082cdbedfe1">Execute</a>(dsInput);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// or, execute on a viskores::cont::PartitionedDataSet</span></div>
<div class="line"><a class="code" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> mbInput = ...</div>
<div class="line">auto outputMB = contour.<a class="code" href="classviskores_1_1filter_1_1Filter.html#aa9a860f4a72ae4b6330d1082cdbedfe1">Execute</a>(mbInput);</div>
</div><!-- fragment --><p><code>Execute</code> methods take in the input DataSet or PartitionedDataSet to process and return the result. The type of the result is same as the input type, thus <code>Execute(DataSet&amp;)</code> returns a DataSet while <code>Execute(PartitionedDataSet&amp;)</code> returns a PartitionedDataSet.</p>
<p><code>Execute</code> simply calls the pure virtual function <code>DoExecute(DataSet&amp;)</code> which is the main extension point of the <a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a> interface. <a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a> developer needs to override <code>DoExecute(DataSet)</code> to implement the business logic of filtering operations on a single DataSet.</p>
<p>The default implementation of <code>Execute(PartitionedDataSet&amp;)</code> is merely provided for convenience. Internally, it calls <code>DoExecutePartitions(PartitionedDataSet)</code> to iterate DataSets of a PartitionedDataSet and pass each individual DataSets to <code>DoExecute(DataSet&amp;)</code>, possibly in a multi-threaded setting. Developer of <code>DoExecute(DataSet&amp;)</code> needs to indicate the thread-safeness of <code>DoExecute(DataSet&amp;)</code> by overriding the <code><a class="el" href="classviskores_1_1filter_1_1Filter.html#af83357015ad2df06b7ab181a75c3662b" title="Returns whether the filter can execute on partitions in concurrent threads.">CanThread()</a></code> virtual method which by default returns <code>true</code>.</p>
<p>In the case that filtering on a PartitionedDataSet can not be simply implemented as a for-each loop on the component DataSets, filter implementor needs to override the <code>DoExecutePartitions(PartitionedDataSet&amp;)</code>. See the implementation of <code>FilterParticleAdvection::Execute(PartitionedDataSet&amp;)</code> for an example.</p>
<p><b>Creating results and mapping fields</b></p>
<p>For subclasses that map input fields into output fields, the implementation of its <code>DoExecute(DataSet&amp;)</code> should create the <code>DataSet</code> to be returned with a call to <code><a class="el" href="classviskores_1_1filter_1_1Filter.html#a6f56120132ad471ae092feedad608118" title="Create the output data set for DoExecute.">Filter::CreateResult</a></code> or a similar method (such as <code><a class="el" href="classviskores_1_1filter_1_1Filter.html#a51d9cd432e624c6995d88cb379f33bd8" title="Create the output data set for DoExecute">Filter::CreateResultField</a></code>).</p>
<div class="fragment"><div class="line"><a class="code" href="ExportMacros_8h.html#ae47b94fbf1d55103fa9aeff192d8404b">VISKORES_CONT</a> DataSet SomeFilter::DoExecute(<span class="keyword">const</span> <a class="code" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a>&amp; input)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classviskores_1_1cont_1_1UnknownCellSet.html">viskores::cont::UnknownCellSet</a> outCellSet;</div>
<div class="line">  outCellSet = ... <span class="comment">// Generation of the new CellSet</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Mapper is a callable object (function object, lambda, etc.) that takes an input Field</span></div>
<div class="line">  <span class="comment">// and maps it to an output Field and then add the output Field to the output DataSet</span></div>
<div class="line">  <span class="keyword">auto</span> mapper = [](<span class="keyword">auto</span>&amp; outputDs, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; inputField) {</div>
<div class="line">     <span class="keyword">auto</span> outputField = ... <span class="comment">// Business logic for mapping input field to output field</span></div>
<div class="line">     output.AddField(outputField);</div>
<div class="line">  };</div>
<div class="line">  <span class="comment">// This passes coordinate systems directly from input to output. If the points of</span></div>
<div class="line">  <span class="comment">// the cell set change at all, they will have to be mapped by hand.</span></div>
<div class="line">  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classviskores_1_1filter_1_1Filter.html#a6f56120132ad471ae092feedad608118">CreateResult</a>(input, outCellSet, mapper);</div>
<div class="line">}</div>
</div><!-- fragment --><p>In addition to creating a new <code>DataSet</code> filled with the proper cell structure and coordinate systems, <code>CreateResult</code> iterates through each <code>FieldToPass</code> in the input DataSet and calls the FieldMapper to map the input Field to output Field. For simple filters that just pass on input fields to the output DataSet without any computation, an overload of <code>CreateResult(const viskores::cont::DataSet&amp; input)</code> is also provided as a convenience that uses the default mapper which trivially adds input Field to output DataSet (via a shallow copy).</p>
<p><b>FilterThreadSafety CanThread</b></p>
<p>By default, the implementation of <code>DoExecute(DataSet&amp;)</code> should model a <em>pure function</em>, i.e. it does not have any mutable shared state. This makes it thread-safe by default and allows the default implementation of <code>DoExecutePartitions(PartitionedDataSet&amp;)</code> to be simply a parallel for-each, thus facilitates multi-threaded execution without any lock.</p>
<p>Many legacy (Viskores 1.x) filter implementations needed to store states between the mesh generation phase and field mapping phase of filter execution, for example, parameters for field interpolation. The shared mutable states were mostly stored as mutable data members of the filter class (either in terms of ArrayHandle or some kind of Worket). The new filter interface, by combining the two phases into a single call to <code>DoExecute(DataSet&amp;)</code>, we have eliminated most of the cases that require such shared mutable states. New implementations of filters that require passing information between these two phases can now use local variables within the <code>DoExecute(DataSet&amp;)</code>. For example:</p>
<p>```cpp struct SharedState; // shared states between mesh generation and field mapping. VISKORES_CONT DataSet ThreadSafeFilter::DoExecute(const viskores::cont::DataSet&amp; input) { // Mutable states that was a data member of the filter is now a local variable. // Each invocation of Execute(DataSet) in the multi-threaded execution of // Execute(PartitionedDataSet&amp;) will have a copy of <code>states</code> on each thread's stack // thus making it thread-safe. SharedStates states;</p>
<p>viskores::cont::CellSetExplicit&lt;&gt; cellSet; cellSet = ... // Generation of the new DataSet and store interpolation parameters in <code>states</code></p>
<p>// Lambda capture of <code>states</code>, effectively passing the shared states to the Mapper. auto mapper = [&amp;states](auto&amp; outputDs, const auto&amp; inputField) { auto outputField = ... // Use <code>states</code> for mapping input field to output field output.AddField(outputField); }; this-&gt;CreateOutput(input, cellSet, mapper);</p>
<p>return output; } ```</p>
<p>In the rare cases that filter implementation can not be made thread-safe, the implementation needs to override the <code><a class="el" href="classviskores_1_1filter_1_1Filter.html#af83357015ad2df06b7ab181a75c3662b" title="Returns whether the filter can execute on partitions in concurrent threads.">CanThread()</a></code> virtual method to return <code>false</code>. The default <code>Execute(PartitionedDataSet&amp;)</code> implementation will fallback to a serial for loop execution.</p>
<p><em>FilterThreadScheduling DoExecute</em></p>
<p>The default multi-threaded execution of <code>Execute(PartitionedDataSet&amp;)</code> uses a simple FIFO queue of DataSet and pool of <em>worker</em> threads. Implementation of <a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a> subclass can override the <code>DoExecutePartitions(PartitionedDataSet)</code> virtual method to provide implementation specific scheduling policy. The default number of <em>worker</em> threads in the pool are determined by the <code><a class="el" href="classviskores_1_1filter_1_1Filter.html#a8ab2c182b32a3eab286e6be8a77c651a">DetermineNumberOfThreads()</a></code> virtual method using several backend dependent heuristic. Implementations of <a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a> subclass can also override <code><a class="el" href="classviskores_1_1filter_1_1Filter.html#a8ab2c182b32a3eab286e6be8a77c651a">DetermineNumberOfThreads()</a></code> to provide implementation specific heuristic. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa47718833f3adf8dd6df04a8e8bf8b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47718833f3adf8dd6df04a8e8bf8b93">&#9670;&nbsp;</a></span>Filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">viskores::filter::Filter::Filter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ee64bae3e8c4d54fb5ca208871f8e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee64bae3e8c4d54fb5ca208871f8e2a">&#9670;&nbsp;</a></span>~Filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual viskores::filter::Filter::~Filter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af83357015ad2df06b7ab181a75c3662b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83357015ad2df06b7ab181a75c3662b">&#9670;&nbsp;</a></span>CanThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool viskores::filter::Filter::CanThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the filter can execute on partitions in concurrent threads. </p>
<p>If a derived class's implementation of <code>DoExecute</code> cannot run on multiple threads, then the derived class should override this method to return false. </p>

<p>Reimplemented in <a class="el" href="classviskores_1_1filter_1_1scalar__topology_1_1ContourTreeUniformDistributed.html#ab50776df968704ee872941e628a57302">viskores::filter::scalar_topology::ContourTreeUniformDistributed</a>, <a class="el" href="classviskores_1_1filter_1_1scalar__topology_1_1ContourTreeAugmented.html#a14ef6624a9a515fe308f19b9f2e19f6c">viskores::filter::scalar_topology::ContourTreeAugmented</a>, <a class="el" href="classviskores_1_1filter_1_1entity__extraction_1_1ExternalFaces.html#a20ed373ffd0308f35014d96ddc0857de">viskores::filter::entity_extraction::ExternalFaces</a>, <a class="el" href="classviskores_1_1filter_1_1flow_1_1FilterParticleAdvection.html#a593c804066e61aadf68b54e7536dc8db">viskores::filter::flow::FilterParticleAdvection</a>, <a class="el" href="classviskores_1_1filter_1_1flow_1_1LagrangianStructures.html#ab48a21a4c928cf856630caa58efa27eb">viskores::filter::flow::LagrangianStructures</a>, and <a class="el" href="classviskores_1_1filter_1_1flow_1_1Lagrangian.html#acfbd3eb664c25e70b9d7a0cca37531ab">viskores::filter::flow::Lagrangian</a>.</p>

</div>
</div>
<a id="a23b5bee38aeb26a87641c9ecef4ff510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b5bee38aeb26a87641c9ecef4ff510">&#9670;&nbsp;</a></span>CastAndCallScalarField() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::CastAndCallScalarField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method to get the array from a filter's input scalar field. </p>
<p>A field filter typically gets its input fields using the internal <code>GetFieldFromDataSet</code>. To use this field in a worklet, it eventually needs to be converted to an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a></code>. If the input field is limited to be a scalar field, then this method provides a convenient way to determine the correct array type. Like other <code>CastAndCall</code> methods, it takes as input a <code><a class="el" href="classviskores_1_1cont_1_1Field.html" title="A Field encapsulates an array on some piece of the mesh, such as the points, a cell set,...">viskores::cont::Field</a></code> (or <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">viskores::cont::UnknownArrayHandle</a></code>) and a function/functor to call with the appropriate <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a></code> type. </p>

</div>
</div>
<a id="a5fc8781cad13719eddfd02b84480833c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc8781cad13719eddfd02b84480833c">&#9670;&nbsp;</a></span>CastAndCallScalarField() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::CastAndCallScalarField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>fieldArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method to get the array from a filter's input scalar field. </p>
<p>A field filter typically gets its input fields using the internal <code>GetFieldFromDataSet</code>. To use this field in a worklet, it eventually needs to be converted to an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a></code>. If the input field is limited to be a scalar field, then this method provides a convenient way to determine the correct array type. Like other <code>CastAndCall</code> methods, it takes as input a <code><a class="el" href="classviskores_1_1cont_1_1Field.html" title="A Field encapsulates an array on some piece of the mesh, such as the points, a cell set,...">viskores::cont::Field</a></code> (or <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">viskores::cont::UnknownArrayHandle</a></code>) and a function/functor to call with the appropriate <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a></code> type. </p>

</div>
</div>
<a id="a1442151fef2c1a08bd862a259f7f6cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1442151fef2c1a08bd862a259f7f6cc4">&#9670;&nbsp;</a></span>CastAndCallVariableVecField() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::CastAndCallVariableVecField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is like <code>CastAndCallVecField</code> except that it can be used for a field of unknown vector size (or scalars). </p>
<p>This method will call the given functor with an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRecombineVec.html" title="A grouping of ArrayHandleStrides into an ArrayHandle of viskores::Vecs.">viskores::cont::ArrayHandleRecombineVec</a></code>.</p>
<p>Note that there are limitations with using <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRecombineVec.html" title="A grouping of ArrayHandleStrides into an ArrayHandle of viskores::Vecs.">viskores::cont::ArrayHandleRecombineVec</a></code> within a worklet. Because the size of the vectors are not known at compile time, you cannot just create an intermediate <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a></code> of the correct size. Typically, you must allocate the output array (for example, with <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">viskores::cont::ArrayHandleRuntimeVec</a></code>), and the worklet must iterate over the components and store them in the prealocated output. </p>

</div>
</div>
<a id="a6eeb38eb36eb5fc65f40277c1226e8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eeb38eb36eb5fc65f40277c1226e8e9">&#9670;&nbsp;</a></span>CastAndCallVariableVecField() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::CastAndCallVariableVecField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>fieldArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is like <code>CastAndCallVecField</code> except that it can be used for a field of unknown vector size (or scalars). </p>
<p>This method will call the given functor with an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRecombineVec.html" title="A grouping of ArrayHandleStrides into an ArrayHandle of viskores::Vecs.">viskores::cont::ArrayHandleRecombineVec</a></code>.</p>
<p>Note that there are limitations with using <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRecombineVec.html" title="A grouping of ArrayHandleStrides into an ArrayHandle of viskores::Vecs.">viskores::cont::ArrayHandleRecombineVec</a></code> within a worklet. Because the size of the vectors are not known at compile time, you cannot just create an intermediate <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a></code> of the correct size. Typically, you must allocate the output array (for example, with <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">viskores::cont::ArrayHandleRuntimeVec</a></code>), and the worklet must iterate over the components and store them in the prealocated output. </p>

</div>
</div>
<a id="a37ab194a602c04481083cfb94ba6c045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ab194a602c04481083cfb94ba6c045">&#9670;&nbsp;</a></span>CastAndCallVecField() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;viskores::IdComponent VecSize, typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::CastAndCallVecField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method to get the array from a filter's input vector field. </p>
<p>A field filter typically gets its input fields using the internal <code>GetFieldFromDataSet</code>. To use this field in a worklet, it eventually needs to be converted to an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a></code>. If the input field is limited to be a vector field with vectors of a specific size, then this method provides a convenient way to determine the correct array type. Like other <code>CastAndCall</code> methods, it takes as input a <code><a class="el" href="classviskores_1_1cont_1_1Field.html" title="A Field encapsulates an array on some piece of the mesh, such as the points, a cell set,...">viskores::cont::Field</a></code> (or <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">viskores::cont::UnknownArrayHandle</a></code>) and a function/functor to call with the appropriate <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a></code> type. You also have to provide the vector size as the first template argument. For example <code>CastAndCallVecField&lt;3&gt;(field, functor);</code>. </p>

</div>
</div>
<a id="a16e2041e42cad019f261c2f53d2ae2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e2041e42cad019f261c2f53d2ae2b6">&#9670;&nbsp;</a></span>CastAndCallVecField() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;viskores::IdComponent VecSize, typename Functor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::CastAndCallVecField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>fieldArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method to get the array from a filter's input vector field. </p>
<p>A field filter typically gets its input fields using the internal <code>GetFieldFromDataSet</code>. To use this field in a worklet, it eventually needs to be converted to an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a></code>. If the input field is limited to be a vector field with vectors of a specific size, then this method provides a convenient way to determine the correct array type. Like other <code>CastAndCall</code> methods, it takes as input a <code><a class="el" href="classviskores_1_1cont_1_1Field.html" title="A Field encapsulates an array on some piece of the mesh, such as the points, a cell set,...">viskores::cont::Field</a></code> (or <code><a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html" title="An ArrayHandle of an unknown value type and storage.">viskores::cont::UnknownArrayHandle</a></code>) and a function/functor to call with the appropriate <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">viskores::cont::ArrayHandle</a></code> type. You also have to provide the vector size as the first template argument. For example <code>CastAndCallVecField&lt;3&gt;(field, functor);</code>. </p>

</div>
</div>
<a id="a6f56120132ad471ae092feedad608118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f56120132ad471ae092feedad608118">&#9670;&nbsp;</a></span>CreateResult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> viskores::filter::Filter::CreateResult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>inDataSet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the output data set for <code>DoExecute</code>. </p>
<p>This form of <code>CreateResult</code> will create an output data set with the same cell structure and coordinate system as the input and pass all fields (as requested by the <code><a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a></code> state).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inDataSet</td><td>The input data set being modified (usually the one passed into <code>DoExecute</code>). The returned <code>DataSet</code> is filled with the cell set, coordinate system, and fields of <code>inDataSet</code> (as selected by the <code>FieldsToPass</code> state of the filter). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0292134ef6d642d852fc5e17f46f280c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0292134ef6d642d852fc5e17f46f280c">&#9670;&nbsp;</a></span>CreateResult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldMapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> viskores::filter::Filter::CreateResult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>inDataSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownCellSet.html">viskores::cont::UnknownCellSet</a> &amp;&#160;</td>
          <td class="paramname"><em>resultCellSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldMapper &amp;&amp;&#160;</td>
          <td class="paramname"><em>fieldMapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the output data set for <code>DoExecute</code>. </p>
<p>This form of <code>CreateResult</code> will create an output data set with the given <code>CellSet</code>. You must also provide a field mapper function, which is a function that takes the output <code>DataSet</code> being created and a <code>Field</code> from the input and then applies any necessary transformations to the field array and adds it to the <code>DataSet</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inDataSet</td><td>The input data set being modified (usually the one passed into <code>DoExecute</code>). The returned <code>DataSet</code> is filled with fields of <code>inDataSet</code> (as selected by the <code>FieldsToPass</code> state of the filter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultCellSet</td><td>The <code>CellSet</code> of the output will be set to this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fieldMapper</td><td>A function or functor that takes a <code>DataSet</code> as its first argument and a <code>Field</code> as its second argument. The <code>DataSet</code> is the data being created and will eventually be returned by <code>CreateResult</code>. The <code>Field</code> comes from <code>inDataSet</code>. The function should map the <code>Field</code> to match <code>resultCellSet</code> and then add the resulting field to the <code>DataSet</code>. If the mapping is not possible, then the function should do nothing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a838ec247e6d25281eecffe26374961a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838ec247e6d25281eecffe26374961a3">&#9670;&nbsp;</a></span>CreateResult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> viskores::filter::Filter::CreateResult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>resultPartitions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the output data set for <code>DoExecute</code>. </p>
<p>This form of <code>CreateResult</code> will create an output PartitionedDataSet with the same partitions and pass all PartitionedDataSet fields (as requested by the <code><a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a></code> state).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input data set being modified (usually the one passed into <code>DoExecute</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultPartitions</td><td>The output data created by the filter. Fields from the input are passed onto the return result partition as requested by the <code><a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a></code> state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f45fbc5edc7a0cb9a99fc8af4e5d369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f45fbc5edc7a0cb9a99fc8af4e5d369">&#9670;&nbsp;</a></span>CreateResult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldMapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> viskores::filter::Filter::CreateResult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>resultPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldMapper &amp;&amp;&#160;</td>
          <td class="paramname"><em>fieldMapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the output data set for <code>DoExecute</code>. </p>
<p>This form of <code>CreateResult</code> will create an output PartitionedDataSet with the same partitions and pass all PartitionedDataSet fields (as requested by the <code><a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a></code> state).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input data set being modified (usually the one passed into <code>DoExecute</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultPartitions</td><td>The output data created by the filter. Fields from the input are passed onto the return result partition as requested by the <code><a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a></code> state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fieldMapper</td><td>A function or functor that takes a <code>PartitionedDataSet</code> as its first argument and a <code>Field</code> as its second argument. The <code>PartitionedDataSet</code> is the data being created and will eventually be returned by <code>CreateResult</code>. The <code>Field</code> comes from <code>input</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac166dc462d825cffb35701017d912099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac166dc462d825cffb35701017d912099">&#9670;&nbsp;</a></span>CreateResultCoordinateSystem() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldMapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> viskores::filter::Filter::CreateResultCoordinateSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>inDataSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownCellSet.html">viskores::cont::UnknownCellSet</a> &amp;&#160;</td>
          <td class="paramname"><em>resultCellSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>coordsName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>coordsData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldMapper &amp;&amp;&#160;</td>
          <td class="paramname"><em>fieldMapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the output data set for <code>DoExecute</code>. </p>
<p>This form of <code>CreateResult</code> will create an output data set with the given <code>CellSet</code> and <code>CoordinateSystem</code>. You must also provide a field mapper function, which is a function that takes the output <code>DataSet</code> being created and a <code>Field</code> from the input and then applies any necessary transformations to the field array and adds it to the <code>DataSet</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inDataSet</td><td>The input data set being modified (usually the one passed into <code>DoExecute</code>). The returned <code>DataSet</code> is filled with fields of <code>inDataSet</code> (as selected by the <code>FieldsToPass</code> state of the filter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultCellSet</td><td>The <code>CellSet</code> of the output will be set to this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coordsName</td><td>The name of the coordinate system to be added to the output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coordsData</td><td>The array containing the coordinates of the points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fieldMapper</td><td>A function or functor that takes a <code>DataSet</code> as its first argument and a <code>Field</code> as its second argument. The <code>DataSet</code> is the data being created and will eventually be returned by <code>CreateResult</code>. The <code>Field</code> comes from <code>inDataSet</code>. The function should map the <code>Field</code> to match <code>resultCellSet</code> and then add the resulting field to the <code>DataSet</code>. If the mapping is not possible, then the function should do nothing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09a3adeb07b3ffd9cef4ebb562f0ef5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a3adeb07b3ffd9cef4ebb562f0ef5c">&#9670;&nbsp;</a></span>CreateResultCoordinateSystem() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldMapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> viskores::filter::Filter::CreateResultCoordinateSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>inDataSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownCellSet.html">viskores::cont::UnknownCellSet</a> &amp;&#160;</td>
          <td class="paramname"><em>resultCellSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html">viskores::cont::CoordinateSystem</a> &amp;&#160;</td>
          <td class="paramname"><em>resultCoordSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldMapper &amp;&amp;&#160;</td>
          <td class="paramname"><em>fieldMapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the output data set for <code>DoExecute</code>. </p>
<p>This form of <code>CreateResult</code> will create an output data set with the given <code>CellSet</code> and <code>CoordinateSystem</code>. You must also provide a field mapper function, which is a function that takes the output <code>DataSet</code> being created and a <code>Field</code> from the input and then applies any necessary transformations to the field array and adds it to the <code>DataSet</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inDataSet</td><td>The input data set being modified (usually the one passed into <code>DoExecute</code>). The returned <code>DataSet</code> is filled with fields of <code>inDataSet</code> (as selected by the <code>FieldsToPass</code> state of the filter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultCellSet</td><td>The <code>CellSet</code> of the output will be set to this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultCoordSystem</td><td>This <code>CoordinateSystem</code> will be added to the output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fieldMapper</td><td>A function or functor that takes a <code>DataSet</code> as its first argument and a <code>Field</code> as its second argument. The <code>DataSet</code> is the data being created and will eventually be returned by <code>CreateResult</code>. The <code>Field</code> comes from <code>inDataSet</code>. The function should map the <code>Field</code> to match <code>resultCellSet</code> and then add the resulting field to the <code>DataSet</code>. If the mapping is not possible, then the function should do nothing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab352d4c1439c22e40e88658ea41d6322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab352d4c1439c22e40e88658ea41d6322">&#9670;&nbsp;</a></span>CreateResultField() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> viskores::filter::Filter::CreateResultField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>inDataSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>resultFieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a>&#160;</td>
          <td class="paramname"><em>resultFieldAssociation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>resultFieldArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the output data set for <code>DoExecute</code> </p>
<p>This form of <code>CreateResult</code> will create an output data set with the same cell structure and coordinate system as the input and pass all fields (as requested by the <code><a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a></code> state). Additionally, it will add a field matching the provided specifications to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inDataSet</td><td>The input data set being modified (usually the one passed into <code>DoExecute</code>). The returned <code>DataSet</code> is filled with fields of <code>inDataSet</code> (as selected by the <code>FieldsToPass</code> state of the filter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultFieldName</td><td>The name of the field added to the returned <code>DataSet</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultFieldAssociation</td><td>The association of the field (e.g. point or cell) added to the returned <code>DataSet</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultFieldArray</td><td>An array containing the data for the field added to the returned <code>DataSet</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51d9cd432e624c6995d88cb379f33bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d9cd432e624c6995d88cb379f33bd8">&#9670;&nbsp;</a></span>CreateResultField() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> viskores::filter::Filter::CreateResultField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>inDataSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a> &amp;&#160;</td>
          <td class="paramname"><em>resultField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the output data set for <code>DoExecute</code> </p>
<p>This form of <code>CreateResult</code> will create an output data set with the same cell structure and coordinate system as the input and pass all fields (as requested by the <code><a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a></code> state). Additionally, it will add the provided field to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inDataSet</td><td>The input data set being modified (usually the one passed into <code>DoExecute</code>). The returned <code>DataSet</code> is filled with fields of <code>inDataSet</code> (as selected by the <code>FieldsToPass</code> state of the filter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultField</td><td>A <code>Field</code> that is added to the returned <code>DataSet</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a527b9d9cb733738b5bf1afa1120c904a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527b9d9cb733738b5bf1afa1120c904a">&#9670;&nbsp;</a></span>CreateResultFieldCell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> viskores::filter::Filter::CreateResultFieldCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>inDataSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>resultFieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>resultFieldArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the output data set for <code>DoExecute</code> </p>
<p>This form of <code>CreateResult</code> will create an output data set with the same cell structure and coordinate system as the input and pass all fields (as requested by the <code><a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a></code> state). Additionally, it will add a cell field matching the provided specifications to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inDataSet</td><td>The input data set being modified (usually the one passed into <code>DoExecute</code>). The returned <code>DataSet</code> is filled with fields of <code>inDataSet</code> (as selected by the <code>FieldsToPass</code> state of the filter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultFieldName</td><td>The name of the field added to the returned <code>DataSet</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultFieldArray</td><td>An array containing the data for the field added to the returned <code>DataSet</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe86079ed8dd3d5a6665b0c118885d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe86079ed8dd3d5a6665b0c118885d54">&#9670;&nbsp;</a></span>CreateResultFieldPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> viskores::filter::Filter::CreateResultFieldPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>inDataSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>resultFieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1UnknownArrayHandle.html">viskores::cont::UnknownArrayHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>resultFieldArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the output data set for <code>DoExecute</code> </p>
<p>This form of <code>CreateResult</code> will create an output data set with the same cell structure and coordinate system as the input and pass all fields (as requested by the <code><a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a></code> state). Additionally, it will add a point field matching the provided specifications to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inDataSet</td><td>The input data set being modified (usually the one passed into <code>DoExecute</code>). The returned <code>DataSet</code> is filled with fields of <code>inDataSet</code> (as selected by the <code>FieldsToPass</code> state of the filter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultFieldName</td><td>The name of the field added to the returned <code>DataSet</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultFieldArray</td><td>An array containing the data for the field added to the returned <code>DataSet</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ab2c182b32a3eab286e6be8a77c651a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab2c182b32a3eab286e6be8a77c651a">&#9670;&nbsp;</a></span>DetermineNumberOfThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> viskores::filter::Filter::DetermineNumberOfThreads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ed1cf9cb66af903ab03e4157f3032af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed1cf9cb66af903ab03e4157f3032af">&#9670;&nbsp;</a></span>DoExecute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> viskores::filter::Filter::DoExecute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>inData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classviskores_1_1filter_1_1contour_1_1AbstractContour.html#a757349f33cb3ef85e545803c98bf867c">viskores::filter::contour::AbstractContour</a>, <a class="el" href="classviskores_1_1filter_1_1contour_1_1Contour.html#a9ffdecf62a7eef8a90e317c61036435d">viskores::filter::contour::Contour</a>, <a class="el" href="classviskores_1_1filter_1_1contour_1_1ContourFlyingEdges.html#af4b1920b4a05537d5cdb632d7b775e8b">viskores::filter::contour::ContourFlyingEdges</a>, <a class="el" href="classviskores_1_1filter_1_1contour_1_1ContourMarchingCells.html#a8ef9bbf619cd45041e954be6aa4bce47">viskores::filter::contour::ContourMarchingCells</a>, <a class="el" href="classviskores_1_1filter_1_1image__processing_1_1ImageDifference.html#ae44dce0d242ed816575695f89479cbe0">viskores::filter::image_processing::ImageDifference</a>, <a class="el" href="classviskores_1_1filter_1_1vector__analysis_1_1SurfaceNormals.html#a1d07d2761f1818438ecb3e07185b0cfd">viskores::filter::vector_analysis::SurfaceNormals</a>, <a class="el" href="classviskores_1_1filter_1_1vector__analysis_1_1Gradient.html#a0eea4744720fc6b44455b69bb14f17c3">viskores::filter::vector_analysis::Gradient</a>, <a class="el" href="classviskores_1_1filter_1_1multi__block_1_1MergeDataSets.html#a6385f06af1d9e67c836d135d31d92b77">viskores::filter::multi_block::MergeDataSets</a>, <a class="el" href="classviskores_1_1filter_1_1scalar__topology_1_1ContourTreeUniformDistributed.html#a3c22ee7837bb01362703c1b0907356b6">viskores::filter::scalar_topology::ContourTreeUniformDistributed</a>, <a class="el" href="classviskores_1_1filter_1_1field__transform_1_1PointTransform.html#a456cc39b332d70eb8e2229ee124f69de">viskores::filter::field_transform::PointTransform</a>, <a class="el" href="classviskores_1_1filter_1_1field__transform_1_1FieldToColors.html#aa5b5f920d7e327a0f4921f54ecd8ef2b">viskores::filter::field_transform::FieldToColors</a>, <a class="el" href="classviskores_1_1filter_1_1scalar__topology_1_1ContourTreeAugmented.html#a752f501eb15cfae88aeb00cba38600d0">viskores::filter::scalar_topology::ContourTreeAugmented</a>, <a class="el" href="classviskores_1_1filter_1_1field__transform_1_1Warp.html#a15c89254bcab3ebd2cd091ca75d026de">viskores::filter::field_transform::Warp</a>, <a class="el" href="classviskores_1_1filter_1_1entity__extraction_1_1ExtractStructured.html#af44f26de768d3a148969627a4329d0c8">viskores::filter::entity_extraction::ExtractStructured</a>, <a class="el" href="classviskores_1_1filter_1_1vector__analysis_1_1DotProduct.html#a8eb60122c5bdcab156628efcdb23ed54">viskores::filter::vector_analysis::DotProduct</a>, <a class="el" href="classviskores_1_1filter_1_1vector__analysis_1_1CrossProduct.html#a3f564e0c93c0df822bf46e44d5bb1be2">viskores::filter::vector_analysis::CrossProduct</a>, <a class="el" href="classviskores_1_1filter_1_1uncertainty_1_1ContourUncertainUniform.html#af914aee185c53726db1859238ca07136">viskores::filter::uncertainty::ContourUncertainUniform</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQuality.html#ad237effb265a6ff86a06020554372042">viskores::filter::mesh_info::MeshQuality</a>, <a class="el" href="classviskores_1_1filter_1_1entity__extraction_1_1Threshold.html#a910a67105e902fb688a0e997245cdd51">viskores::filter::entity_extraction::Threshold</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1CellMeasures.html#a280f0929d2f49bd1d502991d37d25f98">viskores::filter::mesh_info::CellMeasures</a>, <a class="el" href="classviskores_1_1filter_1_1entity__extraction_1_1ExtractGeometry.html#a0d3aebd1859dea50b8b61adf16e6cac0">viskores::filter::entity_extraction::ExtractGeometry</a>, <a class="el" href="classviskores_1_1filter_1_1scalar__topology_1_1ContourTreeMesh3D.html#a84a001f7237e9044427db85a81ca22d6">viskores::filter::scalar_topology::ContourTreeMesh3D</a>, <a class="el" href="classviskores_1_1filter_1_1entity__extraction_1_1GhostCellRemove.html#a82754acbf035216e4e1cef452c7677d7">viskores::filter::entity_extraction::GhostCellRemove</a>, <a class="el" href="classviskores_1_1filter_1_1resampling_1_1HistSampling.html#aad9e93f330c488b9b41ac1cb315b6b1f">viskores::filter::resampling::HistSampling</a>, <a class="el" href="classviskores_1_1filter_1_1field__transform_1_1GenerateIds.html#a98f1e15934e246097e55cfc9e04ed075">viskores::filter::field_transform::GenerateIds</a>, <a class="el" href="classviskores_1_1filter_1_1field__transform_1_1LogValues.html#a713b29a1e876ea176f73227001cb4b19">viskores::filter::field_transform::LogValues</a>, <a class="el" href="classviskores_1_1filter_1_1scalar__topology_1_1ContourTreeMesh2D.html#a70300e3b152401c3057d4a41a2f15eda">viskores::filter::scalar_topology::ContourTreeMesh2D</a>, <a class="el" href="classviskores_1_1filter_1_1entity__extraction_1_1ExtractPoints.html#a0e3298e682f31c53558c5cd02e6d8ee9">viskores::filter::entity_extraction::ExtractPoints</a>, <a class="el" href="classviskores_1_1filter_1_1density__estimate_1_1Histogram.html#afef73b3e48692db138e6961e0d05efad">viskores::filter::density_estimate::Histogram</a>, <a class="el" href="classviskores_1_1filter_1_1field__transform_1_1PointElevation.html#ad309cdd2063617e338831fcd7d1b5de2">viskores::filter::field_transform::PointElevation</a>, <a class="el" href="classviskores_1_1filter_1_1uncertainty_1_1ContourUncertainUniformMonteCarlo.html#a7d7252efc53ba01873e765d153ad3e33">viskores::filter::uncertainty::ContourUncertainUniformMonteCarlo</a>, <a class="el" href="classviskores_1_1filter_1_1contour_1_1MIRFilter.html#a725bb0728e1c84fc47495f3ace0ba083">viskores::filter::contour::MIRFilter</a>, <a class="el" href="classviskores_1_1filter_1_1density__estimate_1_1Statistics.html#ad27a80c30a74097f473c926afa6e426b">viskores::filter::density_estimate::Statistics</a>, <a class="el" href="classviskores_1_1filter_1_1geometry__refinement_1_1VertexClustering.html#a947eab91843001fac0a2d0404bdbaa5d">viskores::filter::geometry_refinement::VertexClustering</a>, <a class="el" href="classviskores_1_1filter_1_1resampling_1_1Probe.html#a92a1519b70b6f8e12aa0ddaa9b28334d">viskores::filter::resampling::Probe</a>, <a class="el" href="classviskores_1_1filter_1_1entity__extraction_1_1ExternalFaces.html#ab2fede3202c53d101d211e07d6ba87a5">viskores::filter::entity_extraction::ExternalFaces</a>, <a class="el" href="classviskores_1_1filter_1_1density__estimate_1_1ParticleDensityNearestGridPoint.html#ae3d31340bb2e2ba3392f638754d299d8">viskores::filter::density_estimate::ParticleDensityNearestGridPoint</a>, <a class="el" href="classviskores_1_1filter_1_1geometry__refinement_1_1ConvertToPointCloud.html#a5782a819ef361626c0fb9d37b3086091">viskores::filter::geometry_refinement::ConvertToPointCloud</a>, <a class="el" href="classviskores_1_1filter_1_1density__estimate_1_1ParticleDensityCloudInCell.html#a9a54c00e2752c77ed5925417c42a08f5">viskores::filter::density_estimate::ParticleDensityCloudInCell</a>, <a class="el" href="classviskores_1_1filter_1_1geometry__refinement_1_1SplitSharpEdges.html#a2c2abc5d0777779ab79a61899be174c1">viskores::filter::geometry_refinement::SplitSharpEdges</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityScaledJacobian.html#a45f025ace25dbee8369698978516caab">viskores::filter::mesh_info::MeshQualityScaledJacobian</a>, <a class="el" href="classviskores_1_1filter_1_1contour_1_1ClipWithImplicitFunction.html#a9a2c204d60a3e01313f3d36644c9881a">viskores::filter::contour::ClipWithImplicitFunction</a>, <a class="el" href="classviskores_1_1filter_1_1density__estimate_1_1ContinuousScatterPlot.html#af0b09c97790de968d9318399a5abb5b5">viskores::filter::density_estimate::ContinuousScatterPlot</a>, <a class="el" href="classviskores_1_1filter_1_1contour_1_1ClipWithField.html#a9d1417202fc4e91e018ce2e55fcb6d83">viskores::filter::contour::ClipWithField</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityRelativeSizeSquared.html#a82dda6f9390edb09ba606767081428d7">viskores::filter::mesh_info::MeshQualityRelativeSizeSquared</a>, <a class="el" href="classviskores_1_1filter_1_1entity__extraction_1_1ThresholdPoints.html#af2edff0911a49c717e458c96b7c831f7">viskores::filter::entity_extraction::ThresholdPoints</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityWarpage.html#a1032eb24bd2316241d76075bd03e39a0">viskores::filter::mesh_info::MeshQualityWarpage</a>, <a class="el" href="classviskores_1_1filter_1_1density__estimate_1_1NDHistogram.html#a2f2b8903390718373f67da3c805d6a11">viskores::filter::density_estimate::NDHistogram</a>, <a class="el" href="classviskores_1_1filter_1_1field__transform_1_1CompositeVectors.html#abcf087d9f3b2eb961b4639ddbd624898">viskores::filter::field_transform::CompositeVectors</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityArea.html#a99840d1b1e2064e6d9d6841f31a0973a">viskores::filter::mesh_info::MeshQualityArea</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityVolume.html#a3fb0f12f7ada37d2d1dd7c69a1f9f205">viskores::filter::mesh_info::MeshQualityVolume</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityShape.html#a68ca72c48babdac97a7d41548ecbf1ea">viskores::filter::mesh_info::MeshQualityShape</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityShapeAndSize.html#acff9b1b9aea2badf888dcd5ecb239083">viskores::filter::mesh_info::MeshQualityShapeAndSize</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualitySkew.html#a76af622fcac292b9dec4e3ec241cbd96">viskores::filter::mesh_info::MeshQualitySkew</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityTaper.html#a2e30cb3b13294366c11cd9b6dfd5fa2d">viskores::filter::mesh_info::MeshQualityTaper</a>, <a class="el" href="classviskores_1_1filter_1_1geometry__refinement_1_1Tube.html#ab45e510841890c5bc0e0a8c09a94c29c">viskores::filter::geometry_refinement::Tube</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityMaxAngle.html#a5541c1096d2ac682a4fc021f927d015b">viskores::filter::mesh_info::MeshQualityMaxAngle</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityMinAngle.html#a040fdc2ebc3407b637ec2eb42bbab2ac">viskores::filter::mesh_info::MeshQualityMinAngle</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityStretch.html#a68884734706ebfc8507e64dee27b6b36">viskores::filter::mesh_info::MeshQualityStretch</a>, <a class="el" href="classviskores_1_1filter_1_1contour_1_1Slice.html#ad438a66b48dab93ff4c3da2f635179ce">viskores::filter::contour::Slice</a>, <a class="el" href="classviskores_1_1filter_1_1geometry__refinement_1_1Shrink.html#a82e3e660aaabb3b14ee160db698f6484">viskores::filter::geometry_refinement::Shrink</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityAspectGamma.html#ac906c29436f742def020fd5f0f24e44d">viskores::filter::mesh_info::MeshQualityAspectGamma</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityAspectRatio.html#ab31b23b77fee246a5fbde5d15058dcf1">viskores::filter::mesh_info::MeshQualityAspectRatio</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityShear.html#a7d73f5f04edf7b9374067f7b7516ef95">viskores::filter::mesh_info::MeshQualityShear</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityCondition.html#ad5a36e68f12f8c31da3790fcd825026e">viskores::filter::mesh_info::MeshQualityCondition</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityDiagonalRatio.html#a6b7c2c7c53aee626f7683d8e2b8d0d4b">viskores::filter::mesh_info::MeshQualityDiagonalRatio</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityOddy.html#aa784e5cbe4929f62f3dc5ab58006588d">viskores::filter::mesh_info::MeshQualityOddy</a>, <a class="el" href="classviskores_1_1filter_1_1contour_1_1SliceMultiple.html#a317f4aa7339ffb030634e5b9781a0c3e">viskores::filter::contour::SliceMultiple</a>, <a class="el" href="classviskores_1_1filter_1_1entity__extraction_1_1Mask.html#aed35a159549fb6842e0d65c25d4afebf">viskores::filter::entity_extraction::Mask</a>, <a class="el" href="classviskores_1_1filter_1_1field__transform_1_1CylindricalCoordinateTransform.html#abb6a746233c2ac1cbdad525ad09d42f3">viskores::filter::field_transform::CylindricalCoordinateTransform</a>, <a class="el" href="classviskores_1_1filter_1_1field__transform_1_1SphericalCoordinateTransform.html#a62e39f6efb3c0e7a2347e40d74cda1f8">viskores::filter::field_transform::SphericalCoordinateTransform</a>, <a class="el" href="classviskores_1_1filter_1_1connected__components_1_1ImageConnectivity.html#a4d9c0d77f11199a19ceada29ab5f6f7b">viskores::filter::connected_components::ImageConnectivity</a>, <a class="el" href="classviskores_1_1filter_1_1density__estimate_1_1Entropy.html#a94683a6e1b3ec632ebccd92325c9ef5f">viskores::filter::density_estimate::Entropy</a>, <a class="el" href="classviskores_1_1filter_1_1entity__extraction_1_1MaskPoints.html#a531a4abaf3dff9e98934861c51cb9ac5">viskores::filter::entity_extraction::MaskPoints</a>, <a class="el" href="classviskores_1_1filter_1_1image__processing_1_1ImageMedian.html#a27f18260e05ab70e47497fc47103b035">viskores::filter::image_processing::ImageMedian</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityDimension.html#ab560ee5ac5d05214e819fd95bf5177da">viskores::filter::mesh_info::MeshQualityDimension</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityJacobian.html#ac30748300bf743ff50a8b6293ade91d4">viskores::filter::mesh_info::MeshQualityJacobian</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityMaxDiagonal.html#afadddc078a605a596672c9f3a6dfe101">viskores::filter::mesh_info::MeshQualityMaxDiagonal</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1MeshQualityMinDiagonal.html#a91d1313bd40d6d4335232e0a7d1d57c1">viskores::filter::mesh_info::MeshQualityMinDiagonal</a>, <a class="el" href="classviskores_1_1filter_1_1connected__components_1_1CellSetConnectivity.html#a93a59c0caf56cc6b164375695f9ac949">viskores::filter::connected_components::CellSetConnectivity</a>, <a class="el" href="classviskores_1_1filter_1_1zfp_1_1ZFPCompressor2D.html#a264917d2862a68be8120c9b104025f08">viskores::filter::zfp::ZFPCompressor2D</a>, <a class="el" href="classviskores_1_1filter_1_1zfp_1_1ZFPCompressor3D.html#a132fae23c3d42ce570237ed26e63781b">viskores::filter::zfp::ZFPCompressor3D</a>, <a class="el" href="classviskores_1_1filter_1_1zfp_1_1ZFPDecompressor1D.html#a3e3fc46890044bebebdb997d4596b4b6">viskores::filter::zfp::ZFPDecompressor1D</a>, <a class="el" href="classviskores_1_1filter_1_1zfp_1_1ZFPDecompressor2D.html#a04fca408c7179478c01f7b71c2a57936">viskores::filter::zfp::ZFPDecompressor2D</a>, <a class="el" href="classviskores_1_1filter_1_1zfp_1_1ZFPDecompressor3D.html#a568ec109f44c9e27b9ad7291b00befb7">viskores::filter::zfp::ZFPDecompressor3D</a>, <a class="el" href="classviskores_1_1filter_1_1field__conversion_1_1CellAverage.html#a228be445eeaf10b8c39237ffc5bdb67f">viskores::filter::field_conversion::CellAverage</a>, <a class="el" href="classviskores_1_1filter_1_1field__conversion_1_1PointAverage.html#ae1bd575486ba890141d9f55679b56427">viskores::filter::field_conversion::PointAverage</a>, <a class="el" href="classviskores_1_1filter_1_1vector__analysis_1_1VectorMagnitude.html#aa4b91bdf2c7dcf787ba005e9761c7c55">viskores::filter::vector_analysis::VectorMagnitude</a>, <a class="el" href="classviskores_1_1filter_1_1geometry__refinement_1_1Tetrahedralize.html#aa4db5acdb7fdc376e299a00986a4e373">viskores::filter::geometry_refinement::Tetrahedralize</a>, <a class="el" href="classviskores_1_1filter_1_1geometry__refinement_1_1Triangulate.html#ade8d951b9a7d8556dd1bb9bebec351fa">viskores::filter::geometry_refinement::Triangulate</a>, <a class="el" href="classviskores_1_1filter_1_1image__processing_1_1ComputeMoments.html#aff954548695123c3f5c836ca402291a3">viskores::filter::image_processing::ComputeMoments</a>, <a class="el" href="classviskores_1_1filter_1_1density__estimate_1_1NDEntropy.html#ab9e059079dc8190d6757bf0e58cd74a3">viskores::filter::density_estimate::NDEntropy</a>, <a class="el" href="classviskores_1_1filter_1_1zfp_1_1ZFPCompressor1D.html#a0fcc44f2caab70568660998550005f63">viskores::filter::zfp::ZFPCompressor1D</a>, <a class="el" href="classviskores_1_1filter_1_1flow_1_1FilterParticleAdvection.html#a49984b6855b11b253e552446b3eb9296">viskores::filter::flow::FilterParticleAdvection</a>, <a class="el" href="classviskores_1_1filter_1_1flow_1_1LagrangianStructures.html#a859f682ef18c2f83f4e185d4a5130a17">viskores::filter::flow::LagrangianStructures</a>, <a class="el" href="classviskores_1_1filter_1_1flow_1_1Lagrangian.html#a3700240edd2cd78b63a42fff8a38ee2a">viskores::filter::flow::Lagrangian</a>, <a class="el" href="classviskores_1_1filter_1_1clean__grid_1_1CleanGrid.html#a72449f8d0d6db5f31fab20eb09338048">viskores::filter::clean_grid::CleanGrid</a>, <a class="el" href="classviskores_1_1filter_1_1flow_1_1StreamSurface.html#a764d76362179b60b159a5a19748945ae">viskores::filter::flow::StreamSurface</a>, <a class="el" href="classviskores_1_1filter_1_1mesh__info_1_1GhostCellClassify.html#a1cd8b2ecb26ef918f02cf8d428e22f33">viskores::filter::mesh_info::GhostCellClassify</a>, <a class="el" href="classviskores_1_1filter_1_1scalar__topology_1_1ExtractTopVolumeContoursFilter.html#a5fed98dcef936546998624f49e38a2ef">viskores::filter::scalar_topology::ExtractTopVolumeContoursFilter</a>, <a class="el" href="classviskores_1_1filter_1_1scalar__topology_1_1SelectTopVolumeBranchesFilter.html#ad7398f7e80741341d4f863c370fe38ba">viskores::filter::scalar_topology::SelectTopVolumeBranchesFilter</a>, <a class="el" href="classviskores_1_1filter_1_1scalar__topology_1_1DistributedBranchDecompositionFilter.html#a6a6dbc57788ae10cb40c63520f994207">viskores::filter::scalar_topology::DistributedBranchDecompositionFilter</a>, and <a class="el" href="classviskores_1_1filter_1_1multi__block_1_1AmrArrays.html#ab1aea767894afabe0ebdc5043a76439b">viskores::filter::multi_block::AmrArrays</a>.</p>

</div>
</div>
<a id="a352e61e711e070ef54291e970bf145dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352e61e711e070ef54291e970bf145dc">&#9670;&nbsp;</a></span>DoExecutePartitions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> viskores::filter::Filter::DoExecutePartitions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>inData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classviskores_1_1filter_1_1scalar__topology_1_1ContourTreeUniformDistributed.html#a7065f972bdfca3f7a426a465f7d517ea">viskores::filter::scalar_topology::ContourTreeUniformDistributed</a>, <a class="el" href="classviskores_1_1filter_1_1multi__block_1_1AmrArrays.html#af75890e087237db8dbd69a500d0d8a32">viskores::filter::multi_block::AmrArrays</a>, <a class="el" href="classviskores_1_1filter_1_1multi__block_1_1MergeDataSets.html#a03c845f90f12248804f1a8cfbdac2674">viskores::filter::multi_block::MergeDataSets</a>, <a class="el" href="classviskores_1_1filter_1_1flow_1_1FilterParticleAdvectionSteadyState.html#ac077d731f0df8d5f1f8aada7e888d6b5">viskores::filter::flow::FilterParticleAdvectionSteadyState&lt; Derived &gt;</a>, <a class="el" href="classviskores_1_1filter_1_1flow_1_1FilterParticleAdvectionSteadyState.html#ac077d731f0df8d5f1f8aada7e888d6b5">viskores::filter::flow::FilterParticleAdvectionSteadyState&lt; ParticleAdvection &gt;</a>, <a class="el" href="classviskores_1_1filter_1_1flow_1_1FilterParticleAdvectionSteadyState.html#ac077d731f0df8d5f1f8aada7e888d6b5">viskores::filter::flow::FilterParticleAdvectionSteadyState&lt; Streamline &gt;</a>, <a class="el" href="classviskores_1_1filter_1_1flow_1_1FilterParticleAdvectionSteadyState.html#ac077d731f0df8d5f1f8aada7e888d6b5">viskores::filter::flow::FilterParticleAdvectionSteadyState&lt; WarpXStreamline &gt;</a>, <a class="el" href="classviskores_1_1filter_1_1flow_1_1FilterParticleAdvectionUnsteadyState.html#ad0592ea6780c91244ef9d64f0f215247">viskores::filter::flow::FilterParticleAdvectionUnsteadyState&lt; Derived &gt;</a>, <a class="el" href="classviskores_1_1filter_1_1flow_1_1FilterParticleAdvectionUnsteadyState.html#ad0592ea6780c91244ef9d64f0f215247">viskores::filter::flow::FilterParticleAdvectionUnsteadyState&lt; PathParticle &gt;</a>, <a class="el" href="classviskores_1_1filter_1_1flow_1_1FilterParticleAdvectionUnsteadyState.html#ad0592ea6780c91244ef9d64f0f215247">viskores::filter::flow::FilterParticleAdvectionUnsteadyState&lt; Pathline &gt;</a>, <a class="el" href="classviskores_1_1filter_1_1scalar__topology_1_1ContourTreeAugmented.html#a57523417b5b6a57b2eaa35dcae710c07">viskores::filter::scalar_topology::ContourTreeAugmented</a>, <a class="el" href="classviskores_1_1filter_1_1density__estimate_1_1Histogram.html#adf720c26224ab467a7312924b950ab4e">viskores::filter::density_estimate::Histogram</a>, <a class="el" href="classviskores_1_1filter_1_1scalar__topology_1_1ExtractTopVolumeContoursFilter.html#a27694ff3d4b1b6ef4f70c89d48dabfd3">viskores::filter::scalar_topology::ExtractTopVolumeContoursFilter</a>, <a class="el" href="classviskores_1_1filter_1_1scalar__topology_1_1SelectTopVolumeBranchesFilter.html#a8ebd5c82517f3295a9388b7c64bac4c0">viskores::filter::scalar_topology::SelectTopVolumeBranchesFilter</a>, <a class="el" href="classviskores_1_1filter_1_1density__estimate_1_1Statistics.html#ae5415610b15f26053e02c3c75dce1dac">viskores::filter::density_estimate::Statistics</a>, and <a class="el" href="classviskores_1_1filter_1_1scalar__topology_1_1DistributedBranchDecompositionFilter.html#a225e7430cb3167d32503a2e3b70f3713">viskores::filter::scalar_topology::DistributedBranchDecompositionFilter</a>.</p>

</div>
</div>
<a id="aa9a860f4a72ae4b6330d1082cdbedfe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a860f4a72ae4b6330d1082cdbedfe1">&#9670;&nbsp;</a></span>Execute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> viskores::filter::Filter::Execute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the filter on the input and produces a result dataset. </p>
<p>On success, this the dataset produced. On error, <code><a class="el" href="classviskores_1_1cont_1_1ErrorExecution.html" title="This class is thrown in the control environment whenever an error occurs in the execution environment...">viskores::cont::ErrorExecution</a></code> will be thrown. </p>

</div>
</div>
<a id="ab3680ceaaa184d3c4ef12bb5da7cc95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3680ceaaa184d3c4ef12bb5da7cc95d">&#9670;&nbsp;</a></span>Execute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> viskores::filter::Filter::Execute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the filter on the input PartitionedDataSet and produces a result PartitionedDataSet. </p>
<p>On success, this the dataset produced. On error, <code><a class="el" href="classviskores_1_1cont_1_1ErrorExecution.html" title="This class is thrown in the control environment whenever an error occurs in the execution environment...">viskores::cont::ErrorExecution</a></code> will be thrown. </p>

</div>
</div>
<a id="a274ba00026b4ed9f577dd34e2c440d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274ba00026b4ed9f577dd34e2c440d1e">&#9670;&nbsp;</a></span>GetActiveCoordinateSystemIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> viskores::filter::Filter::GetActiveCoordinateSystemIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the coordinate system index to make active to use when processing the input <code><a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">viskores::cont::DataSet</a></code>. </p>
<p>This is used primarily by the <a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a> to select the coordinate system to use as a field when <code>UseCoordinateSystemAsField</code> is true. </p>

</div>
</div>
<a id="ac3bfd1ea8b44574b3263ab662514f6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bfd1ea8b44574b3263ab662514f6f5">&#9670;&nbsp;</a></span>GetActiveFieldAssociation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a> viskores::filter::Filter::GetActiveFieldAssociation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies a field to operate on. </p>
<p>The number of input fields (or whether the filter operates on input fields at all) is specific to each particular filter. </p>

</div>
</div>
<a id="a4d1eb94b67dec54c5455b915b9fa262a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1eb94b67dec54c5455b915b9fa262a">&#9670;&nbsp;</a></span>GetActiveFieldName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; viskores::filter::Filter::GetActiveFieldName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies a field to operate on. </p>
<p>The number of input fields (or whether the filter operates on input fields at all) is specific to each particular filter. </p>

</div>
</div>
<a id="a01866782b46fb387b11192cdbefa1ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01866782b46fb387b11192cdbefa1ca6">&#9670;&nbsp;</a></span>GetFieldFromDataSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a>&amp; viskores::filter::Filter::GetFieldFromDataSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve an input field from a <code><a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">viskores::cont::DataSet</a></code> object. </p>
<p>When a filter operates on fields, it should use this method to get the input fields that the use has selected with <code><a class="el" href="classviskores_1_1filter_1_1Filter.html#a80a3b66fc0d7bd5a60b8ee17606f780e" title="Specifies a field to operate on.">SetActiveField()</a></code> and related methods. </p>

</div>
</div>
<a id="a08454a8acc7224b8ee4f7481a390c23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08454a8acc7224b8ee4f7481a390c23a">&#9670;&nbsp;</a></span>GetFieldFromDataSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classviskores_1_1cont_1_1Field.html">viskores::cont::Field</a>&amp; viskores::filter::Filter::GetFieldFromDataSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve an input field from a <code><a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">viskores::cont::DataSet</a></code> object. </p>
<p>When a filter operates on fields, it should use this method to get the input fields that the use has selected with <code><a class="el" href="classviskores_1_1filter_1_1Filter.html#a80a3b66fc0d7bd5a60b8ee17606f780e" title="Specifies a field to operate on.">SetActiveField()</a></code> and related methods. </p>

</div>
</div>
<a id="a0aef83ae99b2dc7d8c0bdd549f947da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aef83ae99b2dc7d8c0bdd549f947da3">&#9670;&nbsp;</a></span>GetFieldsToPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1filter_1_1FieldSelection.html">viskores::filter::FieldSelection</a>&amp; viskores::filter::Filter::GetFieldsToPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify which fields get passed from input to output. </p>
<p>After a filter successfully executes and returns a new data set, fields are mapped from input to output. Depending on what operation the filter does, this could be a simple shallow copy of an array, or it could be a computed operation. You can control which fields are passed (and equivalently which are not) with this parameter.</p>
<p>By default, all fields are passed during execution. </p>

</div>
</div>
<a id="a60e13f0b1257deb056d46979ef3e9e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e13f0b1257deb056d46979ef3e9e1f">&#9670;&nbsp;</a></span>GetFieldsToPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html">viskores::filter::FieldSelection</a>&amp; viskores::filter::Filter::GetFieldsToPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify which fields get passed from input to output. </p>
<p>After a filter successfully executes and returns a new data set, fields are mapped from input to output. Depending on what operation the filter does, this could be a simple shallow copy of an array, or it could be a computed operation. You can control which fields are passed (and equivalently which are not) with this parameter.</p>
<p>By default, all fields are passed during execution. </p>

</div>
</div>
<a id="a4582630898b66bf518dab0a7c9ca8eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4582630898b66bf518dab0a7c9ca8eb3">&#9670;&nbsp;</a></span>GetNumberOfActiveFields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> viskores::filter::Filter::GetNumberOfActiveFields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of active fields currently set. </p>
<p>The general interface to <code><a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a></code> allows a user to set an arbitrary number of active fields (indexed 0 and on). This method returns the number of active fields that are set. Note that the filter implementation is free to ignore any active fields it does not support. Also note that an active field can be set to be either a named field or a coordinate system. </p>

</div>
</div>
<a id="ab86f7468798f9483610ddd4c5135bdd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86f7468798f9483610ddd4c5135bdd4">&#9670;&nbsp;</a></span>GetOutputFieldName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; viskores::filter::Filter::GetOutputFieldName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the name of the output field generated. </p>
<p>Not all filters create an output field. </p>

</div>
</div>
<a id="a2a1fa9dcbd16d3e51a6001210be0c431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1fa9dcbd16d3e51a6001210be0c431">&#9670;&nbsp;</a></span>GetPassCoordinateSystems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::filter::Filter::GetPassCoordinateSystems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify whether to always pass coordinate systems. </p>
<p><code><a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html" title="Manages a coordinate system for a DataSet.">viskores::cont::CoordinateSystem</a></code>s in a <code>DataSet</code> are really just point fields marked as being a coordinate system. Thus, a coordinate system is passed if and only if the associated field is passed.</p>
<p>By default, the filter will pass all fields associated with a coordinate system regardless of the <code>FieldsToPass</code> marks the field as passing. If this option is set to <code>false</code>, then coordinate systems will only be passed if it is marked so by <code>FieldsToPass</code>. </p>

</div>
</div>
<a id="a0e39eecdfc999f4cfc28b4784d72f193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e39eecdfc999f4cfc28b4784d72f193">&#9670;&nbsp;</a></span>GetRunMultiThreadedFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::filter::Filter::GetRunMultiThreadedFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81c180327e6837ccfec582fa8a5abcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c180327e6837ccfec582fa8a5abcbd">&#9670;&nbsp;</a></span>GetThreadsPerCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> viskores::filter::Filter::GetThreadsPerCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a429ef4ca7f45a4ed42ed25dc2564c310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429ef4ca7f45a4ed42ed25dc2564c310">&#9670;&nbsp;</a></span>GetThreadsPerGPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> viskores::filter::Filter::GetThreadsPerGPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d47bb1b58cf07941c904ec5b3f43d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d47bb1b58cf07941c904ec5b3f43d35">&#9670;&nbsp;</a></span>GetUseCoordinateSystemAsField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::filter::Filter::GetUseCoordinateSystemAsField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies whether to use point coordinates as the input field. </p>
<p>When true, the values for the active field are ignored and the active coordinate system is used instead. </p>

</div>
</div>
<a id="ac746ba8f4227c8b708dd4cb44f42c81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac746ba8f4227c8b708dd4cb44f42c81d">&#9670;&nbsp;</a></span>MapFieldsOntoOutput() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldMapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::MapFieldsOntoOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html">viskores::filter::FieldSelection</a> &amp;&#160;</td>
          <td class="paramname"><em>fieldSelection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldMapper &amp;&amp;&#160;</td>
          <td class="paramname"><em>fieldMapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9da1903bd412bfed514cea6e8253b545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da1903bd412bfed514cea6e8253b545">&#9670;&nbsp;</a></span>MapFieldsOntoOutput() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldMapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::MapFieldsOntoOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html">viskores::filter::FieldSelection</a> &amp;&#160;</td>
          <td class="paramname"><em>fieldSelection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldMapper &amp;&amp;&#160;</td>
          <td class="paramname"><em>fieldMapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b70e2191ed595134f2a3887e1a49eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b70e2191ed595134f2a3887e1a49eb8">&#9670;&nbsp;</a></span>ResizeIfNeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::ResizeIfNeeded </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index_st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36e349933e2462b9ff713ed5be03498f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e349933e2462b9ff713ed5be03498f">&#9670;&nbsp;</a></span>SetActiveCoordinateSystem() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetActiveCoordinateSystem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>coord_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the coordinate system index to make active to use when processing the input <code><a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">viskores::cont::DataSet</a></code>. </p>
<p>This is used primarily by the <a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a> to select the coordinate system to use as a field when <code>UseCoordinateSystemAsField</code> is true. </p>

</div>
</div>
<a id="aeb0368295acf4a60c5e4183185db3743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0368295acf4a60c5e4183185db3743">&#9670;&nbsp;</a></span>SetActiveCoordinateSystem() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetActiveCoordinateSystem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>coord_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the coordinate system index to make active to use when processing the input <code><a class="el" href="classviskores_1_1cont_1_1DataSet.html" title="Contains and manages the geometric data structures that Viskores operates on.">viskores::cont::DataSet</a></code>. </p>
<p>This is used primarily by the <a class="el" href="classviskores_1_1filter_1_1Filter.html" title="Base class for all filters.">Filter</a> to select the coordinate system to use as a field when <code>UseCoordinateSystemAsField</code> is true. </p>

</div>
</div>
<a id="a80a3b66fc0d7bd5a60b8ee17606f780e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a3b66fc0d7bd5a60b8ee17606f780e">&#9670;&nbsp;</a></span>SetActiveField() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetActiveField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a>&#160;</td>
          <td class="paramname"><em>association</em> = <code><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bdaed36a1ef76a59ee3f15180e0441188ad">viskores::cont::Field::Association::Any</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies a field to operate on. </p>
<p>The number of input fields (or whether the filter operates on input fields at all) is specific to each particular filter. </p>

</div>
</div>
<a id="ac45f9d93d75896829c6f661cc104b639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45f9d93d75896829c6f661cc104b639">&#9670;&nbsp;</a></span>SetActiveField() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetActiveField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a>&#160;</td>
          <td class="paramname"><em>association</em> = <code><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bdaed36a1ef76a59ee3f15180e0441188ad">viskores::cont::Field::Association::Any</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies a field to operate on. </p>
<p>The number of input fields (or whether the filter operates on input fields at all) is specific to each particular filter. </p>

</div>
</div>
<a id="a730f729313e02e0764d75c889b0cec9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730f729313e02e0764d75c889b0cec9e">&#9670;&nbsp;</a></span>SetFieldsToPass() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetFieldsToPass </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a>&#160;</td>
          <td class="paramname"><em>association</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7">viskores::filter::FieldSelection::Mode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7ae0626222614bdee31951d84c64e5e9ff">viskores::filter::FieldSelection::Mode::Select</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify which fields get passed from input to output. </p>
<p>After a filter successfully executes and returns a new data set, fields are mapped from input to output. Depending on what operation the filter does, this could be a simple shallow copy of an array, or it could be a computed operation. You can control which fields are passed (and equivalently which are not) with this parameter.</p>
<p>By default, all fields are passed during execution. </p>

</div>
</div>
<a id="a9891d36816b7461e022e3301d8eac56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9891d36816b7461e022e3301d8eac56c">&#9670;&nbsp;</a></span>SetFieldsToPass() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetFieldsToPass </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7">viskores::filter::FieldSelection::Mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify which fields get passed from input to output. </p>
<p>After a filter successfully executes and returns a new data set, fields are mapped from input to output. Depending on what operation the filter does, this could be a simple shallow copy of an array, or it could be a computed operation. You can control which fields are passed (and equivalently which are not) with this parameter.</p>
<p>By default, all fields are passed during execution. </p>

</div>
</div>
<a id="a40a4dc01cbe1230075cdad9467a1e9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a4dc01cbe1230075cdad9467a1e9e5">&#9670;&nbsp;</a></span>SetFieldsToPass() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetFieldsToPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html">viskores::filter::FieldSelection</a> &amp;&#160;</td>
          <td class="paramname"><em>fieldsToPass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify which fields get passed from input to output. </p>
<p>After a filter successfully executes and returns a new data set, fields are mapped from input to output. Depending on what operation the filter does, this could be a simple shallow copy of an array, or it could be a computed operation. You can control which fields are passed (and equivalently which are not) with this parameter.</p>
<p>By default, all fields are passed during execution. </p>

</div>
</div>
<a id="a4d9fcfbff4e50921c90f6a633216c8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9fcfbff4e50921c90f6a633216c8f3">&#9670;&nbsp;</a></span>SetFieldsToPass() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetFieldsToPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html">viskores::filter::FieldSelection</a> &amp;&#160;</td>
          <td class="paramname"><em>fieldsToPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7">viskores::filter::FieldSelection::Mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66de3cad6dac78a51571d061895547ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66de3cad6dac78a51571d061895547ec">&#9670;&nbsp;</a></span>SetFieldsToPass() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetFieldsToPass </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::pair&lt; std::string, <a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7">viskores::filter::FieldSelection::Mode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7ae0626222614bdee31951d84c64e5e9ff">viskores::filter::FieldSelection::Mode::Select</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify which fields get passed from input to output. </p>
<p>After a filter successfully executes and returns a new data set, fields are mapped from input to output. Depending on what operation the filter does, this could be a simple shallow copy of an array, or it could be a computed operation. You can control which fields are passed (and equivalently which are not) with this parameter.</p>
<p>By default, all fields are passed during execution. </p>

</div>
</div>
<a id="a540ebc458e434da096a71471e22eb2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540ebc458e434da096a71471e22eb2fc">&#9670;&nbsp;</a></span>SetFieldsToPass() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetFieldsToPass </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7">viskores::filter::FieldSelection::Mode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7ae0626222614bdee31951d84c64e5e9ff">viskores::filter::FieldSelection::Mode::Select</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify which fields get passed from input to output. </p>
<p>After a filter successfully executes and returns a new data set, fields are mapped from input to output. Depending on what operation the filter does, this could be a simple shallow copy of an array, or it could be a computed operation. You can control which fields are passed (and equivalently which are not) with this parameter.</p>
<p>By default, all fields are passed during execution. </p>

</div>
</div>
<a id="a7e744f004cb1e408b80e143da87b7732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e744f004cb1e408b80e143da87b7732">&#9670;&nbsp;</a></span>SetFieldsToPass() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetFieldsToPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1filter_1_1FieldSelection.html">viskores::filter::FieldSelection</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>fieldsToPass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify which fields get passed from input to output. </p>
<p>After a filter successfully executes and returns a new data set, fields are mapped from input to output. Depending on what operation the filter does, this could be a simple shallow copy of an array, or it could be a computed operation. You can control which fields are passed (and equivalently which are not) with this parameter.</p>
<p>By default, all fields are passed during execution. </p>

</div>
</div>
<a id="a036a2822a21ac92b1c0266a9277bffa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036a2822a21ac92b1c0266a9277bffa0">&#9670;&nbsp;</a></span>SetInvoker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetInvoker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1Invoker.html">viskores::cont::Invoker</a>&#160;</td>
          <td class="paramname"><em>inv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify the <a class="el" href="structviskores_1_1cont_1_1Invoker.html" title="Allows launching any worklet without a dispatcher.">viskores::cont::Invoker</a> to be used to execute worklets by this filter instance. </p>
<p>Overriding the default allows callers to control which device adapters a filter uses. </p>

</div>
</div>
<a id="a337a15fc9298d0edaae5dc7b9502d27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337a15fc9298d0edaae5dc7b9502d27e">&#9670;&nbsp;</a></span>SetOutputFieldName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetOutputFieldName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the name of the output field generated. </p>
<p>Not all filters create an output field. </p>

</div>
</div>
<a id="a6aeebaa3e10c7649f78d89ca3a56cd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aeebaa3e10c7649f78d89ca3a56cd19">&#9670;&nbsp;</a></span>SetPassCoordinateSystems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetPassCoordinateSystems </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify whether to always pass coordinate systems. </p>
<p><code><a class="el" href="classviskores_1_1cont_1_1CoordinateSystem.html" title="Manages a coordinate system for a DataSet.">viskores::cont::CoordinateSystem</a></code>s in a <code>DataSet</code> are really just point fields marked as being a coordinate system. Thus, a coordinate system is passed if and only if the associated field is passed.</p>
<p>By default, the filter will pass all fields associated with a coordinate system regardless of the <code>FieldsToPass</code> marks the field as passing. If this option is set to <code>false</code>, then coordinate systems will only be passed if it is marked so by <code>FieldsToPass</code>. </p>

</div>
</div>
<a id="a0ab0ac78734df9709e8af0025ed21fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab0ac78734df9709e8af0025ed21fbd">&#9670;&nbsp;</a></span>SetRunMultiThreadedFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetRunMultiThreadedFilter </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbbf6ee581d811552650786200f550bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbbf6ee581d811552650786200f550bd">&#9670;&nbsp;</a></span>SetThreadsPerCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetThreadsPerCPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numThreads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="add6202c185e6773d7450b12605c7da7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6202c185e6773d7450b12605c7da7c">&#9670;&nbsp;</a></span>SetThreadsPerGPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetThreadsPerGPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numThreads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a95ecffbe06ddfeef4b05d126795474cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ecffbe06ddfeef4b05d126795474cd">&#9670;&nbsp;</a></span>SetUseCoordinateSystemAsField() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetUseCoordinateSystemAsField </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies whether to use point coordinates as the input field. </p>
<p>When true, the values for the active field are ignored and the active coordinate system is used instead. </p>

</div>
</div>
<a id="a0e82e0de463f8ffb4ce758858a60849c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e82e0de463f8ffb4ce758858a60849c">&#9670;&nbsp;</a></span>SetUseCoordinateSystemAsField() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::filter::Filter::SetUseCoordinateSystemAsField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies whether to use point coordinates as the input field. </p>
<p>When true, the values for the active field are ignored and the active coordinate system is used instead. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a83ffaf24d517115ca572a9add34d5171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ffaf24d517115ca572a9add34d5171">&#9670;&nbsp;</a></span>ActiveCoordinateSystemIndices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&gt; viskores::filter::Filter::ActiveCoordinateSystemIndices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f5dc9917652a94eb89bc70fb0cac3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5dc9917652a94eb89bc70fb0cac3c7">&#9670;&nbsp;</a></span>ActiveFieldAssociation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classviskores_1_1cont_1_1Field.html#a5f604e4f44f75cf1cbe6da4f986975bd">viskores::cont::Field::Association</a>&gt; viskores::filter::Filter::ActiveFieldAssociation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac42a23f42d4cfef371ad179952f45bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42a23f42d4cfef371ad179952f45bda">&#9670;&nbsp;</a></span>ActiveFieldNames</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; viskores::filter::Filter::ActiveFieldNames</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adc67addff0017aa61269e66e901c097a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc67addff0017aa61269e66e901c097a">&#9670;&nbsp;</a></span>FieldsToPass</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1filter_1_1FieldSelection.html">viskores::filter::FieldSelection</a> viskores::filter::Filter::FieldsToPass = <a class="el" href="classviskores_1_1filter_1_1FieldSelection.html#adda382c1a46ea0bbf4ede55f836000d7ab1c94ca2fbc3e78fc30069c8d0f01680">viskores::filter::FieldSelection::Mode::All</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a122f8d1ef77b7bb7f87c5279bc8f8f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122f8d1ef77b7bb7f87c5279bc8f8f12">&#9670;&nbsp;</a></span>Invoke</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviskores_1_1cont_1_1Invoker.html">viskores::cont::Invoker</a> viskores::filter::Filter::Invoke</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af44ac016e520929fbf7fd7b814a873ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44ac016e520929fbf7fd7b814a873ae">&#9670;&nbsp;</a></span>NumThreadsPerCPU</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> viskores::filter::Filter::NumThreadsPerCPU = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a33c893882e8ba18986e605902a600dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c893882e8ba18986e605902a600dfd">&#9670;&nbsp;</a></span>NumThreadsPerGPU</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> viskores::filter::Filter::NumThreadsPerGPU = 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6077d8d2d079d389807586da7f3d8924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6077d8d2d079d389807586da7f3d8924">&#9670;&nbsp;</a></span>OutputFieldName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string viskores::filter::Filter::OutputFieldName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d58f563d76dc6333edf88462f77e773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d58f563d76dc6333edf88462f77e773">&#9670;&nbsp;</a></span>PassCoordinateSystems</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::filter::Filter::PassCoordinateSystems = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dce4a6f133924ae99e1f51736122c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dce4a6f133924ae99e1f51736122c6e">&#9670;&nbsp;</a></span>RunFilterWithMultipleThreads</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::filter::Filter::RunFilterWithMultipleThreads = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8387639f912e86ddb160776d4f9d968f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8387639f912e86ddb160776d4f9d968f">&#9670;&nbsp;</a></span>UseCoordinateSystemAsField</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; viskores::filter::Filter::UseCoordinateSystemAsField</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Filter_8h_source.html">Filter.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassviskores_1_1cont_1_1DataSet_html"><div class="ttname"><a href="classviskores_1_1cont_1_1DataSet.html">viskores::cont::DataSet</a></div><div class="ttdoc">Contains and manages the geometric data structures that Viskores operates on.</div><div class="ttdef"><b>Definition:</b> DataSet.h:66</div></div>
<div class="ttc" id="aclassviskores_1_1filter_1_1Filter_html_a6f56120132ad471ae092feedad608118"><div class="ttname"><a href="classviskores_1_1filter_1_1Filter.html#a6f56120132ad471ae092feedad608118">viskores::filter::Filter::CreateResult</a></div><div class="ttdeci">viskores::cont::DataSet CreateResult(const viskores::cont::DataSet &amp;inDataSet) const</div><div class="ttdoc">Create the output data set for DoExecute.</div></div>
<div class="ttc" id="aclassviskores_1_1filter_1_1Filter_html_aa9a860f4a72ae4b6330d1082cdbedfe1"><div class="ttname"><a href="classviskores_1_1filter_1_1Filter.html#aa9a860f4a72ae4b6330d1082cdbedfe1">viskores::filter::Filter::Execute</a></div><div class="ttdeci">viskores::cont::DataSet Execute(const viskores::cont::DataSet &amp;input)</div><div class="ttdoc">Executes the filter on the input and produces a result dataset.</div></div>
<div class="ttc" id="aExportMacros_8h_html_ae47b94fbf1d55103fa9aeff192d8404b"><div class="ttname"><a href="ExportMacros_8h.html#ae47b94fbf1d55103fa9aeff192d8404b">VISKORES_CONT</a></div><div class="ttdeci">#define VISKORES_CONT</div><div class="ttdef"><b>Definition:</b> ExportMacros.h:65</div></div>
<div class="ttc" id="aclassviskores_1_1cont_1_1PartitionedDataSet_html"><div class="ttname"><a href="classviskores_1_1cont_1_1PartitionedDataSet.html">viskores::cont::PartitionedDataSet</a></div><div class="ttdoc">Comprises a set of viskores::cont::DataSet objects.</div><div class="ttdef"><b>Definition:</b> PartitionedDataSet.h:34</div></div>
<div class="ttc" id="aclassviskores_1_1filter_1_1Filter_html_a40a4dc01cbe1230075cdad9467a1e9e5"><div class="ttname"><a href="classviskores_1_1filter_1_1Filter.html#a40a4dc01cbe1230075cdad9467a1e9e5">viskores::filter::Filter::SetFieldsToPass</a></div><div class="ttdeci">void SetFieldsToPass(const viskores::filter::FieldSelection &amp;fieldsToPass)</div><div class="ttdoc">Specify which fields get passed from input to output.</div></div>
<div class="ttc" id="aclassviskores_1_1cont_1_1UnknownCellSet_html"><div class="ttname"><a href="classviskores_1_1cont_1_1UnknownCellSet.html">viskores::cont::UnknownCellSet</a></div><div class="ttdoc">A CellSet of an unknown type.</div><div class="ttdef"><b>Definition:</b> UnknownCellSet.h:56</div></div>
<div class="ttc" id="aclassviskores_1_1filter_1_1contour_1_1Contour_html"><div class="ttname"><a href="classviskores_1_1filter_1_1contour_1_1Contour.html">viskores::filter::contour::Contour</a></div><div class="ttdoc">Generate contours or isosurfaces from a region of space.</div><div class="ttdef"><b>Definition:</b> Contour.h:43</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
