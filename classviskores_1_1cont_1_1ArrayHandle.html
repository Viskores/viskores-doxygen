<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Viskores: viskores::cont::ArrayHandle&lt; T, StorageTag_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Viskores
   &#160;<span id="projectnumber">0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceviskores.html">viskores</a></li><li class="navelem"><a class="el" href="namespaceviskores_1_1cont.html">cont</a></li><li class="navelem"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classviskores_1_1cont_1_1ArrayHandle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">viskores::cont::ArrayHandle&lt; T, StorageTag_ &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Manages an array-worth of data.  
 <a href="classviskores_1_1cont_1_1ArrayHandle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ArrayHandle_8h_source.html">ArrayHandle.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for viskores::cont::ArrayHandle&lt; T, StorageTag_ &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classviskores_1_1cont_1_1ArrayHandle.png" usemap="#viskores::cont::ArrayHandle_3C_20T_2C_20StorageTag_5F_20_3E_map" alt=""/>
  <map id="viskores::cont::ArrayHandle_3C_20T_2C_20StorageTag_5F_20_3E_map" name="viskores::cont::ArrayHandle_3C_20T_2C_20StorageTag_5F_20_3E_map">
<area href="classviskores_1_1cont_1_1ArrayHandleImplicit.html" alt="viskores::cont::ArrayHandleImplicit&lt; detail::PhiloxFunctor &gt;" shape="rect" coords="0,112,609,136"/>
<area href="classviskores_1_1cont_1_1ArrayHandleCartesianProduct.html" title="ArrayHandleCartesianProduct is a specialization of ArrayHandle." alt="viskores::cont::ArrayHandleCartesianProduct&lt; FirstHandleType, SecondHandleType, ThirdHandleType &gt;" shape="rect" coords="619,112,1228,136"/>
<area href="classviskores_1_1cont_1_1ArrayHandleDecorator.html" title="A fancy ArrayHandle that can be used to modify the results from one or more source ArrayHandle." alt="viskores::cont::ArrayHandleDecorator&lt; DecoratorImplT, ArrayTs &gt;" shape="rect" coords="1238,112,1847,136"/>
<area href="classviskores_1_1cont_1_1ArrayHandleDiscard.html" title="ArrayHandleDiscard is a write-only array that discards all data written to it." alt="viskores::cont::ArrayHandleDiscard&lt; ValueType_ &gt;" shape="rect" coords="1857,112,2466,136"/>
<area href="classviskores_1_1cont_1_1ArrayHandleImplicit.html" title="An ArrayHandle that computes values on the fly." alt="viskores::cont::ArrayHandleImplicit&lt; FunctorType &gt;" shape="rect" coords="2476,112,3085,136"/>
<area href="classviskores_1_1cont_1_1ArrayHandleZip.html" title="ArrayHandleZip is a specialization of ArrayHandle." alt="viskores::cont::ArrayHandleZip&lt; FirstHandleType, SecondHandleType &gt;" shape="rect" coords="3095,112,3704,136"/>
<area href="classviskores_1_1cont_1_1ArrayHandleRandomUniformBits.html" title="An ArrayHandle that provides a source of random bits." alt="viskores::cont::ArrayHandleRandomUniformBits" shape="rect" coords="0,168,609,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0bea7542605b4a33146564e266af841e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a> = T</td></tr>
<tr class="separator:a0bea7542605b4a33146564e266af841e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c6816987572574d01d16764393bc1e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> = StorageTag_</td></tr>
<tr class="separator:a62c6816987572574d01d16764393bc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa944cb30d836f84b06d2262a66c65327"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aa944cb30d836f84b06d2262a66c65327">StorageType</a> = viskores::cont::internal::Storage&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt;</td></tr>
<tr class="separator:aa944cb30d836f84b06d2262a66c65327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3edd88546709bdfaa2910a8cb35bbc0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#af3edd88546709bdfaa2910a8cb35bbc0">ReadPortalType</a> = typename StorageType::ReadPortalType</td></tr>
<tr class="memdesc:af3edd88546709bdfaa2910a8cb35bbc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of portal used when accessing data in a read-only mode.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#af3edd88546709bdfaa2910a8cb35bbc0">More...</a><br /></td></tr>
<tr class="separator:af3edd88546709bdfaa2910a8cb35bbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa713511405938d93164978905f624d9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aaa713511405938d93164978905f624d9">WritePortalType</a> = typename StorageType::WritePortalType</td></tr>
<tr class="memdesc:aaa713511405938d93164978905f624d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of portal used when accessing data in a read-write mode.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#aaa713511405938d93164978905f624d9">More...</a><br /></td></tr>
<tr class="separator:aaa713511405938d93164978905f624d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa3c15396a60b6dd0718efa8a4915f938"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aa3c15396a60b6dd0718efa8a4915f938">ArrayHandle</a> ()</td></tr>
<tr class="memdesc:aa3c15396a60b6dd0718efa8a4915f938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#aa3c15396a60b6dd0718efa8a4915f938">More...</a><br /></td></tr>
<tr class="separator:aa3c15396a60b6dd0718efa8a4915f938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8e2f577861f159cd427396d72eac8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a6c8e2f577861f159cd427396d72eac8c">ArrayHandle</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt; &amp;src)</td></tr>
<tr class="memdesc:a6c8e2f577861f159cd427396d72eac8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a6c8e2f577861f159cd427396d72eac8c">More...</a><br /></td></tr>
<tr class="separator:a6c8e2f577861f159cd427396d72eac8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3c24ad9845820248569bc1d60f011a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a9e3c24ad9845820248569bc1d60f011a">ArrayHandle</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt; &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a9e3c24ad9845820248569bc1d60f011a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a9e3c24ad9845820248569bc1d60f011a">More...</a><br /></td></tr>
<tr class="separator:a9e3c24ad9845820248569bc1d60f011a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137a796cc8d484db4b58c03745951592"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a137a796cc8d484db4b58c03745951592">ArrayHandle</a> (const std::vector&lt; viskores::cont::internal::Buffer &gt; &amp;buffers)</td></tr>
<tr class="memdesc:a137a796cc8d484db4b58c03745951592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special constructor for subclass specializations that need to set the initial state array.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a137a796cc8d484db4b58c03745951592">More...</a><br /></td></tr>
<tr class="separator:a137a796cc8d484db4b58c03745951592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ed4b37011b3985234ee4e2d086bce1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a36ed4b37011b3985234ee4e2d086bce1">ArrayHandle</a> (std::vector&lt; viskores::cont::internal::Buffer &gt; &amp;&amp;buffers) noexcept</td></tr>
<tr class="memdesc:a36ed4b37011b3985234ee4e2d086bce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special constructor for subclass specializations that need to set the initial state array.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a36ed4b37011b3985234ee4e2d086bce1">More...</a><br /></td></tr>
<tr class="separator:a36ed4b37011b3985234ee4e2d086bce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb86aa9e0165b8b2711aee2d821028ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abb86aa9e0165b8b2711aee2d821028ad">~ArrayHandle</a> ()</td></tr>
<tr class="memdesc:abb86aa9e0165b8b2711aee2d821028ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs an empty <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#abb86aa9e0165b8b2711aee2d821028ad">More...</a><br /></td></tr>
<tr class="separator:abb86aa9e0165b8b2711aee2d821028ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349b67ec5fc601dc01da752295b6830b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a349b67ec5fc601dc01da752295b6830b">operator=</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt; &amp;src)</td></tr>
<tr class="memdesc:a349b67ec5fc601dc01da752295b6830b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shallow copies an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a349b67ec5fc601dc01da752295b6830b">More...</a><br /></td></tr>
<tr class="separator:a349b67ec5fc601dc01da752295b6830b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd27f9878c3098847bbd474295303f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#adbd27f9878c3098847bbd474295303f0">operator=</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt; &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:adbd27f9878c3098847bbd474295303f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move and Assignment of an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#adbd27f9878c3098847bbd474295303f0">More...</a><br /></td></tr>
<tr class="separator:adbd27f9878c3098847bbd474295303f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f94267f3bd4da6c80690f90417ad626"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a3f94267f3bd4da6c80690f90417ad626">operator==</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a3f94267f3bd4da6c80690f90417ad626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like a pointer, two <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>s are considered equal if they point to the same location in memory.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a3f94267f3bd4da6c80690f90417ad626">More...</a><br /></td></tr>
<tr class="separator:a3f94267f3bd4da6c80690f90417ad626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff479adc4188ecbedb681d13d280ddb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a2ff479adc4188ecbedb681d13d280ddb">operator!=</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt; &amp;rhs) const</td></tr>
<tr class="separator:a2ff479adc4188ecbedb681d13d280ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a30f1b7549fec2e41edac59de3b4e4"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ST &gt; </td></tr>
<tr class="memitem:a07a30f1b7549fec2e41edac59de3b4e4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a07a30f1b7549fec2e41edac59de3b4e4">operator==</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle</a>&lt; VT, ST &gt; &amp;) const</td></tr>
<tr class="separator:a07a30f1b7549fec2e41edac59de3b4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42793148ca4d0b18f12c8aa8d9cb119"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ST &gt; </td></tr>
<tr class="memitem:aa42793148ca4d0b18f12c8aa8d9cb119"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aa42793148ca4d0b18f12c8aa8d9cb119">operator!=</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle</a>&lt; VT, ST &gt; &amp;) const</td></tr>
<tr class="separator:aa42793148ca4d0b18f12c8aa8d9cb119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda0dd50a677971a714555444402eceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aa944cb30d836f84b06d2262a66c65327">StorageType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aeda0dd50a677971a714555444402eceb">GetStorage</a> () const</td></tr>
<tr class="memdesc:aeda0dd50a677971a714555444402eceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the storage.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#aeda0dd50a677971a714555444402eceb">More...</a><br /></td></tr>
<tr class="separator:aeda0dd50a677971a714555444402eceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d28220785ee72f97469b29a7b587443"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#af3edd88546709bdfaa2910a8cb35bbc0">ReadPortalType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a7d28220785ee72f97469b29a7b587443">ReadPortal</a> () const</td></tr>
<tr class="memdesc:a7d28220785ee72f97469b29a7b587443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an array portal that can be used in the control environment.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a7d28220785ee72f97469b29a7b587443">More...</a><br /></td></tr>
<tr class="separator:a7d28220785ee72f97469b29a7b587443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1882410ce1a58fff86f313895806fac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#af3edd88546709bdfaa2910a8cb35bbc0">ReadPortalType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#ae1882410ce1a58fff86f313895806fac">ReadPortal</a> (<a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;token) const</td></tr>
<tr class="memdesc:ae1882410ce1a58fff86f313895806fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of portal used when accessing data in a read-only mode.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#ae1882410ce1a58fff86f313895806fac">More...</a><br /></td></tr>
<tr class="separator:ae1882410ce1a58fff86f313895806fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5d93aa07c249d3a5a375a8c8229eff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aaa713511405938d93164978905f624d9">WritePortalType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff">WritePortal</a> () const</td></tr>
<tr class="memdesc:abe5d93aa07c249d3a5a375a8c8229eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an array portal that can be used in the control environment.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#abe5d93aa07c249d3a5a375a8c8229eff">More...</a><br /></td></tr>
<tr class="separator:abe5d93aa07c249d3a5a375a8c8229eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af502debf665a670a6a389aa7fba2069f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aaa713511405938d93164978905f624d9">WritePortalType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#af502debf665a670a6a389aa7fba2069f">WritePortal</a> (<a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;token) const</td></tr>
<tr class="memdesc:af502debf665a670a6a389aa7fba2069f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an array portal that can be used in the control environment.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#af502debf665a670a6a389aa7fba2069f">More...</a><br /></td></tr>
<tr class="separator:af502debf665a670a6a389aa7fba2069f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad084795021c8600def1edbc8b1872921"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">GetNumberOfValues</a> () const</td></tr>
<tr class="memdesc:ad084795021c8600def1edbc8b1872921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of entries in the array.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#ad084795021c8600def1edbc8b1872921">More...</a><br /></td></tr>
<tr class="separator:ad084795021c8600def1edbc8b1872921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05172888cda84f9ce53984eb80d4724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#ac05172888cda84f9ce53984eb80d4724">GetNumberOfComponentsFlat</a> () const</td></tr>
<tr class="memdesc:ac05172888cda84f9ce53984eb80d4724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of components for each value in the array.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#ac05172888cda84f9ce53984eb80d4724">More...</a><br /></td></tr>
<tr class="separator:ac05172888cda84f9ce53984eb80d4724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603363f20df24f1e3e123261531a38c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a603363f20df24f1e3e123261531a38c7">Allocate</a> (<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfValues, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> preserve, <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;token) const</td></tr>
<tr class="memdesc:a603363f20df24f1e3e123261531a38c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an array large enough to hold the given number of values.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a603363f20df24f1e3e123261531a38c7">More...</a><br /></td></tr>
<tr class="separator:a603363f20df24f1e3e123261531a38c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce875dbaf448fde4a33f7f8a8140be9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#adce875dbaf448fde4a33f7f8a8140be9">Allocate</a> (<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfValues, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> preserve=<a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a>) const</td></tr>
<tr class="memdesc:adce875dbaf448fde4a33f7f8a8140be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an array large enough to hold the given number of values.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#adce875dbaf448fde4a33f7f8a8140be9">More...</a><br /></td></tr>
<tr class="separator:adce875dbaf448fde4a33f7f8a8140be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e46d034011a0618e71074847b6e63e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a85e46d034011a0618e71074847b6e63e">AllocateAndFill</a> (<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfValues, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a> &amp;fillValue, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> preserve, <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;token) const</td></tr>
<tr class="memdesc:a85e46d034011a0618e71074847b6e63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an array and fills it with an initial value.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a85e46d034011a0618e71074847b6e63e">More...</a><br /></td></tr>
<tr class="separator:a85e46d034011a0618e71074847b6e63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d5fdf73934b854620072d7ae213793"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aa9d5fdf73934b854620072d7ae213793">AllocateAndFill</a> (<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfValues, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a> &amp;fillValue, <a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a> preserve=<a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a>) const</td></tr>
<tr class="memdesc:aa9d5fdf73934b854620072d7ae213793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an array and fills it with an initial value.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#aa9d5fdf73934b854620072d7ae213793">More...</a><br /></td></tr>
<tr class="separator:aa9d5fdf73934b854620072d7ae213793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2385756db7737d90dfa6e6a33022e65e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a2385756db7737d90dfa6e6a33022e65e">Fill</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a> &amp;fillValue, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> startIndex, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> endIndex, <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;token) const</td></tr>
<tr class="memdesc:a2385756db7737d90dfa6e6a33022e65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the array with a given value.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a2385756db7737d90dfa6e6a33022e65e">More...</a><br /></td></tr>
<tr class="separator:a2385756db7737d90dfa6e6a33022e65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffb214e439010606ab00a9ee2174e74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a4ffb214e439010606ab00a9ee2174e74">Fill</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a> &amp;fillValue, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> startIndex, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> endIndex) const</td></tr>
<tr class="memdesc:a4ffb214e439010606ab00a9ee2174e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the array with a given value.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a4ffb214e439010606ab00a9ee2174e74">More...</a><br /></td></tr>
<tr class="separator:a4ffb214e439010606ab00a9ee2174e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ddae60f7387086da744990f0e248bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a38ddae60f7387086da744990f0e248bc">Fill</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a> &amp;fillValue, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> startIndex=0) const</td></tr>
<tr class="memdesc:a38ddae60f7387086da744990f0e248bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the array with a given value.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a38ddae60f7387086da744990f0e248bc">More...</a><br /></td></tr>
<tr class="separator:a38ddae60f7387086da744990f0e248bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3fed8fe7bd0389903d0acfce9264e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a5a3fed8fe7bd0389903d0acfce9264e3">ReleaseResourcesExecution</a> () const</td></tr>
<tr class="memdesc:a5a3fed8fe7bd0389903d0acfce9264e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases any resources being used in the execution environment (that are not being shared by the control environment).  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a5a3fed8fe7bd0389903d0acfce9264e3">More...</a><br /></td></tr>
<tr class="separator:a5a3fed8fe7bd0389903d0acfce9264e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34a5f0d93ab497c898cbc11ebed86aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#af34a5f0d93ab497c898cbc11ebed86aa">ReleaseResources</a> () const</td></tr>
<tr class="memdesc:af34a5f0d93ab497c898cbc11ebed86aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases all resources in both the control and execution environments.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#af34a5f0d93ab497c898cbc11ebed86aa">More...</a><br /></td></tr>
<tr class="separator:af34a5f0d93ab497c898cbc11ebed86aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d92a5f2878d74d79b639e2ec270425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#af3edd88546709bdfaa2910a8cb35bbc0">ReadPortalType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a31d92a5f2878d74d79b639e2ec270425">PrepareForInput</a> (<a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a> device, <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;token) const</td></tr>
<tr class="memdesc:a31d92a5f2878d74d79b639e2ec270425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares this array to be used as an input to an operation in the execution environment.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a31d92a5f2878d74d79b639e2ec270425">More...</a><br /></td></tr>
<tr class="separator:a31d92a5f2878d74d79b639e2ec270425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf21e20da5185c4a3b0d237f2a6a1543"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aaa713511405938d93164978905f624d9">WritePortalType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aaf21e20da5185c4a3b0d237f2a6a1543">PrepareForInPlace</a> (<a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a> device, <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;token) const</td></tr>
<tr class="memdesc:aaf21e20da5185c4a3b0d237f2a6a1543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares this array to be used in an in-place operation (both as input and output) in the execution environment.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#aaf21e20da5185c4a3b0d237f2a6a1543">More...</a><br /></td></tr>
<tr class="separator:aaf21e20da5185c4a3b0d237f2a6a1543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae723b49ef2bf7bdf6c95d75e7735cfdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aaa713511405938d93164978905f624d9">WritePortalType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#ae723b49ef2bf7bdf6c95d75e7735cfdc">PrepareForOutput</a> (<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfValues, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a> device, <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;token) const</td></tr>
<tr class="memdesc:ae723b49ef2bf7bdf6c95d75e7735cfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares (allocates) this array to be used as an output from an operation in the execution environment.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#ae723b49ef2bf7bdf6c95d75e7735cfdc">More...</a><br /></td></tr>
<tr class="separator:ae723b49ef2bf7bdf6c95d75e7735cfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f29177c980164bb4e22e735d913465f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a8f29177c980164bb4e22e735d913465f">IsOnDevice</a> (<a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a> device) const</td></tr>
<tr class="memdesc:a8f29177c980164bb4e22e735d913465f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>'s data is on the given device.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a8f29177c980164bb4e22e735d913465f">More...</a><br /></td></tr>
<tr class="separator:a8f29177c980164bb4e22e735d913465f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f55b1867121a46271ca26dfc35b7b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aa7f55b1867121a46271ca26dfc35b7b4">IsOnHost</a> () const</td></tr>
<tr class="memdesc:aa7f55b1867121a46271ca26dfc35b7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>'s data is on the host.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#aa7f55b1867121a46271ca26dfc35b7b4">More...</a><br /></td></tr>
<tr class="separator:aa7f55b1867121a46271ca26dfc35b7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd671883c872226c26ac5cb057a84950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#abd671883c872226c26ac5cb057a84950">SyncControlArray</a> () const</td></tr>
<tr class="memdesc:abd671883c872226c26ac5cb057a84950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizes the control array with the execution array.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#abd671883c872226c26ac5cb057a84950">More...</a><br /></td></tr>
<tr class="separator:abd671883c872226c26ac5cb057a84950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee30eb72ef7733dae4f04f832f3eb2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a2ee30eb72ef7733dae4f04f832f3eb2b">Enqueue</a> (const <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;token) const</td></tr>
<tr class="memdesc:a2ee30eb72ef7733dae4f04f832f3eb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a token for access to this <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a2ee30eb72ef7733dae4f04f832f3eb2b">More...</a><br /></td></tr>
<tr class="separator:a2ee30eb72ef7733dae4f04f832f3eb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28896a4dd2aa1ebd5baa5f31e220c2bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a28896a4dd2aa1ebd5baa5f31e220c2bd">DeepCopyFrom</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt; &amp;source) const</td></tr>
<tr class="memdesc:a28896a4dd2aa1ebd5baa5f31e220c2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copies the data in the array.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a28896a4dd2aa1ebd5baa5f31e220c2bd">More...</a><br /></td></tr>
<tr class="separator:a28896a4dd2aa1ebd5baa5f31e220c2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c378b86f00656e0b1ea38c67294bd93"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; viskores::cont::internal::Buffer &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a8c378b86f00656e0b1ea38c67294bd93">GetBuffers</a> () const</td></tr>
<tr class="memdesc:a8c378b86f00656e0b1ea38c67294bd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal <code>Buffer</code> structures that hold the data.  <a href="classviskores_1_1cont_1_1ArrayHandle.html#a8c378b86f00656e0b1ea38c67294bd93">More...</a><br /></td></tr>
<tr class="separator:a8c378b86f00656e0b1ea38c67294bd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05b0e58dde167b5a4c5beab73f00c7e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; viskores::cont::internal::Buffer &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#ac05b0e58dde167b5a4c5beab73f00c7e">GetBuffers</a> ()</td></tr>
<tr class="separator:ac05b0e58dde167b5a4c5beab73f00c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8e578cb07bf30c6b20e93eabfa1544bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a8e578cb07bf30c6b20e93eabfa1544bb">SetBuffer</a> (<a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> index, const viskores::cont::internal::Buffer &amp;buffer)</td></tr>
<tr class="separator:a8e578cb07bf30c6b20e93eabfa1544bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f98c1bd6e600cf01d469f756e47e8db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a8f98c1bd6e600cf01d469f756e47e8db">SetBuffers</a> (const std::vector&lt; viskores::cont::internal::Buffer &gt; &amp;buffers)</td></tr>
<tr class="separator:a8f98c1bd6e600cf01d469f756e47e8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffd01d7022357dbbf9b224805712cb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a9ffd01d7022357dbbf9b224805712cb4">SetBuffers</a> (std::vector&lt; viskores::cont::internal::Buffer &gt; &amp;&amp;buffers)</td></tr>
<tr class="separator:a9ffd01d7022357dbbf9b224805712cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a2bc2ec257675be1bc7ded017eb5bd3e7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; viskores::cont::internal::Buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a2bc2ec257675be1bc7ded017eb5bd3e7">Buffers</a></td></tr>
<tr class="separator:a2bc2ec257675be1bc7ded017eb5bd3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename StorageTag_ = VISKORES_DEFAULT_STORAGE_TAG&gt;<br />
class viskores::cont::ArrayHandle&lt; T, StorageTag_ &gt;</h3>

<p>Manages an array-worth of data. </p>
<p><code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> manages as array of data that can be manipulated by Viskores algorithms. The <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> may have up to two copies of the array, one for the control environment and one for the execution environment, although depending on the device and how the array is being used, the <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> will only have one copy when possible.</p>
<p>An <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> is often constructed by instantiating one of the <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> subclasses. Several basic <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> types can also be constructed directly and then allocated. The <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleBasic.html" title="Basic array storage for an array handle.">ArrayHandleBasic</a></code> subclass provides mechanisms for importing user arrays into an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>.</p>
<p><code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> behaves like a shared smart pointer in that when it is copied each copy holds a reference to the same array. These copies are reference counted so that when all copies of the <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> are destroyed, any allocated memory is released. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af3edd88546709bdfaa2910a8cb35bbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3edd88546709bdfaa2910a8cb35bbc0">&#9670;&nbsp;</a></span>ReadPortalType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#af3edd88546709bdfaa2910a8cb35bbc0">ReadPortalType</a> =  typename StorageType::ReadPortalType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of portal used when accessing data in a read-only mode. </p>

</div>
</div>
<a id="a62c6816987572574d01d16764393bc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c6816987572574d01d16764393bc1e">&#9670;&nbsp;</a></span>StorageTag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> =  StorageTag_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa944cb30d836f84b06d2262a66c65327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa944cb30d836f84b06d2262a66c65327">&#9670;&nbsp;</a></span>StorageType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aa944cb30d836f84b06d2262a66c65327">StorageType</a> =  viskores::cont::internal::Storage&lt;<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bea7542605b4a33146564e266af841e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bea7542605b4a33146564e266af841e">&#9670;&nbsp;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa713511405938d93164978905f624d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa713511405938d93164978905f624d9">&#9670;&nbsp;</a></span>WritePortalType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aaa713511405938d93164978905f624d9">WritePortalType</a> =  typename StorageType::WritePortalType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of portal used when accessing data in a read-write mode. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa3c15396a60b6dd0718efa8a4915f938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c15396a60b6dd0718efa8a4915f938">&#9670;&nbsp;</a></span>ArrayHandle() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>

</div>
</div>
<a id="a6c8e2f577861f159cd427396d72eac8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8e2f577861f159cd427396d72eac8c">&#9670;&nbsp;</a></span>ArrayHandle() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Implemented so that it is defined exclusively in the control environment. If there is a separate device for the execution environment (for example, with CUDA), then the automatically generated copy constructor could be created for all devices, and it would not be valid for all devices. </p>

</div>
</div>
<a id="a9e3c24ad9845820248569bc1d60f011a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3c24ad9845820248569bc1d60f011a">&#9670;&nbsp;</a></span>ArrayHandle() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Implemented so that it is defined exclusively in the control environment. If there is a separate device for the execution environment (for example, with CUDA), then the automatically generated move constructor could be created for all devices, and it would not be valid for all devices. </p>

</div>
</div>
<a id="a137a796cc8d484db4b58c03745951592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137a796cc8d484db4b58c03745951592">&#9670;&nbsp;</a></span>ArrayHandle() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; viskores::cont::internal::Buffer &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Special constructor for subclass specializations that need to set the initial state array. </p>
<p>Used when pulling data from other sources. </p>

</div>
</div>
<a id="a36ed4b37011b3985234ee4e2d086bce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ed4b37011b3985234ee4e2d086bce1">&#9670;&nbsp;</a></span>ArrayHandle() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; viskores::cont::internal::Buffer &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Special constructor for subclass specializations that need to set the initial state array. </p>
<p>Used when pulling data from other sources. </p>

</div>
</div>
<a id="abb86aa9e0165b8b2711aee2d821028ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb86aa9e0165b8b2711aee2d821028ad">&#9670;&nbsp;</a></span>~ArrayHandle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::~<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructs an empty <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>
<p>Implemented so that it is defined exclusively in the control environment. If there is a separate device for the execution environment (for example, with CUDA), then the automatically generated destructor could be created for all devices, and it would not be valid for all devices. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a603363f20df24f1e3e123261531a38c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603363f20df24f1e3e123261531a38c7">&#9670;&nbsp;</a></span>Allocate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::Allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>preserve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates an array large enough to hold the given number of values. </p>
<p>The allocation may be done on an already existing array. If so, then the data are preserved as best as possible if the preserve flag is set to <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3">viskores::CopyFlag::On</a></code>. If the preserve flag is set to <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a></code> (the default), any existing data could be wiped out.</p>
<p>This method can throw <code><a class="el" href="classviskores_1_1cont_1_1ErrorBadAllocation.html" title="This class is thrown when Viskores attempts to manipulate memory that it should not.">viskores::cont::ErrorBadAllocation</a></code> if the array cannot be allocated or <code><a class="el" href="classviskores_1_1cont_1_1ErrorBadValue.html" title="This class is thrown when a Viskores function or method encounters an invalid value that inhibits pro...">viskores::cont::ErrorBadValue</a></code> if the allocation is not feasible (for example, the array storage is read-only). </p>

</div>
</div>
<a id="adce875dbaf448fde4a33f7f8a8140be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce875dbaf448fde4a33f7f8a8140be9">&#9670;&nbsp;</a></span>Allocate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::Allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>preserve</em> = <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates an array large enough to hold the given number of values. </p>
<p>The allocation may be done on an already existing array. If so, then the data are preserved as best as possible if the preserve flag is set to <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3">viskores::CopyFlag::On</a></code>. If the preserve flag is set to <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a></code> (the default), any existing data could be wiped out.</p>
<p>This method can throw <code><a class="el" href="classviskores_1_1cont_1_1ErrorBadAllocation.html" title="This class is thrown when Viskores attempts to manipulate memory that it should not.">viskores::cont::ErrorBadAllocation</a></code> if the array cannot be allocated or <code><a class="el" href="classviskores_1_1cont_1_1ErrorBadValue.html" title="This class is thrown when a Viskores function or method encounters an invalid value that inhibits pro...">viskores::cont::ErrorBadValue</a></code> if the allocation is not feasible (for example, the array storage is read-only). </p>

</div>
</div>
<a id="a85e46d034011a0618e71074847b6e63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e46d034011a0618e71074847b6e63e">&#9670;&nbsp;</a></span>AllocateAndFill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::AllocateAndFill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>preserve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates an array and fills it with an initial value. </p>
<p><code>AllocateAndFill</code> behaves similar to <code>Allocate</code> except that after allocation it fills the array with a given <code>fillValue</code>. This method is convenient when you wish to initialize the array.</p>
<p>If the <code>preserve</code> flag is <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3">viskores::CopyFlag::On</a></code>, then any data that existed before the call to <code>AllocateAndFill</code> will remain after the call (assuming the new array size is large enough). If the array size is expanded, then the new values at the end will be filled.</p>
<p>If the <code>preserve</code> flag is <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a></code> (the default), the entire array is filled with the given <code>fillValue</code>. </p>

</div>
</div>
<a id="aa9d5fdf73934b854620072d7ae213793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d5fdf73934b854620072d7ae213793">&#9670;&nbsp;</a></span>AllocateAndFill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::AllocateAndFill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94">viskores::CopyFlag</a>&#160;</td>
          <td class="paramname"><em>preserve</em> = <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates an array and fills it with an initial value. </p>
<p><code>AllocateAndFill</code> behaves similar to <code>Allocate</code> except that after allocation it fills the array with a given <code>fillValue</code>. This method is convenient when you wish to initialize the array.</p>
<p>If the <code>preserve</code> flag is <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94a521c36a31c2762741cf0f8890cbe05e3">viskores::CopyFlag::On</a></code>, then any data that existed before the call to <code>AllocateAndFill</code> will remain after the call (assuming the new array size is large enough). If the array size is expanded, then the new values at the end will be filled.</p>
<p>If the <code>preserve</code> flag is <code><a class="el" href="namespaceviskores.html#a113186fd6accb2e5880e81dd7cdb1c94ad15305d7a4e34e02489c74a5ef542f36">viskores::CopyFlag::Off</a></code> (the default), the entire array is filled with the given <code>fillValue</code>. </p>

</div>
</div>
<a id="a28896a4dd2aa1ebd5baa5f31e220c2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28896a4dd2aa1ebd5baa5f31e220c2bd">&#9670;&nbsp;</a></span>DeepCopyFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::DeepCopyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copies the data in the array. </p>
<p>Takes the data that is in <em>source</em> and copies that data into this array. </p>

</div>
</div>
<a id="a2ee30eb72ef7733dae4f04f832f3eb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee30eb72ef7733dae4f04f832f3eb2b">&#9670;&nbsp;</a></span>Enqueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::Enqueue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue a token for access to this <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>
<p>This method places the given <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> into the queue of <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code>s waiting for access to this <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> and then returns immediately. When this token is later used to get data from this <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> (for example, in a call to <code>PrepareForInput</code>), it will use this place in the queue while waiting for access.</p>
<p>This method is to be used to ensure that a set of accesses to an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> that happen on multiple threads occur in a specified order. For example, if you spawn of a job to modify data in an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> and then spawn off a job that reads that same data, you need to make sure that the first job gets access to the <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> before the second. If they both just attempt to call their respective <code>Prepare</code> methods, there is no guarantee which order they will occur. Having the spawning thread first call this method will ensure the order.</p>
<dl class="section warning"><dt>Warning</dt><dd>After calling this method it is required to subsequently call a method like one of the <code>Prepare</code> methods that attaches the token to this <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>. Otherwise, the enqueued token will block any subsequent access to the <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>, even if the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is destroyed. </dd></dl>

</div>
</div>
<a id="a4ffb214e439010606ab00a9ee2174e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffb214e439010606ab00a9ee2174e74">&#9670;&nbsp;</a></span>Fill() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::Fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>endIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the array with a given value. </p>
<p>After calling this method, every entry in the array from <code>startIndex</code> (inclusive) to <code>endIndex</code> (exclusive) of the array is set to <code>fillValue</code>. If <code>startIndex</code> or <code>endIndex</code> is not specified, then the fill happens from the begining or end, respectively. </p>

</div>
</div>
<a id="a2385756db7737d90dfa6e6a33022e65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2385756db7737d90dfa6e6a33022e65e">&#9670;&nbsp;</a></span>Fill() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::Fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>endIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the array with a given value. </p>
<p>After calling this method, every entry in the array from <code>startIndex</code> (inclusive) to <code>endIndex</code> (exclusive) of the array is set to <code>fillValue</code>. If <code>startIndex</code> or <code>endIndex</code> is not specified, then the fill happens from the begining or end, respectively. </p>

</div>
</div>
<a id="a38ddae60f7387086da744990f0e248bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ddae60f7387086da744990f0e248bc">&#9670;&nbsp;</a></span>Fill() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::Fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>startIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the array with a given value. </p>
<p>After calling this method, every entry in the array from <code>startIndex</code> (inclusive) to <code>endIndex</code> (exclusive) of the array is set to <code>fillValue</code>. If <code>startIndex</code> or <code>endIndex</code> is not specified, then the fill happens from the begining or end, respectively. </p>

</div>
</div>
<a id="ac05b0e58dde167b5a4c5beab73f00c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05b0e58dde167b5a4c5beab73f00c7e">&#9670;&nbsp;</a></span>GetBuffers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;viskores::cont::internal::Buffer&gt;&amp; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::GetBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c378b86f00656e0b1ea38c67294bd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c378b86f00656e0b1ea38c67294bd93">&#9670;&nbsp;</a></span>GetBuffers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;viskores::cont::internal::Buffer&gt;&amp; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::GetBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal <code>Buffer</code> structures that hold the data. </p>
<p>Note that great care should be taken when modifying buffers outside of the <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>

</div>
</div>
<a id="ac05172888cda84f9ce53984eb80d4724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05172888cda84f9ce53984eb80d4724">&#9670;&nbsp;</a></span>GetNumberOfComponentsFlat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::GetNumberOfComponentsFlat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of components for each value in the array. </p>
<p>If the array holds <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a></code> objects, this will return the total number of components in each value assuming the object is flattened out to one level of <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code> objects. If the array holds a basic C type (such as <code>float</code>), this will return 1. If the array holds a simple <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code> (such as <code><a class="el" href="namespaceviskores.html#abb422027052141614ec406112a05576d" title="Vec3f corresponds to a 3-dimensional vector of floating point values.">viskores::Vec3f</a></code>), this will return the number of components (in this case 3). If the array holds a hierarchy of <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code>s (such as <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">viskores::Vec</a>&lt;<a class="el" href="namespaceviskores.html#abb422027052141614ec406112a05576d" title="Vec3f corresponds to a 3-dimensional vector of floating point values.">viskores::Vec3f</a>, 2&gt;</code>), this will return the total number of vecs (in this case 6).</p>
<p>If this object is holding an array where the number of components can be selected at runtime (for example, <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleRuntimeVec.html" title="Fancy array handle for a basic array with runtime selected vec size.">viskores::cont::ArrayHandleRuntimeVec</a></code>), this method will still return the correct number of components. However, if each value in the array can be a <code><a class="el" href="classviskores_1_1Vec.html" title="A short fixed-length array.">Vec</a></code> of a different size (such as <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandleGroupVecVariable.html" title="Fancy array handle that groups values into vectors of different sizes.">viskores::cont::ArrayHandleGroupVecVariable</a></code>), this method will return 0 (because there is no consistent answer). </p>

</div>
</div>
<a id="ad084795021c8600def1edbc8b1872921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad084795021c8600def1edbc8b1872921">&#9670;&nbsp;</a></span>GetNumberOfValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::GetNumberOfValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of entries in the array. </p>

</div>
</div>
<a id="aeda0dd50a677971a714555444402eceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda0dd50a677971a714555444402eceb">&#9670;&nbsp;</a></span>GetStorage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aa944cb30d836f84b06d2262a66c65327">StorageType</a> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::GetStorage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the storage. </p>

</div>
</div>
<a id="a8f29177c980164bb4e22e735d913465f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f29177c980164bb4e22e735d913465f">&#9670;&nbsp;</a></span>IsOnDevice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::IsOnDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>'s data is on the given device. </p>
<p>If the data are on the given device, then preparing for that device should not require any data movement. </p>

</div>
</div>
<a id="aa7f55b1867121a46271ca26dfc35b7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f55b1867121a46271ca26dfc35b7b4">&#9670;&nbsp;</a></span>IsOnHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::IsOnHost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>'s data is on the host. </p>
<p>If the data are on the given device, then calling <code>ReadPortal</code> or <code>WritePortal</code> should not require any data movement. </p>

</div>
</div>
<a id="a2ff479adc4188ecbedb681d13d280ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff479adc4188ecbedb681d13d280ddb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa42793148ca4d0b18f12c8aa8d9cb119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42793148ca4d0b18f12c8aa8d9cb119">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<div class="memtemplate">
template&lt;typename VT , typename ST &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle</a>&lt; VT, ST &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a349b67ec5fc601dc01da752295b6830b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349b67ec5fc601dc01da752295b6830b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a>&gt;&amp; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shallow copies an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>

</div>
</div>
<a id="adbd27f9878c3098847bbd474295303f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd27f9878c3098847bbd474295303f0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt;<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a>&gt;&amp; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move and Assignment of an <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>

</div>
</div>
<a id="a3f94267f3bd4da6c80690f90417ad626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f94267f3bd4da6c80690f90417ad626">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle</a>&lt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a0bea7542605b4a33146564e266af841e">ValueType</a>, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#a62c6816987572574d01d16764393bc1e">StorageTag</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like a pointer, two <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>s are considered equal if they point to the same location in memory. </p>

</div>
</div>
<a id="a07a30f1b7549fec2e41edac59de3b4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a30f1b7549fec2e41edac59de3b4e4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<div class="memtemplate">
template&lt;typename VT , typename ST &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">ArrayHandle</a>&lt; VT, ST &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf21e20da5185c4a3b0d237f2a6a1543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf21e20da5185c4a3b0d237f2a6a1543">&#9670;&nbsp;</a></span>PrepareForInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aaa713511405938d93164978905f624d9">WritePortalType</a> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::PrepareForInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepares this array to be used in an in-place operation (both as input and output) in the execution environment. </p>
<p>If necessary, copies data to the execution environment. Can throw an exception if this array does not yet contain any data. Returns a portal that can be used in code running in the execution environment.</p>
<p>The <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> object provided will be attached to this <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>. The returned portal is guaranteed to be valid while the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is still attached and in scope. Other operations on this <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> that would invalidate the returned portal will block until the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is released. Likewise, this method will block if another <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is already attached. This can potentially lead to deadlocks. </p>

</div>
</div>
<a id="a31d92a5f2878d74d79b639e2ec270425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d92a5f2878d74d79b639e2ec270425">&#9670;&nbsp;</a></span>PrepareForInput()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#af3edd88546709bdfaa2910a8cb35bbc0">ReadPortalType</a> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::PrepareForInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepares this array to be used as an input to an operation in the execution environment. </p>
<p>If necessary, copies data to the execution environment. Can throw an exception if this array does not yet contain any data. Returns a portal that can be used in code running in the execution environment.</p>
<p>The <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> object provided will be attached to this <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>. The returned portal is guaranteed to be valid while the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is still attached and in scope. Other operations on this <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> that would invalidate the returned portal will block until the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is released. Likewise, this method will block if another <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is already attached. This can potentially lead to deadlocks. </p>

</div>
</div>
<a id="ae723b49ef2bf7bdf6c95d75e7735cfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae723b49ef2bf7bdf6c95d75e7735cfdc">&#9670;&nbsp;</a></span>PrepareForOutput()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aaa713511405938d93164978905f624d9">WritePortalType</a> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::PrepareForOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterId.html">viskores::cont::DeviceAdapterId</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepares (allocates) this array to be used as an output from an operation in the execution environment. </p>
<p>The internal state of this class is set to have valid data in the execution array with the assumption that the array will be filled soon (i.e. before any other methods of this object are called). Returns a portal that can be used in code running in the execution environment.</p>
<p>The <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> object provided will be attached to this <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code>. The returned portal is guaranteed to be valid while the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is still attached and in scope. Other operations on this <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> that would invalidate the returned portal will block until the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is released. Likewise, this method will block if another <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is already attached. This can potentially lead to deadlocks. </p>

</div>
</div>
<a id="a7d28220785ee72f97469b29a7b587443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d28220785ee72f97469b29a7b587443">&#9670;&nbsp;</a></span>ReadPortal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#af3edd88546709bdfaa2910a8cb35bbc0">ReadPortalType</a> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::ReadPortal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an array portal that can be used in the control environment. </p>
<p>The returned array can be used in the control environment to read values from the array. (It is not possible to write to the returned portal. That is <code>Get</code> will work on the portal, but <code>Set</code> will not.)</p>
<p><b>Note:</b> The returned portal cannot be used in the execution environment. This is because the portal will not work on some devices like GPUs. To get a portal that will work in the execution environment, use <code>PrepareForInput</code>. </p>

</div>
</div>
<a id="ae1882410ce1a58fff86f313895806fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1882410ce1a58fff86f313895806fac">&#9670;&nbsp;</a></span>ReadPortal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#af3edd88546709bdfaa2910a8cb35bbc0">ReadPortalType</a> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::ReadPortal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of portal used when accessing data in a read-only mode. </p>

</div>
</div>
<a id="af34a5f0d93ab497c898cbc11ebed86aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34a5f0d93ab497c898cbc11ebed86aa">&#9670;&nbsp;</a></span>ReleaseResources()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::ReleaseResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases all resources in both the control and execution environments. </p>

</div>
</div>
<a id="a5a3fed8fe7bd0389903d0acfce9264e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3fed8fe7bd0389903d0acfce9264e3">&#9670;&nbsp;</a></span>ReleaseResourcesExecution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::ReleaseResourcesExecution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases any resources being used in the execution environment (that are not being shared by the control environment). </p>

</div>
</div>
<a id="a8e578cb07bf30c6b20e93eabfa1544bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e578cb07bf30c6b20e93eabfa1544bb">&#9670;&nbsp;</a></span>SetBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::SetBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const viskores::cont::internal::Buffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f98c1bd6e600cf01d469f756e47e8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f98c1bd6e600cf01d469f756e47e8db">&#9670;&nbsp;</a></span>SetBuffers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::SetBuffers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; viskores::cont::internal::Buffer &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ffd01d7022357dbbf9b224805712cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ffd01d7022357dbbf9b224805712cb4">&#9670;&nbsp;</a></span>SetBuffers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::SetBuffers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; viskores::cont::internal::Buffer &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd671883c872226c26ac5cb057a84950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd671883c872226c26ac5cb057a84950">&#9670;&nbsp;</a></span>SyncControlArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::SyncControlArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronizes the control array with the execution array. </p>
<p>If either the user array or control array is already valid, this method does nothing (because the data is already available in the control environment). Although the internal state of this class can change, the method is declared const because logically the data does not. </p>

</div>
</div>
<a id="abe5d93aa07c249d3a5a375a8c8229eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5d93aa07c249d3a5a375a8c8229eff">&#9670;&nbsp;</a></span>WritePortal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aaa713511405938d93164978905f624d9">WritePortalType</a> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::WritePortal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an array portal that can be used in the control environment. </p>
<p>The returned array can be used in the control environment to reand and write values to the array.</p>
<p><b>Note:</b> The returned portal cannot be used in the execution environment. This is because the portal will not work on some devices like GPUs. To get a portal that will work in the execution environment, use <code>PrepareForInput</code>. </p>

</div>
</div>
<a id="af502debf665a670a6a389aa7fba2069f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af502debf665a670a6a389aa7fba2069f">&#9670;&nbsp;</a></span>WritePortal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html#aaa713511405938d93164978905f624d9">WritePortalType</a> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::WritePortal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token.html">viskores::cont::Token</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an array portal that can be used in the control environment. </p>
<p>The returned array can be used in the control environment to reand and write values to the array.</p>
<p><b>Note:</b> The returned portal cannot be used in the execution environment. This is because the portal will not work on some devices like GPUs. To get a portal that will work in the execution environment, use <code>PrepareForInput</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2bc2ec257675be1bc7ded017eb5bd3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc2ec257675be1bc7ded017eb5bd3e7">&#9670;&nbsp;</a></span>Buffers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename StorageTag_  = VISKORES_DEFAULT_STORAGE_TAG&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;viskores::cont::internal::Buffer&gt; <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageTag_ &gt;::Buffers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ArrayHandle_8h_source.html">ArrayHandle.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
