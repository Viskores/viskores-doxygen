<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Viskores: viskores::cont::DeviceAdapterAlgorithm&lt; DeviceAdapterTag &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Viskores
   &#160;<span id="projectnumber">0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceviskores.html">viskores</a></li><li class="navelem"><a class="el" href="namespaceviskores_1_1cont.html">cont</a></li><li class="navelem"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">DeviceAdapterAlgorithm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">viskores::cont::DeviceAdapterAlgorithm&lt; DeviceAdapterTag &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Struct containing device adapter algorithms.  
 <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DeviceAdapterAlgorithm_8h_source.html">DeviceAdapterAlgorithm.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1a8c12c512465ade0c8ec7f222ad0f16"><td class="memItemLeft" align="right" valign="top">static T class BinaryFunctor static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a1a8c12c512465ade0c8ec7f222ad0f16">ScanExclusiveByKey</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a43d371abbd468f89479410c97fa1a807">KIn</a> &gt; &amp;keys, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aba4f60fcf4baacdad31a188b136318e9">VIn</a> &gt; &amp;values, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a63523e0d84616450f9497d5750e0be2f">VOut</a> &gt; &amp;output, const <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a> &amp;initialValue, BinaryFunctor binaryFunctor)</td></tr>
<tr class="separator:a1a8c12c512465ade0c8ec7f222ad0f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae8fc940ba9a8bfd8f6a5c7516411ac27"><td class="memTemplParams" colspan="2">template&lt;typename IndicesStorage &gt; </td></tr>
<tr class="memitem:ae8fc940ba9a8bfd8f6a5c7516411ac27"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#ae8fc940ba9a8bfd8f6a5c7516411ac27">BitFieldToUnorderedSet</a> (const <a class="el" href="classviskores_1_1cont_1_1BitField.html">viskores::cont::BitField</a> &amp;bits, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">Id</a>, IndicesStorage &gt; &amp;indices)</td></tr>
<tr class="memdesc:ae8fc940ba9a8bfd8f6a5c7516411ac27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique, unsorted list of indices denoting which bits are set in a bitfield.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#ae8fc940ba9a8bfd8f6a5c7516411ac27">More...</a><br /></td></tr>
<tr class="separator:ae8fc940ba9a8bfd8f6a5c7516411ac27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3dc5a8bc0fdec96a9a7014f6dc978c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , class CIn , class COut &gt; </td></tr>
<tr class="memitem:a3a3dc5a8bc0fdec96a9a7014f6dc978c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a3a3dc5a8bc0fdec96a9a7014f6dc978c">Copy</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;input, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, COut &gt; &amp;output)</td></tr>
<tr class="memdesc:a3a3dc5a8bc0fdec96a9a7014f6dc978c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of one <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> to another.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a3a3dc5a8bc0fdec96a9a7014f6dc978c">More...</a><br /></td></tr>
<tr class="separator:a3a3dc5a8bc0fdec96a9a7014f6dc978c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ca92eaac87182ac3305cfd37236777"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , class CIn , class CStencil , class COut &gt; </td></tr>
<tr class="memitem:a83ca92eaac87182ac3305cfd37236777"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a83ca92eaac87182ac3305cfd37236777">CopyIf</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;input, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, CStencil &gt; &amp;stencil, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, COut &gt; &amp;output)</td></tr>
<tr class="memdesc:a83ca92eaac87182ac3305cfd37236777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally copy elements in the input array to the output array.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a83ca92eaac87182ac3305cfd37236777">More...</a><br /></td></tr>
<tr class="separator:a83ca92eaac87182ac3305cfd37236777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15432fa11b9e33f5f268e09007327bc1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , class CIn , class CStencil , class COut , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a15432fa11b9e33f5f268e09007327bc1"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a15432fa11b9e33f5f268e09007327bc1">CopyIf</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;input, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, CStencil &gt; &amp;stencil, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, COut &gt; &amp;output, UnaryPredicate unary_predicate)</td></tr>
<tr class="memdesc:a15432fa11b9e33f5f268e09007327bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally copy elements in the input array to the output array.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a15432fa11b9e33f5f268e09007327bc1">More...</a><br /></td></tr>
<tr class="separator:a15432fa11b9e33f5f268e09007327bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cebe388768139c2a1de7a07bd78621"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , class CIn , class COut &gt; </td></tr>
<tr class="memitem:a00cebe388768139c2a1de7a07bd78621"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a00cebe388768139c2a1de7a07bd78621">CopySubRange</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;input, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> inputStartIndex, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numberOfElementsToCopy, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, COut &gt; &amp;output, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> outputIndex=0)</td></tr>
<tr class="memdesc:a00cebe388768139c2a1de7a07bd78621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of a section of one <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> to another.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a00cebe388768139c2a1de7a07bd78621">More...</a><br /></td></tr>
<tr class="separator:a00cebe388768139c2a1de7a07bd78621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e3dfa8ae3c3ecc09c59b6358a8c071"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#af6e3dfa8ae3c3ecc09c59b6358a8c071">CountSetBits</a> (const <a class="el" href="classviskores_1_1cont_1_1BitField.html">viskores::cont::BitField</a> &amp;bits)</td></tr>
<tr class="memdesc:af6e3dfa8ae3c3ecc09c59b6358a8c071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of "1" bits in <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a>.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#af6e3dfa8ae3c3ecc09c59b6358a8c071">More...</a><br /></td></tr>
<tr class="separator:af6e3dfa8ae3c3ecc09c59b6358a8c071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa911eb358d57a9a7c66950c7f27f4739"><td class="memTemplParams" colspan="2">template&lt;typename T , class CIn , class CVal , class COut &gt; </td></tr>
<tr class="memitem:aa911eb358d57a9a7c66950c7f27f4739"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aa911eb358d57a9a7c66950c7f27f4739">LowerBounds</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;input, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CVal &gt; &amp;values, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, COut &gt; &amp;output)</td></tr>
<tr class="memdesc:aa911eb358d57a9a7c66950c7f27f4739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output is the first index in input for each item in values that wouldn't alter the ordering of input.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aa911eb358d57a9a7c66950c7f27f4739">More...</a><br /></td></tr>
<tr class="separator:aa911eb358d57a9a7c66950c7f27f4739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4135e42bbc49004491ffd251fd0998"><td class="memTemplParams" colspan="2">template&lt;typename T , class CIn , class CVal , class COut , class BinaryCompare &gt; </td></tr>
<tr class="memitem:a9c4135e42bbc49004491ffd251fd0998"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a9c4135e42bbc49004491ffd251fd0998">LowerBounds</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;input, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CVal &gt; &amp;values, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, COut &gt; &amp;output, BinaryCompare binary_compare)</td></tr>
<tr class="memdesc:a9c4135e42bbc49004491ffd251fd0998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output is the first index in input for each item in values that wouldn't alter the ordering of input.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a9c4135e42bbc49004491ffd251fd0998">More...</a><br /></td></tr>
<tr class="separator:a9c4135e42bbc49004491ffd251fd0998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f03be975aab6e4b302155fa417dd47a"><td class="memTemplParams" colspan="2">template&lt;class CIn , class COut &gt; </td></tr>
<tr class="memitem:a8f03be975aab6e4b302155fa417dd47a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a8f03be975aab6e4b302155fa417dd47a">LowerBounds</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, CIn &gt; &amp;input, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, COut &gt; &amp;values_output)</td></tr>
<tr class="memdesc:a8f03be975aab6e4b302155fa417dd47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special version of LowerBounds that does an in place operation.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a8f03be975aab6e4b302155fa417dd47a">More...</a><br /></td></tr>
<tr class="separator:a8f03be975aab6e4b302155fa417dd47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8972b0d361ed2be5bf2f7c9d5caf53"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , class CIn &gt; </td></tr>
<tr class="memitem:abd8972b0d361ed2be5bf2f7c9d5caf53"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#abd8972b0d361ed2be5bf2f7c9d5caf53">Reduce</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;input, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a> initialValue)</td></tr>
<tr class="memdesc:abd8972b0d361ed2be5bf2f7c9d5caf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a accumulated sum operation on the input <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#abd8972b0d361ed2be5bf2f7c9d5caf53">More...</a><br /></td></tr>
<tr class="separator:abd8972b0d361ed2be5bf2f7c9d5caf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7b4e4a690d51ff76e1ac1c8efe5249"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , class CIn , class BinaryFunctor &gt; </td></tr>
<tr class="memitem:aaa7b4e4a690d51ff76e1ac1c8efe5249"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aaa7b4e4a690d51ff76e1ac1c8efe5249">Reduce</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;input, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a> initialValue, BinaryFunctor binary_functor)</td></tr>
<tr class="memdesc:aaa7b4e4a690d51ff76e1ac1c8efe5249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a accumulated sum operation on the input <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aaa7b4e4a690d51ff76e1ac1c8efe5249">More...</a><br /></td></tr>
<tr class="separator:aaa7b4e4a690d51ff76e1ac1c8efe5249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e25f0cdb9b26bd7b2a92e5661d4b4a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , class CKeyIn , class CValIn , class CKeyOut , class CValOut , class BinaryFunctor &gt; </td></tr>
<tr class="memitem:ac8e25f0cdb9b26bd7b2a92e5661d4b4a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#ac8e25f0cdb9b26bd7b2a92e5661d4b4a">ReduceByKey</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CKeyIn &gt; &amp;keys, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, CValIn &gt; &amp;values, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CKeyOut &gt; &amp;keys_output, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, CValOut &gt; &amp;values_output, BinaryFunctor binary_functor)</td></tr>
<tr class="memdesc:ac8e25f0cdb9b26bd7b2a92e5661d4b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a accumulated sum operation on the input key value pairs.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#ac8e25f0cdb9b26bd7b2a92e5661d4b4a">More...</a><br /></td></tr>
<tr class="separator:ac8e25f0cdb9b26bd7b2a92e5661d4b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a71723cc1f3374bd2883281b8e956ce"><td class="memTemplParams" colspan="2">template&lt;typename T , class CIn , class COut &gt; </td></tr>
<tr class="memitem:a6a71723cc1f3374bd2883281b8e956ce"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a6a71723cc1f3374bd2883281b8e956ce">ScanInclusive</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;input, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, COut &gt; &amp;output)</td></tr>
<tr class="memdesc:a6a71723cc1f3374bd2883281b8e956ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an inclusive prefix sum operation on the input <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a6a71723cc1f3374bd2883281b8e956ce">More...</a><br /></td></tr>
<tr class="separator:a6a71723cc1f3374bd2883281b8e956ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f2b2163eb535b06e6d6549380beeec"><td class="memTemplParams" colspan="2">template&lt;typename T , class CIn , class COut , class BinaryFunctor &gt; </td></tr>
<tr class="memitem:aa8f2b2163eb535b06e6d6549380beeec"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aa8f2b2163eb535b06e6d6549380beeec">ScanInclusive</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;input, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, COut &gt; &amp;output, BinaryFunctor binary_functor)</td></tr>
<tr class="memdesc:aa8f2b2163eb535b06e6d6549380beeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an inclusive prefix sum operation on the input <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aa8f2b2163eb535b06e6d6549380beeec">More...</a><br /></td></tr>
<tr class="separator:aa8f2b2163eb535b06e6d6549380beeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b28babab62a44e7ad55fd893508b6f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename KIn , typename VIn , typename VOut , typename BinaryFunctor &gt; </td></tr>
<tr class="memitem:a38b28babab62a44e7ad55fd893508b6f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a38b28babab62a44e7ad55fd893508b6f">ScanInclusiveByKey</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a43d371abbd468f89479410c97fa1a807">KIn</a> &gt; &amp;keys, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aba4f60fcf4baacdad31a188b136318e9">VIn</a> &gt; &amp;values, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a63523e0d84616450f9497d5750e0be2f">VOut</a> &gt; &amp;values_output, BinaryFunctor binary_functor)</td></tr>
<tr class="memdesc:a38b28babab62a44e7ad55fd893508b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a segmented inclusive prefix sum operation on the input key value pairs.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a38b28babab62a44e7ad55fd893508b6f">More...</a><br /></td></tr>
<tr class="separator:a38b28babab62a44e7ad55fd893508b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d90cb36e3f396905070cd00767db95e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename KIn , typename VIn , typename VOut &gt; </td></tr>
<tr class="memitem:a9d90cb36e3f396905070cd00767db95e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a9d90cb36e3f396905070cd00767db95e">ScanInclusiveByKey</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a43d371abbd468f89479410c97fa1a807">KIn</a> &gt; &amp;keys, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aba4f60fcf4baacdad31a188b136318e9">VIn</a> &gt; &amp;values, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a63523e0d84616450f9497d5750e0be2f">VOut</a> &gt; &amp;values_output)</td></tr>
<tr class="memdesc:a9d90cb36e3f396905070cd00767db95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a segmented inclusive prefix sum operation on the input key value pairs.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a9d90cb36e3f396905070cd00767db95e">More...</a><br /></td></tr>
<tr class="separator:a9d90cb36e3f396905070cd00767db95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e87afb60c28f969e3e751b6a9df57e"><td class="memTemplParams" colspan="2">template&lt;typename T , class CIn , class COut &gt; </td></tr>
<tr class="memitem:ae7e87afb60c28f969e3e751b6a9df57e"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#ae7e87afb60c28f969e3e751b6a9df57e">ScanExclusive</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;input, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, COut &gt; &amp;output)</td></tr>
<tr class="memdesc:ae7e87afb60c28f969e3e751b6a9df57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an exclusive prefix sum operation on the input <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#ae7e87afb60c28f969e3e751b6a9df57e">More...</a><br /></td></tr>
<tr class="separator:ae7e87afb60c28f969e3e751b6a9df57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2399210b953e719df2804bc9e6ac04"><td class="memTemplParams" colspan="2">template&lt;typename T , class CIn , class COut , class BinaryFunctor &gt; </td></tr>
<tr class="memitem:a3b2399210b953e719df2804bc9e6ac04"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a3b2399210b953e719df2804bc9e6ac04">ScanExclusive</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;input, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, COut &gt; &amp;output, BinaryFunctor binaryFunctor, const T &amp;initialValue) template&lt; typename T</td></tr>
<tr class="memdesc:a3b2399210b953e719df2804bc9e6ac04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an exclusive prefix sum operation on the input <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a3b2399210b953e719df2804bc9e6ac04">More...</a><br /></td></tr>
<tr class="separator:a3b2399210b953e719df2804bc9e6ac04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af143fda8d8aae9e37ca0edd819c50aa9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , class KIn , typename VIn , typename VOut &gt; </td></tr>
<tr class="memitem:af143fda8d8aae9e37ca0edd819c50aa9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#af143fda8d8aae9e37ca0edd819c50aa9">ScanExclusiveByKey</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a43d371abbd468f89479410c97fa1a807">KIn</a> &gt; &amp;keys, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aba4f60fcf4baacdad31a188b136318e9">VIn</a> &gt; &amp;values, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a63523e0d84616450f9497d5750e0be2f">VOut</a> &gt; &amp;output)</td></tr>
<tr class="memdesc:af143fda8d8aae9e37ca0edd819c50aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a segmented exclusive prefix sum operation on the input key value pairs.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#af143fda8d8aae9e37ca0edd819c50aa9">More...</a><br /></td></tr>
<tr class="separator:af143fda8d8aae9e37ca0edd819c50aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a79503babbf7511d15b72c1646667f6"><td class="memTemplParams" colspan="2">template&lt;typename T , class CIn , class COut &gt; </td></tr>
<tr class="memitem:a6a79503babbf7511d15b72c1646667f6"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a6a79503babbf7511d15b72c1646667f6">ScanExtended</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;input, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, COut &gt; &amp;output)</td></tr>
<tr class="memdesc:a6a79503babbf7511d15b72c1646667f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an extended prefix sum operation on the input <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a6a79503babbf7511d15b72c1646667f6">More...</a><br /></td></tr>
<tr class="separator:a6a79503babbf7511d15b72c1646667f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07d652c26a7ce5ac12e7a270a023b14"><td class="memTemplParams" colspan="2">template&lt;typename T , class CIn , class COut , class BinaryFunctor &gt; </td></tr>
<tr class="memitem:aa07d652c26a7ce5ac12e7a270a023b14"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aa07d652c26a7ce5ac12e7a270a023b14">ScanExtended</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;input, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, COut &gt; &amp;output, BinaryFunctor binaryFunctor, const T &amp;initialValue)</td></tr>
<tr class="memdesc:aa07d652c26a7ce5ac12e7a270a023b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an extended prefix sum operation on the input <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aa07d652c26a7ce5ac12e7a270a023b14">More...</a><br /></td></tr>
<tr class="separator:aa07d652c26a7ce5ac12e7a270a023b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb26f67083977143c46eaaefc7efe973"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:aeb26f67083977143c46eaaefc7efe973"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aeb26f67083977143c46eaaefc7efe973">Schedule</a> (Functor functor, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numInstances)</td></tr>
<tr class="memdesc:aeb26f67083977143c46eaaefc7efe973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule many instances of a function to run on concurrent threads.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aeb26f67083977143c46eaaefc7efe973">More...</a><br /></td></tr>
<tr class="separator:aeb26f67083977143c46eaaefc7efe973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab0cea9c03c7b545bc42837b72fa30f"><td class="memTemplParams" colspan="2">template&lt;class Functor , class IndiceType &gt; </td></tr>
<tr class="memitem:a3ab0cea9c03c7b545bc42837b72fa30f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a3ab0cea9c03c7b545bc42837b72fa30f">Schedule</a> (Functor functor, <a class="el" href="namespaceviskores.html#a3cc22c6be2f1935ef8a64c21a1196528">viskores::Id3</a> rangeMax)</td></tr>
<tr class="memdesc:a3ab0cea9c03c7b545bc42837b72fa30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule many instances of a function to run on concurrent threads.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a3ab0cea9c03c7b545bc42837b72fa30f">More...</a><br /></td></tr>
<tr class="separator:a3ab0cea9c03c7b545bc42837b72fa30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7215bdf21804a596004659204cf198"><td class="memTemplParams" colspan="2">template&lt;typename T , class Storage &gt; </td></tr>
<tr class="memitem:aec7215bdf21804a596004659204cf198"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aec7215bdf21804a596004659204cf198">Sort</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, Storage &gt; &amp;values)</td></tr>
<tr class="memdesc:aec7215bdf21804a596004659204cf198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unstable ascending sort of input array.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aec7215bdf21804a596004659204cf198">More...</a><br /></td></tr>
<tr class="separator:aec7215bdf21804a596004659204cf198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcbd626ef454c88886547f4f78a1c5a"><td class="memTemplParams" colspan="2">template&lt;typename T , class Storage , class BinaryCompare &gt; </td></tr>
<tr class="memitem:a4fcbd626ef454c88886547f4f78a1c5a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a4fcbd626ef454c88886547f4f78a1c5a">Sort</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, Storage &gt; &amp;values, BinaryCompare binary_compare)</td></tr>
<tr class="memdesc:a4fcbd626ef454c88886547f4f78a1c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unstable ascending sort of input array.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a4fcbd626ef454c88886547f4f78a1c5a">More...</a><br /></td></tr>
<tr class="separator:a4fcbd626ef454c88886547f4f78a1c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b5adb44d6b53c7b4c44145faf4a211"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , class StorageT , class StorageU &gt; </td></tr>
<tr class="memitem:a92b5adb44d6b53c7b4c44145faf4a211"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a92b5adb44d6b53c7b4c44145faf4a211">SortByKey</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageT &gt; &amp;keys, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, StorageU &gt; &amp;values)</td></tr>
<tr class="memdesc:a92b5adb44d6b53c7b4c44145faf4a211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unstable ascending sort of keys and values.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a92b5adb44d6b53c7b4c44145faf4a211">More...</a><br /></td></tr>
<tr class="separator:a92b5adb44d6b53c7b4c44145faf4a211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17502c88e80375f49a2367f5361d994"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , class StorageT , class StorageU , class BinaryCompare &gt; </td></tr>
<tr class="memitem:ac17502c88e80375f49a2367f5361d994"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#ac17502c88e80375f49a2367f5361d994">SortByKey</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageT &gt; &amp;keys, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, StorageU &gt; &amp;values, BinaryCompare binary_compare) static void Synchronize()</td></tr>
<tr class="memdesc:ac17502c88e80375f49a2367f5361d994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unstable ascending sort of keys and values.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#ac17502c88e80375f49a2367f5361d994">More...</a><br /></td></tr>
<tr class="separator:ac17502c88e80375f49a2367f5361d994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26d5e1f2c97aa6f6ff3092517a162d3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V , typename StorageT , typename StorageU , typename StorageV , typename BinaryFunctor &gt; </td></tr>
<tr class="memitem:ac26d5e1f2c97aa6f6ff3092517a162d3"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#ac26d5e1f2c97aa6f6ff3092517a162d3">Transform</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageT &gt; &amp;input1, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, StorageU &gt; &amp;input2, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; V, StorageV &gt; &amp;output, BinaryFunctor binaryFunctor)</td></tr>
<tr class="memdesc:ac26d5e1f2c97aa6f6ff3092517a162d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a given binary operation function element-wise to input arrays.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#ac26d5e1f2c97aa6f6ff3092517a162d3">More...</a><br /></td></tr>
<tr class="separator:ac26d5e1f2c97aa6f6ff3092517a162d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6eaf3183ea92125650f4791931c7e2e"><td class="memTemplParams" colspan="2">template&lt;typename T , class Storage &gt; </td></tr>
<tr class="memitem:af6eaf3183ea92125650f4791931c7e2e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#af6eaf3183ea92125650f4791931c7e2e">Unique</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, Storage &gt; &amp;values)</td></tr>
<tr class="memdesc:af6eaf3183ea92125650f4791931c7e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an array to only the unique values it contains.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#af6eaf3183ea92125650f4791931c7e2e">More...</a><br /></td></tr>
<tr class="separator:af6eaf3183ea92125650f4791931c7e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9751f4db6fccc55cd12223946af2a3f5"><td class="memTemplParams" colspan="2">template&lt;typename T , class Storage , class BinaryCompare &gt; </td></tr>
<tr class="memitem:a9751f4db6fccc55cd12223946af2a3f5"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a9751f4db6fccc55cd12223946af2a3f5">Unique</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, Storage &gt; &amp;values, BinaryCompare binary_compare)</td></tr>
<tr class="memdesc:a9751f4db6fccc55cd12223946af2a3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an array to only the unique values it contains.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a9751f4db6fccc55cd12223946af2a3f5">More...</a><br /></td></tr>
<tr class="separator:a9751f4db6fccc55cd12223946af2a3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab815761324a52382ebb88d1318c83daf"><td class="memTemplParams" colspan="2">template&lt;typename T , class CIn , class CVal , class COut &gt; </td></tr>
<tr class="memitem:ab815761324a52382ebb88d1318c83daf"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#ab815761324a52382ebb88d1318c83daf">UpperBounds</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;input, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CVal &gt; &amp;values, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, COut &gt; &amp;output)</td></tr>
<tr class="memdesc:ab815761324a52382ebb88d1318c83daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output is the last index in input for each item in values that wouldn't alter the ordering of input.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#ab815761324a52382ebb88d1318c83daf">More...</a><br /></td></tr>
<tr class="separator:ab815761324a52382ebb88d1318c83daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb847663bf3079b342d4d39b2e90cbc"><td class="memTemplParams" colspan="2">template&lt;typename T , class CIn , class CVal , class COut , class BinaryCompare &gt; </td></tr>
<tr class="memitem:a5cb847663bf3079b342d4d39b2e90cbc"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a5cb847663bf3079b342d4d39b2e90cbc">UpperBounds</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;input, const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CVal &gt; &amp;values, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, COut &gt; &amp;output, BinaryCompare binary_compare)</td></tr>
<tr class="memdesc:a5cb847663bf3079b342d4d39b2e90cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output is the last index in input for each item in values that wouldn't alter the ordering of input.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a5cb847663bf3079b342d4d39b2e90cbc">More...</a><br /></td></tr>
<tr class="separator:a5cb847663bf3079b342d4d39b2e90cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71cf378e6baa03f411ce361e94ea964"><td class="memTemplParams" colspan="2">template&lt;class CIn , class COut &gt; </td></tr>
<tr class="memitem:ae71cf378e6baa03f411ce361e94ea964"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#ae71cf378e6baa03f411ce361e94ea964">UpperBounds</a> (const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, CIn &gt; &amp;input, <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, COut &gt; &amp;values_output)</td></tr>
<tr class="memdesc:ae71cf378e6baa03f411ce361e94ea964"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special version of UpperBounds that does an in place operation.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#ae71cf378e6baa03f411ce361e94ea964">More...</a><br /></td></tr>
<tr class="separator:ae71cf378e6baa03f411ce361e94ea964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0d16cfbc40907a887753ad6d5555a39c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a0d16cfbc40907a887753ad6d5555a39c">Fill</a> (<a class="el" href="classviskores_1_1cont_1_1BitField.html">viskores::cont::BitField</a> &amp;bits, bool value, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numBits)</td></tr>
<tr class="memdesc:a0d16cfbc40907a887753ad6d5555a39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a> with a specific pattern of bits.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a0d16cfbc40907a887753ad6d5555a39c">More...</a><br /></td></tr>
<tr class="separator:a0d16cfbc40907a887753ad6d5555a39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d30dcba17119ac0e3253431edc90d6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#ad9d30dcba17119ac0e3253431edc90d6">Fill</a> (<a class="el" href="classviskores_1_1cont_1_1BitField.html">viskores::cont::BitField</a> &amp;bits, bool value)</td></tr>
<tr class="memdesc:ad9d30dcba17119ac0e3253431edc90d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a> with a specific pattern of bits.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#ad9d30dcba17119ac0e3253431edc90d6">More...</a><br /></td></tr>
<tr class="separator:ad9d30dcba17119ac0e3253431edc90d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d365e1e84183ee60a630f980e7dfd13"><td class="memTemplParams" colspan="2">template&lt;typename WordType &gt; </td></tr>
<tr class="memitem:a3d365e1e84183ee60a630f980e7dfd13"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a3d365e1e84183ee60a630f980e7dfd13">Fill</a> (<a class="el" href="classviskores_1_1cont_1_1BitField.html">viskores::cont::BitField</a> &amp;bits, WordType word, <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numBits)</td></tr>
<tr class="memdesc:a3d365e1e84183ee60a630f980e7dfd13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a> with a specific pattern of bits.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a3d365e1e84183ee60a630f980e7dfd13">More...</a><br /></td></tr>
<tr class="separator:a3d365e1e84183ee60a630f980e7dfd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c50ccf57c5c7e21cacfd73b184cb9ef"><td class="memTemplParams" colspan="2">template&lt;typename WordType &gt; </td></tr>
<tr class="memitem:a5c50ccf57c5c7e21cacfd73b184cb9ef"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a5c50ccf57c5c7e21cacfd73b184cb9ef">Fill</a> (<a class="el" href="classviskores_1_1cont_1_1BitField.html">viskores::cont::BitField</a> &amp;bits, WordType word)</td></tr>
<tr class="memdesc:a5c50ccf57c5c7e21cacfd73b184cb9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a> with a specific pattern of bits.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a5c50ccf57c5c7e21cacfd73b184cb9ef">More...</a><br /></td></tr>
<tr class="separator:a5c50ccf57c5c7e21cacfd73b184cb9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a053329888c5ae6140e6c14844ec1d55a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a053329888c5ae6140e6c14844ec1d55a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a053329888c5ae6140e6c14844ec1d55a">Fill</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;array, const T &amp;value)</td></tr>
<tr class="memdesc:a053329888c5ae6140e6c14844ec1d55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill <em>array</em> with <em>value</em>.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a053329888c5ae6140e6c14844ec1d55a">More...</a><br /></td></tr>
<tr class="separator:a053329888c5ae6140e6c14844ec1d55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2387d5ffc0ac14a82f7fd82d3aa59144"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a2387d5ffc0ac14a82f7fd82d3aa59144"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a2387d5ffc0ac14a82f7fd82d3aa59144">Fill</a> (<a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;array, const T &amp;value, const <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> numValues)</td></tr>
<tr class="memdesc:a2387d5ffc0ac14a82f7fd82d3aa59144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill <em>array</em> with <em>value</em>.  <a href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a2387d5ffc0ac14a82f7fd82d3aa59144">More...</a><br /></td></tr>
<tr class="separator:a2387d5ffc0ac14a82f7fd82d3aa59144"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a14d019533b71435761f9e7469491f5f6"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a></td></tr>
<tr class="separator:a14d019533b71435761f9e7469491f5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d371abbd468f89479410c97fa1a807"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a43d371abbd468f89479410c97fa1a807">KIn</a></td></tr>
<tr class="separator:a43d371abbd468f89479410c97fa1a807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4f60fcf4baacdad31a188b136318e9"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aba4f60fcf4baacdad31a188b136318e9">VIn</a></td></tr>
<tr class="separator:aba4f60fcf4baacdad31a188b136318e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63523e0d84616450f9497d5750e0be2f"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a63523e0d84616450f9497d5750e0be2f">VOut</a></td></tr>
<tr class="separator:a63523e0d84616450f9497d5750e0be2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class DeviceAdapterTag&gt;<br />
struct viskores::cont::DeviceAdapterAlgorithm&lt; DeviceAdapterTag &gt;</h3>

<p>Struct containing device adapter algorithms. </p>
<p>This struct, templated on the device adapter tag, comprises static methods that implement the algorithms provided by the device adapter. The default struct is not implemented. Device adapter implementations must specialize the template. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae8fc940ba9a8bfd8f6a5c7516411ac27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fc940ba9a8bfd8f6a5c7516411ac27">&#9670;&nbsp;</a></span>BitFieldToUnorderedSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename IndicesStorage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::BitFieldToUnorderedSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1BitField.html">viskores::cont::BitField</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">Id</a>, IndicesStorage &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a unique, unsorted list of indices denoting which bits are set in a bitfield. </p>
<p>Returns the total number of set bits. </p>

</div>
</div>
<a id="a3a3dc5a8bc0fdec96a9a7014f6dc978c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3dc5a8bc0fdec96a9a7014f6dc978c">&#9670;&nbsp;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , class CIn , class COut &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::Copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, COut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the contents of one <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> to another. </p>
<p>Copies the contents of <code>input</code> to <code>output</code>. The array <code>output</code> will be allocated to the same size of <code>input</code>. If output has already been allocated we will reallocate and clear any current values. </p>

</div>
</div>
<a id="a83ca92eaac87182ac3305cfd37236777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ca92eaac87182ac3305cfd37236777">&#9670;&nbsp;</a></span>CopyIf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , class CIn , class CStencil , class COut &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::CopyIf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, CStencil &gt; &amp;&#160;</td>
          <td class="paramname"><em>stencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, COut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally copy elements in the input array to the output array. </p>
<p>Calls the parallel primitive function of stream compaction on the <code>input</code> to remove unwanted elements. The result of the stream compaction is placed in <code>output</code>. The values in <code>stencil</code> are used to determine which <code>input</code> values are placed into <code>output</code>, with all stencil values not equal to the default constructor being considered valid. The size of <code>output</code> will be modified after this call as we can't know the number of elements that will be removed by the stream compaction algorithm. </p>

</div>
</div>
<a id="a15432fa11b9e33f5f268e09007327bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15432fa11b9e33f5f268e09007327bc1">&#9670;&nbsp;</a></span>CopyIf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , class CIn , class CStencil , class COut , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::CopyIf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, CStencil &gt; &amp;&#160;</td>
          <td class="paramname"><em>stencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, COut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>unary_predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally copy elements in the input array to the output array. </p>
<p>Calls the parallel primitive function of stream compaction on the <code>input</code> to remove unwanted elements. The result of the stream compaction is placed in <code>output</code>. The values in <code>stencil</code> are passed to the unary comparison object which is used to determine which /c input values are placed into <code>output</code>. The size of <code>output</code> will be modified after this call as we can't know the number of elements that will be removed by the stream compaction algorithm. </p>

</div>
</div>
<a id="a00cebe388768139c2a1de7a07bd78621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cebe388768139c2a1de7a07bd78621">&#9670;&nbsp;</a></span>CopySubRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , class CIn , class COut &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::CopySubRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>inputStartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numberOfElementsToCopy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, COut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>outputIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the contents of a section of one <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> to another. </p>
<p>Copies the a range of elements of <code>input</code> to <code>output</code>. The number of elements is determined by <code>numberOfElementsToCopy</code>, and initial start position is determined by <code>inputStartIndex</code>. You can control where in the destination the copy should occur by specifying the <code>outputIndex</code> </p>
<p>If inputStartIndex + numberOfElementsToCopy is greater than the length of <code>input</code> we will only copy until we reach the end of the input array</p>
<p>If the <code>outputIndex</code> + numberOfElementsToCopy is greater than the length of <code>output</code> we will reallocate the output array so it can fit the number of elements we desire.</p>
<dl class="section user"><dt>Requirements:</dt><dd><ul>
<li>If <code>input</code> and <code>output</code> share memory, the input and output ranges must not overlap. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af6e3dfa8ae3c3ecc09c59b6358a8c071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e3dfa8ae3c3ecc09c59b6358a8c071">&#9670;&nbsp;</a></span>CountSetBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a> <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::CountSetBits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1BitField.html">viskores::cont::BitField</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of "1" bits in <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a>. </p>

</div>
</div>
<a id="a053329888c5ae6140e6c14844ec1d55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053329888c5ae6140e6c14844ec1d55a">&#9670;&nbsp;</a></span>Fill() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::Fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill <em>array</em> with <em>value</em>. </p>
<p>If <em>numValues</em> is specified, the array will be resized. </p>

</div>
</div>
<a id="a2387d5ffc0ac14a82f7fd82d3aa59144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2387d5ffc0ac14a82f7fd82d3aa59144">&#9670;&nbsp;</a></span>Fill() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::Fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill <em>array</em> with <em>value</em>. </p>
<p>If <em>numValues</em> is specified, the array will be resized. </p>

</div>
</div>
<a id="ad9d30dcba17119ac0e3253431edc90d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d30dcba17119ac0e3253431edc90d6">&#9670;&nbsp;</a></span>Fill() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::Fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1BitField.html">viskores::cont::BitField</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a> with a specific pattern of bits. </p>
<p>For boolean values, all bits are set to 1 if value is true, or 0 if value is false. For word masks, the word type must be an unsigned integral type, which will be stamped across the <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a>. If numBits is provided, the <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a> is resized appropriately. </p>

</div>
</div>
<a id="a0d16cfbc40907a887753ad6d5555a39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d16cfbc40907a887753ad6d5555a39c">&#9670;&nbsp;</a></span>Fill() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::Fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1BitField.html">viskores::cont::BitField</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a> with a specific pattern of bits. </p>
<p>For boolean values, all bits are set to 1 if value is true, or 0 if value is false. For word masks, the word type must be an unsigned integral type, which will be stamped across the <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a>. If numBits is provided, the <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a> is resized appropriately. </p>

</div>
</div>
<a id="a5c50ccf57c5c7e21cacfd73b184cb9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c50ccf57c5c7e21cacfd73b184cb9ef">&#9670;&nbsp;</a></span>Fill() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename WordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::Fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1BitField.html">viskores::cont::BitField</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WordType&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a> with a specific pattern of bits. </p>
<p>For boolean values, all bits are set to 1 if value is true, or 0 if value is false. For word masks, the word type must be an unsigned integral type, which will be stamped across the <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a>. If numBits is provided, the <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a> is resized appropriately. </p>

</div>
</div>
<a id="a3d365e1e84183ee60a630f980e7dfd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d365e1e84183ee60a630f980e7dfd13">&#9670;&nbsp;</a></span>Fill() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename WordType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::Fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1BitField.html">viskores::cont::BitField</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WordType&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a> with a specific pattern of bits. </p>
<p>For boolean values, all bits are set to 1 if value is true, or 0 if value is false. For word masks, the word type must be an unsigned integral type, which will be stamped across the <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a>. If numBits is provided, the <a class="el" href="classviskores_1_1cont_1_1BitField.html">BitField</a> is resized appropriately. </p>

</div>
</div>
<a id="aa911eb358d57a9a7c66950c7f27f4739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa911eb358d57a9a7c66950c7f27f4739">&#9670;&nbsp;</a></span>LowerBounds() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , class CIn , class CVal , class COut &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::LowerBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CVal &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, COut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output is the first index in input for each item in values that wouldn't alter the ordering of input. </p>
<p>LowerBounds is a vectorized search. From each value in <code>values</code> it finds the first place the item can be inserted in the ordered <code>input</code> array and stores the index in <code>output</code>.</p>
<dl class="section user"><dt>Requirements:</dt><dd><ul>
<li><code>input</code> must already be sorted </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9c4135e42bbc49004491ffd251fd0998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4135e42bbc49004491ffd251fd0998">&#9670;&nbsp;</a></span>LowerBounds() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , class CIn , class CVal , class COut , class BinaryCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::LowerBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CVal &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, COut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryCompare&#160;</td>
          <td class="paramname"><em>binary_compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output is the first index in input for each item in values that wouldn't alter the ordering of input. </p>
<p>LowerBounds is a vectorized search. From each value in <code>values</code> it finds the first place the item can be inserted in the ordered <code>input</code> array and stores the index in <code>output</code>. Uses the custom comparison functor to determine the correct location for each item.</p>
<dl class="section user"><dt>Requirements:</dt><dd><ul>
<li><code>input</code> must already be sorted </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8f03be975aab6e4b302155fa417dd47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f03be975aab6e4b302155fa417dd47a">&#9670;&nbsp;</a></span>LowerBounds() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;class CIn , class COut &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::LowerBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, COut &gt; &amp;&#160;</td>
          <td class="paramname"><em>values_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A special version of LowerBounds that does an in place operation. </p>
<p>This version of lower bounds performs an in place operation where each value in the <code>values_output</code> array is replaced by the index in <code>input</code> where it occurs. Because this is an in place operation, the type of the arrays is limited to <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216" title="Base type to use to index arrays.">viskores::Id</a>. </p>

</div>
</div>
<a id="abd8972b0d361ed2be5bf2f7c9d5caf53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8972b0d361ed2be5bf2f7c9d5caf53">&#9670;&nbsp;</a></span>Reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , class CIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a> <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::Reduce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>&#160;</td>
          <td class="paramname"><em>initialValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a accumulated sum operation on the input <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>
<p>Computes an accumulated sum on the <code>input</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>, returning the total sum. Reduce is similar to the stl accumulate sum function, exception that Reduce doesn't do a serial summation. This means that if you have defined a custom plus operator for T it must be commutative, or you will get inconsistent results.</p>
<dl class="section return"><dt>Returns</dt><dd>The total sum. </dd></dl>

</div>
</div>
<a id="aaa7b4e4a690d51ff76e1ac1c8efe5249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7b4e4a690d51ff76e1ac1c8efe5249">&#9670;&nbsp;</a></span>Reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , class CIn , class BinaryFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a> <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::Reduce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>&#160;</td>
          <td class="paramname"><em>initialValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFunctor&#160;</td>
          <td class="paramname"><em>binary_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a accumulated sum operation on the input <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>
<p>Computes an accumulated sum (or any user binary operation) on the <code>input</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>, returning the total sum. Reduce is similar to the stl accumulate sum function, exception that Reduce doesn't do a serial summation. This means that if you have defined a custom plus operator for T it must be commutative, or you will get inconsistent results.</p>
<dl class="section return"><dt>Returns</dt><dd>The total sum. </dd></dl>

</div>
</div>
<a id="ac8e25f0cdb9b26bd7b2a92e5661d4b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e25f0cdb9b26bd7b2a92e5661d4b4a">&#9670;&nbsp;</a></span>ReduceByKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , class CKeyIn , class CValIn , class CKeyOut , class CValOut , class BinaryFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::ReduceByKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CKeyIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, CValIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CKeyOut &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, CValOut &gt; &amp;&#160;</td>
          <td class="paramname"><em>values_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFunctor&#160;</td>
          <td class="paramname"><em>binary_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a accumulated sum operation on the input key value pairs. </p>
<p>Computes a segmented accumulated sum (or any user binary operation) on the <code>keys</code> and <code>values</code> ArrayHandle(s). Each segmented accumulated sum is run on consecutive equal keys with the binary operation applied to all values inside that range. Once finished a single key and value is created for each segment. </p>

</div>
</div>
<a id="ae7e87afb60c28f969e3e751b6a9df57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e87afb60c28f969e3e751b6a9df57e">&#9670;&nbsp;</a></span>ScanExclusive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , class CIn , class COut &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::ScanExclusive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, COut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute an exclusive prefix sum operation on the input <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>
<p>Computes an exclusive prefix sum operation on the <code>input</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>, storing the results in the <code>output</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. ExclusiveScan is similar to the stl partial sum function, exception that ExclusiveScan doesn't do a serial summation. This means that if you have defined a custom plus operator for T it must be associative, or you will get inconsistent results. When the input and output ArrayHandles are the same <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> the operation will be done inplace.</p>
<dl class="section return"><dt>Returns</dt><dd>The total sum. </dd></dl>

</div>
</div>
<a id="a3b2399210b953e719df2804bc9e6ac04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2399210b953e719df2804bc9e6ac04">&#9670;&nbsp;</a></span>ScanExclusive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , class CIn , class COut , class BinaryFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::ScanExclusive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, COut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFunctor&#160;</td>
          <td class="paramname"><em>binaryFunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initialValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute an exclusive prefix sum operation on the input <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>
<p>Computes an exclusive prefix sum operation on the <code>input</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>, storing the results in the <code>output</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. ExclusiveScan is similar to the stl partial sum function, exception that ExclusiveScan doesn't do a serial summation. This means that if you have defined a custom plus operator for T it must be associative, or you will get inconsistent results. When the input and output ArrayHandles are the same <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> the operation will be done inplace.</p>
<dl class="section return"><dt>Returns</dt><dd>The total sum.</dd></dl>
<p>Compute a segmented exclusive prefix sum operation on the input key value pairs.</p>
<p>Computes a segmented exclusive prefix sum (or any user binary operation) on the <code>keys</code> and <code>values</code> ArrayHandle(s). Each segmented exclusive prefix sum is run on consecutive equal keys with the binary operation applied to all values inside that range. Once finished the result is stored in <code>values_output</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>

</div>
</div>
<a id="af143fda8d8aae9e37ca0edd819c50aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af143fda8d8aae9e37ca0edd819c50aa9">&#9670;&nbsp;</a></span>ScanExclusiveByKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , class KIn , typename VIn , typename VOut &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::ScanExclusiveByKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a43d371abbd468f89479410c97fa1a807">KIn</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aba4f60fcf4baacdad31a188b136318e9">VIn</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a63523e0d84616450f9497d5750e0be2f">VOut</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a segmented exclusive prefix sum operation on the input key value pairs. </p>
<p>Computes a segmented inclusive prefix sum on the <code>keys</code> and <code>values</code> ArrayHandle(s). Each segmented inclusive prefix sum is run on consecutive equal keys with the binary operation <a class="el" href="structviskores_1_1Add.html">viskores::Add</a> applied to all values inside that range. Once finished the result is stored in <code>values_output</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>

</div>
</div>
<a id="a1a8c12c512465ade0c8ec7f222ad0f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8c12c512465ade0c8ec7f222ad0f16">&#9670;&nbsp;</a></span>ScanExclusiveByKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static T class BinaryFunctor static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::ScanExclusiveByKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a43d371abbd468f89479410c97fa1a807">KIn</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aba4f60fcf4baacdad31a188b136318e9">VIn</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a63523e0d84616450f9497d5750e0be2f">VOut</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a> &amp;&#160;</td>
          <td class="paramname"><em>initialValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFunctor&#160;</td>
          <td class="paramname"><em>binaryFunctor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a79503babbf7511d15b72c1646667f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a79503babbf7511d15b72c1646667f6">&#9670;&nbsp;</a></span>ScanExtended() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , class CIn , class COut &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::ScanExtended </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, COut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute an extended prefix sum operation on the input <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>
<p>Computes an extended prefix sum operation on the <code>input</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>, storing the results in the <code>output</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. The output array is one element longer than the input array. This produces an output array that contains both an inclusive scan (in elements [1, size]) and an exclusive scan (in elements [0, size-1]). As such, the first element of the output array always has the initial value and the last element of the output array always has the total sum. By using <a class="el" href="classviskores_1_1cont_1_1ArrayHandleView.html" title="Provided a windowed view into a viskores::cont::ArrayHandle.">ArrayHandleView</a>, arrays containing both inclusive and exclusive scans can be generated from an extended scan with minimal memory usage.</p>
<p>This algorithm may also be more efficient than ScanInclusive and ScanExclusive on some devices, since it may be able to avoid copying the total sum to the control environment to return.</p>
<p>ScanExtended is similar to the stl partial sum function, exception that ScanExtended doesn't do a serial summation. This means that if you have defined a custom plus operator for T it must be associative, or you will get inconsistent results.</p>
<p>This overload of ScanExtended uses <a class="el" href="structviskores_1_1Add.html">viskores::Add</a> for the binary functor, and uses zero for the initial value of the scan operation. </p>

</div>
</div>
<a id="aa07d652c26a7ce5ac12e7a270a023b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07d652c26a7ce5ac12e7a270a023b14">&#9670;&nbsp;</a></span>ScanExtended() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , class CIn , class COut , class BinaryFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::ScanExtended </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, COut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFunctor&#160;</td>
          <td class="paramname"><em>binaryFunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initialValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute an extended prefix sum operation on the input <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>
<p>Computes an extended prefix sum operation on the <code>input</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>, storing the results in the <code>output</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. The output array is one element longer than the input array. This produces an output array that contains both an inclusive scan (in elements [1, size]) and an exclusive scan (in elements [0, size-1]). As such, the first element of the output array always has the initial value and the last element of the output array always has the total sum. By using <a class="el" href="classviskores_1_1cont_1_1ArrayHandleView.html" title="Provided a windowed view into a viskores::cont::ArrayHandle.">ArrayHandleView</a>, arrays containing both inclusive and exclusive scans can be generated from an extended scan with minimal memory usage.</p>
<p>This algorithm may also be more efficient than ScanInclusive and ScanExclusive on some devices, since it may be able to avoid copying the total sum to the control environment to return.</p>
<p>ScanExtended is similar to the stl partial sum function, exception that ScanExtended doesn't do a serial summation. This means that if you have defined a custom plus operator for T it must be associative, or you will get inconsistent results. </p>

</div>
</div>
<a id="a6a71723cc1f3374bd2883281b8e956ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a71723cc1f3374bd2883281b8e956ce">&#9670;&nbsp;</a></span>ScanInclusive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , class CIn , class COut &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::ScanInclusive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, COut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute an inclusive prefix sum operation on the input <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>
<p>Computes an inclusive prefix sum operation on the <code>input</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>, storing the results in the <code>output</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. InclusiveScan is similar to the stl partial sum function, exception that InclusiveScan doesn't do a serial summation. This means that if you have defined a custom plus operator for T it must be associative, or you will get inconsistent results. When the input and output ArrayHandles are the same <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> the operation will be done inplace.</p>
<dl class="section return"><dt>Returns</dt><dd>The total sum. </dd></dl>

</div>
</div>
<a id="aa8f2b2163eb535b06e6d6549380beeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f2b2163eb535b06e6d6549380beeec">&#9670;&nbsp;</a></span>ScanInclusive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , class CIn , class COut , class BinaryFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::ScanInclusive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, COut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFunctor&#160;</td>
          <td class="paramname"><em>binary_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute an inclusive prefix sum operation on the input <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>
<p>Computes an inclusive prefix sum operation on the <code>input</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>, storing the results in the <code>output</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. InclusiveScan is similar to the stl partial sum function, exception that InclusiveScan doesn't do a serial summation. This means that if you have defined a custom plus operator for T it must be associative, or you will get inconsistent results. When the input and output ArrayHandles are the same <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a> the operation will be done inplace.</p>
<dl class="section return"><dt>Returns</dt><dd>The total sum. </dd></dl>

</div>
</div>
<a id="a9d90cb36e3f396905070cd00767db95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d90cb36e3f396905070cd00767db95e">&#9670;&nbsp;</a></span>ScanInclusiveByKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , typename KIn , typename VIn , typename VOut &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::ScanInclusiveByKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a43d371abbd468f89479410c97fa1a807">KIn</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aba4f60fcf4baacdad31a188b136318e9">VIn</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a63523e0d84616450f9497d5750e0be2f">VOut</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a segmented inclusive prefix sum operation on the input key value pairs. </p>
<p>Computes a segmented inclusive prefix sum on the <code>keys</code> and <code>values</code> ArrayHandle(s). Each segmented inclusive prefix sum is run on consecutive equal keys with the binary operation <a class="el" href="structviskores_1_1Add.html">viskores::Add</a> applied to all values inside that range. Once finished the result is stored in <code>values_output</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>

</div>
</div>
<a id="a38b28babab62a44e7ad55fd893508b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b28babab62a44e7ad55fd893508b6f">&#9670;&nbsp;</a></span>ScanInclusiveByKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , typename KIn , typename VIn , typename VOut , typename BinaryFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::ScanInclusiveByKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a43d371abbd468f89479410c97fa1a807">KIn</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#aba4f60fcf4baacdad31a188b136318e9">VIn</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a63523e0d84616450f9497d5750e0be2f">VOut</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFunctor&#160;</td>
          <td class="paramname"><em>binary_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a segmented inclusive prefix sum operation on the input key value pairs. </p>
<p>Computes a segmented inclusive prefix sum (or any user binary operation) on the <code>keys</code> and <code>values</code> ArrayHandle(s). Each segmented inclusive prefix sum is run on consecutive equal keys with the binary operation applied to all values inside that range. Once finished the result is stored in <code>values_output</code> <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a>. </p>

</div>
</div>
<a id="aeb26f67083977143c46eaaefc7efe973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb26f67083977143c46eaaefc7efe973">&#9670;&nbsp;</a></span>Schedule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;class Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::Schedule </td>
          <td>(</td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>&#160;</td>
          <td class="paramname"><em>numInstances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedule many instances of a function to run on concurrent threads. </p>
<p>Calls the <code>functor</code> on several threads. This is the function used in the control environment to spawn activity in the execution environment. <code>functor</code> is a function-like object that can be invoked with the calling specification <code>functor(viskores::Id index)</code>. It also has a method called from the control environment to establish the error reporting buffer with the calling specification <code>functor.SetErrorMessageBuffer(const viskores::exec::internal::ErrorMessageBuffer &amp;errorMessage)</code>. This object can be stored in the functor's state such that if RaiseError is called on it in the execution environment, an <a class="el" href="classviskores_1_1cont_1_1ErrorExecution.html" title="This class is thrown in the control environment whenever an error occurs in the execution environment...">ErrorExecution</a> will be thrown from Schedule.</p>
<p>The argument of the invoked functor uniquely identifies the thread or instance of the invocation. There should be one invocation for each index in the range [0, <code>numInstances</code>]. </p>

</div>
</div>
<a id="a3ab0cea9c03c7b545bc42837b72fa30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab0cea9c03c7b545bc42837b72fa30f">&#9670;&nbsp;</a></span>Schedule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;class Functor , class IndiceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::Schedule </td>
          <td>(</td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviskores.html#a3cc22c6be2f1935ef8a64c21a1196528">viskores::Id3</a>&#160;</td>
          <td class="paramname"><em>rangeMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedule many instances of a function to run on concurrent threads. </p>
<p>Calls the <code>functor</code> on several threads. This is the function used in the control environment to spawn activity in the execution environment. <code>functor</code> is a function-like object that can be invoked with the calling specification <code>functor(viskores::Id3 index)</code> or <code>functor(<a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216" title="Base type to use to index arrays.">viskores::Id</a> index)</code>. It also has a method called from the control environment to establish the error reporting buffer with the calling specification <code>functor.SetErrorMessageBuffer(const viskores::exec::internal::ErrorMessageBuffer &amp;errorMessage)</code>. This object can be stored in the functor's state such that if RaiseError is called on it in the execution environment, an <a class="el" href="classviskores_1_1cont_1_1ErrorExecution.html" title="This class is thrown in the control environment whenever an error occurs in the execution environment...">ErrorExecution</a> will be thrown from Schedule.</p>
<p>The argument of the invoked functor uniquely identifies the thread or instance of the invocation. It is at the device adapter's discretion whether to schedule on 1D or 3D indices, so the functor should have an operator() overload for each index type. If 3D indices are used, there is one invocation for every i, j, k value between [0, 0, 0] and <code>rangeMax</code>. If 1D indices are used, this Schedule behaves as if <code>Schedule(functor, rangeMax[0]*rangeMax[1]*rangeMax[2])</code> were called. </p>

</div>
</div>
<a id="aec7215bdf21804a596004659204cf198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7215bdf21804a596004659204cf198">&#9670;&nbsp;</a></span>Sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , class Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::Sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, Storage &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unstable ascending sort of input array. </p>
<p>Sorts the contents of <code>values</code> so that they in ascending value. Doesn't guarantee stability </p>

</div>
</div>
<a id="a4fcbd626ef454c88886547f4f78a1c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcbd626ef454c88886547f4f78a1c5a">&#9670;&nbsp;</a></span>Sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , class Storage , class BinaryCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::Sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, Storage &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryCompare&#160;</td>
          <td class="paramname"><em>binary_compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unstable ascending sort of input array. </p>
<p>Sorts the contents of <code>values</code> so that they in ascending value based on the custom compare functor.</p>
<p>BinaryCompare should be a strict weak ordering comparison operator </p>

</div>
</div>
<a id="a92b5adb44d6b53c7b4c44145faf4a211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b5adb44d6b53c7b4c44145faf4a211">&#9670;&nbsp;</a></span>SortByKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , class StorageT , class StorageU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::SortByKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageT &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, StorageU &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unstable ascending sort of keys and values. </p>
<p>Sorts the contents of <code>keys</code> and <code>values</code> so that they in ascending value based on the values of keys. </p>

</div>
</div>
<a id="ac17502c88e80375f49a2367f5361d994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17502c88e80375f49a2367f5361d994">&#9670;&nbsp;</a></span>SortByKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , class StorageT , class StorageU , class BinaryCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::SortByKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageT &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, StorageU &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryCompare&#160;</td>
          <td class="paramname"><em>binary_compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unstable ascending sort of keys and values. </p>
<p>Sorts the contents of <code>keys</code> and <code>values</code> so that they in ascending value based on the custom compare functor.</p>
<p>BinaryCompare should be a strict weak ordering comparison operator</p>
<p>Completes any asynchronous operations running on the device.</p>
<p>Waits for any asynchronous operations running on the device to complete. </p>

</div>
</div>
<a id="ac26d5e1f2c97aa6f6ff3092517a162d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26d5e1f2c97aa6f6ff3092517a162d3">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U , typename V , typename StorageT , typename StorageU , typename StorageV , typename BinaryFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, StorageT &gt; &amp;&#160;</td>
          <td class="paramname"><em>input1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html#a14d019533b71435761f9e7469491f5f6">U</a>, StorageU &gt; &amp;&#160;</td>
          <td class="paramname"><em>input2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; V, StorageV &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFunctor&#160;</td>
          <td class="paramname"><em>binaryFunctor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a given binary operation function element-wise to input arrays. </p>
<p>Apply the give binary operation to pairs of elements from the two input array <code>input1</code> and <code>input2</code>. The number of elements in the input arrays do not have to be the same, in this case, only the smaller of the two numbers of elements will be applied. Outputs of the binary operation is stored in <code>output</code>. </p>

</div>
</div>
<a id="af6eaf3183ea92125650f4791931c7e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6eaf3183ea92125650f4791931c7e2e">&#9670;&nbsp;</a></span>Unique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , class Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::Unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, Storage &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce an array to only the unique values it contains. </p>
<p>Removes all duplicate values in <code>values</code> that are adjacent to each other. Which means you should sort the input array unless you want duplicate values that aren't adjacent. Note the values array size might be modified by this operation. </p>

</div>
</div>
<a id="a9751f4db6fccc55cd12223946af2a3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9751f4db6fccc55cd12223946af2a3f5">&#9670;&nbsp;</a></span>Unique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , class Storage , class BinaryCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::Unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, Storage &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryCompare&#160;</td>
          <td class="paramname"><em>binary_compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce an array to only the unique values it contains. </p>
<p>Removes all duplicate values in <code>values</code> that are adjacent to each other. Which means you should sort the input array unless you want duplicate values that aren't adjacent. Note the values array size might be modified by this operation.</p>
<p>Uses the custom binary predicate Comparison to determine if something is unique. The predicate must return true if the two items are the same. </p>

</div>
</div>
<a id="ab815761324a52382ebb88d1318c83daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab815761324a52382ebb88d1318c83daf">&#9670;&nbsp;</a></span>UpperBounds() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , class CIn , class CVal , class COut &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::UpperBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CVal &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, COut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output is the last index in input for each item in values that wouldn't alter the ordering of input. </p>
<p>UpperBounds is a vectorized search. From each value in <code>values</code> it finds the last place the item can be inserted in the ordered <code>input</code> array and stores the index in <code>output</code>.</p>
<dl class="section user"><dt>Requirements:</dt><dd><ul>
<li><code>input</code> must already be sorted </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5cb847663bf3079b342d4d39b2e90cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb847663bf3079b342d4d39b2e90cbc">&#9670;&nbsp;</a></span>UpperBounds() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;typename T , class CIn , class CVal , class COut , class BinaryCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::UpperBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; T, CVal &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, COut &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryCompare&#160;</td>
          <td class="paramname"><em>binary_compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output is the last index in input for each item in values that wouldn't alter the ordering of input. </p>
<p>LowerBounds is a vectorized search. From each value in <code>values</code> it finds the last place the item can be inserted in the ordered <code>input</code> array and stores the index in <code>output</code>. Uses the custom comparison functor to determine the correct location for each item.</p>
<dl class="section user"><dt>Requirements:</dt><dd><ul>
<li><code>input</code> must already be sorted </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae71cf378e6baa03f411ce361e94ea964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71cf378e6baa03f411ce361e94ea964">&#9670;&nbsp;</a></span>UpperBounds() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
<div class="memtemplate">
template&lt;class CIn , class COut &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::UpperBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, CIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html">viskores::cont::ArrayHandle</a>&lt; <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216">viskores::Id</a>, COut &gt; &amp;&#160;</td>
          <td class="paramname"><em>values_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A special version of UpperBounds that does an in place operation. </p>
<p>This version of lower bounds performs an in place operation where each value in the <code>values_output</code> array is replaced by the last index in <code>input</code> where it occurs. Because this is an in place operation, the type of the arrays is limited to <a class="el" href="namespaceviskores.html#a8e82cb49e20cef45fbeb58dc58790216" title="Base type to use to index arrays.">viskores::Id</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a43d371abbd468f89479410c97fa1a807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d371abbd468f89479410c97fa1a807">&#9670;&nbsp;</a></span>KIn</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::KIn</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14d019533b71435761f9e7469491f5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d019533b71435761f9e7469491f5f6">&#9670;&nbsp;</a></span>U</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::U</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba4f60fcf4baacdad31a188b136318e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4f60fcf4baacdad31a188b136318e9">&#9670;&nbsp;</a></span>VIn</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::VIn</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63523e0d84616450f9497d5750e0be2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63523e0d84616450f9497d5750e0be2f">&#9670;&nbsp;</a></span>VOut</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceAdapterTag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structviskores_1_1cont_1_1DeviceAdapterAlgorithm.html">viskores::cont::DeviceAdapterAlgorithm</a>&lt; DeviceAdapterTag &gt;::VOut</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="DeviceAdapterAlgorithm_8h_source.html">DeviceAdapterAlgorithm.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
