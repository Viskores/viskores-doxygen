<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Viskores: viskores::cont::Token Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Viskores
   &#160;<span id="projectnumber">1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceviskores.html">viskores</a></li><li class="navelem"><a class="el" href="namespaceviskores_1_1cont.html">cont</a></li><li class="navelem"><a class="el" href="classviskores_1_1cont_1_1Token.html">Token</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classviskores_1_1cont_1_1Token-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">viskores::cont::Token Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A token to hold the scope of an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> or other object.  
 <a href="classviskores_1_1cont_1_1Token.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Token_8h_source.html">Token.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1Token_1_1ObjectReference.html">ObjectReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviskores_1_1cont_1_1Token_1_1ObjectReferenceImpl.html">ObjectReferenceImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Token_1_1Reference.html">Reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a35e2bb06b9b34d738a904e99e8927bf0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Token.html#a35e2bb06b9b34d738a904e99e8927bf0">ReferenceCount</a> = <a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a></td></tr>
<tr class="memdesc:a35e2bb06b9b34d738a904e99e8927bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this type to represent counts of how many tokens are holding a resource.  <a href="classviskores_1_1cont_1_1Token.html#a35e2bb06b9b34d738a904e99e8927bf0">More...</a><br /></td></tr>
<tr class="separator:a35e2bb06b9b34d738a904e99e8927bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6ebd0b56ed620cc0245bb3d607e586a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Token.html#a6ebd0b56ed620cc0245bb3d607e586a3">Token</a> ()</td></tr>
<tr class="separator:a6ebd0b56ed620cc0245bb3d607e586a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc103628030369b381c642a301a1ad2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Token.html#abc103628030369b381c642a301a1ad2b">Token</a> (<a class="el" href="classviskores_1_1cont_1_1Token.html">Token</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:abc103628030369b381c642a301a1ad2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec01dd333924fce44181a7712fdfd71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Token.html#adec01dd333924fce44181a7712fdfd71">~Token</a> ()</td></tr>
<tr class="separator:adec01dd333924fce44181a7712fdfd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f9883cd7345c1622efae7099c1c0a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Token.html#ae5f9883cd7345c1622efae7099c1c0a6">DetachFromAll</a> ()</td></tr>
<tr class="memdesc:ae5f9883cd7345c1622efae7099c1c0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches this <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> from all resources to allow them to be used elsewhere or deleted.  <a href="classviskores_1_1cont_1_1Token.html#ae5f9883cd7345c1622efae7099c1c0a6">More...</a><br /></td></tr>
<tr class="separator:ae5f9883cd7345c1622efae7099c1c0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72da1b9bc95a27feeb7e574e3890e6ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72da1b9bc95a27feeb7e574e3890e6ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Token.html#a72da1b9bc95a27feeb7e574e3890e6ac">Attach</a> (T &amp;&amp;object, <a class="el" href="classviskores_1_1cont_1_1Token.html#a35e2bb06b9b34d738a904e99e8927bf0">viskores::cont::Token::ReferenceCount</a> *referenceCountPointer, std::unique_lock&lt; std::mutex &gt; &amp;lock, std::condition_variable *conditionVariablePointer)</td></tr>
<tr class="memdesc:a72da1b9bc95a27feeb7e574e3890e6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structviskores_1_1Add.html">Add</a> an object to attach to the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code>.  <a href="classviskores_1_1cont_1_1Token.html#a72da1b9bc95a27feeb7e574e3890e6ac">More...</a><br /></td></tr>
<tr class="separator:a72da1b9bc95a27feeb7e574e3890e6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d577f2f570da1035093901d7405bc9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98d577f2f570da1035093901d7405bc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Token.html#a98d577f2f570da1035093901d7405bc9">Attach</a> (T &amp;&amp;object, <a class="el" href="classviskores_1_1cont_1_1Token.html#a35e2bb06b9b34d738a904e99e8927bf0">viskores::cont::Token::ReferenceCount</a> *referenceCountPoiner, std::mutex *mutexPointer, std::condition_variable *conditionVariablePointer)</td></tr>
<tr class="memdesc:a98d577f2f570da1035093901d7405bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structviskores_1_1Add.html">Add</a> an object to attach to the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code>.  <a href="classviskores_1_1cont_1_1Token.html#a98d577f2f570da1035093901d7405bc9">More...</a><br /></td></tr>
<tr class="separator:a98d577f2f570da1035093901d7405bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cff80d588715c72b28460178886820"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Token.html#a22cff80d588715c72b28460178886820">IsAttached</a> (<a class="el" href="classviskores_1_1cont_1_1Token.html#a35e2bb06b9b34d738a904e99e8927bf0">viskores::cont::Token::ReferenceCount</a> *referenceCountPointer) const</td></tr>
<tr class="memdesc:a22cff80d588715c72b28460178886820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is already attached to an object.  <a href="classviskores_1_1cont_1_1Token.html#a22cff80d588715c72b28460178886820">More...</a><br /></td></tr>
<tr class="separator:a22cff80d588715c72b28460178886820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f75797e02c5919b2d20a41f73b86ea5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviskores_1_1cont_1_1Token_1_1Reference.html">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Token.html#a3f75797e02c5919b2d20a41f73b86ea5">GetReference</a> () const</td></tr>
<tr class="memdesc:a3f75797e02c5919b2d20a41f73b86ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference object to this <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code>.  <a href="classviskores_1_1cont_1_1Token.html#a3f75797e02c5919b2d20a41f73b86ea5">More...</a><br /></td></tr>
<tr class="separator:a3f75797e02c5919b2d20a41f73b86ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:acac5c483ba6f6b3164859580bd0f44c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Token.html#acac5c483ba6f6b3164859580bd0f44c0">Attach</a> (std::unique_ptr&lt; <a class="el" href="structviskores_1_1cont_1_1Token_1_1ObjectReference.html">viskores::cont::Token::ObjectReference</a> &gt; &amp;&amp;objectReference, <a class="el" href="classviskores_1_1cont_1_1Token.html#a35e2bb06b9b34d738a904e99e8927bf0">viskores::cont::Token::ReferenceCount</a> *referenceCountPointer, std::unique_lock&lt; std::mutex &gt; &amp;lock, std::condition_variable *conditionVariablePointer)</td></tr>
<tr class="separator:acac5c483ba6f6b3164859580bd0f44c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3057e63179e2cf7122f3c727e4993183"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Token.html#a3057e63179e2cf7122f3c727e4993183">IsAttached</a> (std::unique_lock&lt; std::mutex &gt; &amp;lock, <a class="el" href="classviskores_1_1cont_1_1Token.html#a35e2bb06b9b34d738a904e99e8927bf0">viskores::cont::Token::ReferenceCount</a> *referenceCountPointer) const</td></tr>
<tr class="separator:a3057e63179e2cf7122f3c727e4993183"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a33f260b832abb11f7abff87bc0308c94"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; InternalStruct &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviskores_1_1cont_1_1Token.html#a33f260b832abb11f7abff87bc0308c94">Internals</a></td></tr>
<tr class="separator:a33f260b832abb11f7abff87bc0308c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A token to hold the scope of an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> or other object. </p>
<p>A <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is an object that is held in the stack or state of another object and is used when creating references to resouces that may be used by other threads. For example, when preparing an <code><a class="el" href="classviskores_1_1cont_1_1ArrayHandle.html" title="Manages an array-worth of data.">ArrayHandle</a></code> or <code>ExecutionObject</code> for a device, a <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is given. The returned object will be valid as long as the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> remains in scope. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a35e2bb06b9b34d738a904e99e8927bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e2bb06b9b34d738a904e99e8927bf0">&#9670;&nbsp;</a></span>ReferenceCount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classviskores_1_1cont_1_1Token.html#a35e2bb06b9b34d738a904e99e8927bf0">viskores::cont::Token::ReferenceCount</a> =  <a class="el" href="namespaceviskores.html#aca2ec71d38de7693e10bc433f43dbf40">viskores::IdComponent</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this type to represent counts of how many tokens are holding a resource. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6ebd0b56ed620cc0245bb3d607e586a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ebd0b56ed620cc0245bb3d607e586a3">&#9670;&nbsp;</a></span>Token() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">viskores::cont::Token::Token </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc103628030369b381c642a301a1ad2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc103628030369b381c642a301a1ad2b">&#9670;&nbsp;</a></span>Token() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">viskores::cont::Token::Token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token.html">Token</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adec01dd333924fce44181a7712fdfd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec01dd333924fce44181a7712fdfd71">&#9670;&nbsp;</a></span>~Token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">viskores::cont::Token::~Token </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acac5c483ba6f6b3164859580bd0f44c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac5c483ba6f6b3164859580bd0f44c0">&#9670;&nbsp;</a></span>Attach() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::Token::Attach </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="structviskores_1_1cont_1_1Token_1_1ObjectReference.html">viskores::cont::Token::ObjectReference</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>objectReference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token.html#a35e2bb06b9b34d738a904e99e8927bf0">viskores::cont::Token::ReferenceCount</a> *&#160;</td>
          <td class="paramname"><em>referenceCountPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_lock&lt; std::mutex &gt; &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::condition_variable *&#160;</td>
          <td class="paramname"><em>conditionVariablePointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a98d577f2f570da1035093901d7405bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d577f2f570da1035093901d7405bc9">&#9670;&nbsp;</a></span>Attach() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::Token::Attach </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token.html#a35e2bb06b9b34d738a904e99e8927bf0">viskores::cont::Token::ReferenceCount</a> *&#160;</td>
          <td class="paramname"><em>referenceCountPoiner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mutex *&#160;</td>
          <td class="paramname"><em>mutexPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::condition_variable *&#160;</td>
          <td class="paramname"><em>conditionVariablePointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structviskores_1_1Add.html">Add</a> an object to attach to the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code>. </p>
<p>To attach an object to a <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code>, you need the object itself, a pointer to a <code><a class="el" href="classviskores_1_1cont_1_1Token.html#a35e2bb06b9b34d738a904e99e8927bf0" title="Use this type to represent counts of how many tokens are holding a resource.">Token::ReferenceCount</a></code> that is used to count how many <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code>s hold the object, a pointer to a <code>std::mutex</code> used to safely use the <code>ReferenceCount</code>, and a pointer to a <code>std::condition_variable</code> that other threads will wait on if they are blocked by the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> (using the same <code>mutex</code> in the given <code>unique_lock</code>). The mutex can also be passed in as a <code>std::unique_lock&lt;std::mutex&gt;</code> to signal whether or not the mutex is already locked by the current thread.</p>
<p>When the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is attached, it will increment the reference count (safely with the mutex) and store away these items. Other items will be able tell if a token is attached to the object by looking at the reference count.</p>
<p>When the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is released, it will decrement the reference count (safely with the mutex) and then notify all threads waiting on the condition variable. </p>

</div>
</div>
<a id="a72da1b9bc95a27feeb7e574e3890e6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72da1b9bc95a27feeb7e574e3890e6ac">&#9670;&nbsp;</a></span>Attach() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::Token::Attach </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token.html#a35e2bb06b9b34d738a904e99e8927bf0">viskores::cont::Token::ReferenceCount</a> *&#160;</td>
          <td class="paramname"><em>referenceCountPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_lock&lt; std::mutex &gt; &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::condition_variable *&#160;</td>
          <td class="paramname"><em>conditionVariablePointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structviskores_1_1Add.html">Add</a> an object to attach to the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code>. </p>
<p>To attach an object to a <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code>, you need the object itself, a pointer to a <code><a class="el" href="classviskores_1_1cont_1_1Token.html#a35e2bb06b9b34d738a904e99e8927bf0" title="Use this type to represent counts of how many tokens are holding a resource.">Token::ReferenceCount</a></code> that is used to count how many <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code>s hold the object, a pointer to a <code>std::mutex</code> used to safely use the <code>ReferenceCount</code>, and a pointer to a <code>std::condition_variable</code> that other threads will wait on if they are blocked by the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> (using the same <code>mutex</code> in the given <code>unique_lock</code>). The mutex can also be passed in as a <code>std::unique_lock&lt;std::mutex&gt;</code> to signal whether or not the mutex is already locked by the current thread.</p>
<p>When the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is attached, it will increment the reference count (safely with the mutex) and store away these items. Other items will be able tell if a token is attached to the object by looking at the reference count.</p>
<p>When the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is released, it will decrement the reference count (safely with the mutex) and then notify all threads waiting on the condition variable. </p>

</div>
</div>
<a id="ae5f9883cd7345c1622efae7099c1c0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f9883cd7345c1622efae7099c1c0a6">&#9670;&nbsp;</a></span>DetachFromAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viskores::cont::Token::DetachFromAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches this <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> from all resources to allow them to be used elsewhere or deleted. </p>

</div>
</div>
<a id="a3f75797e02c5919b2d20a41f73b86ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f75797e02c5919b2d20a41f73b86ea5">&#9670;&nbsp;</a></span>GetReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviskores_1_1cont_1_1Token_1_1Reference.html">Reference</a> viskores::cont::Token::GetReference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference object to this <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code>. </p>
<p><code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> objects cannot be copied and generally are not shared. However, there are cases where you need to save a reference to a <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> belonging to someone else so that it can later be compared. Saving a pointer to a <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is not always safe because <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code>s can be moved. To get around this problem, you can save a <code><a class="el" href="classviskores_1_1cont_1_1Token_1_1Reference.html">Reference</a></code> to the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code>. You cannot use the <code><a class="el" href="classviskores_1_1cont_1_1Token_1_1Reference.html">Reference</a></code> to manipulate the <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> in any way (because you do not own it). Rather, a <code><a class="el" href="classviskores_1_1cont_1_1Token_1_1Reference.html">Reference</a></code> can just be used to compare to a <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> object (or another <code><a class="el" href="classviskores_1_1cont_1_1Token_1_1Reference.html">Reference</a></code>). </p>

</div>
</div>
<a id="a3057e63179e2cf7122f3c727e4993183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3057e63179e2cf7122f3c727e4993183">&#9670;&nbsp;</a></span>IsAttached() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::Token::IsAttached </td>
          <td>(</td>
          <td class="paramtype">std::unique_lock&lt; std::mutex &gt; &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token.html#a35e2bb06b9b34d738a904e99e8927bf0">viskores::cont::Token::ReferenceCount</a> *&#160;</td>
          <td class="paramname"><em>referenceCountPointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22cff80d588715c72b28460178886820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cff80d588715c72b28460178886820">&#9670;&nbsp;</a></span>IsAttached() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool viskores::cont::Token::IsAttached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviskores_1_1cont_1_1Token.html#a35e2bb06b9b34d738a904e99e8927bf0">viskores::cont::Token::ReferenceCount</a> *&#160;</td>
          <td class="paramname"><em>referenceCountPointer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if this <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is already attached to an object. </p>
<p>Given a reference counter pointer, such as would be passed to the <code>Attach</code> method, returns true if this <code><a class="el" href="classviskores_1_1cont_1_1Token.html" title="A token to hold the scope of an ArrayHandle or other object.">Token</a></code> is already attached, <code>false</code> otherwise. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a33f260b832abb11f7abff87bc0308c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f260b832abb11f7abff87bc0308c94">&#9670;&nbsp;</a></span>Internals</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;InternalStruct&gt; viskores::cont::Token::Internals</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Token_8h_source.html">Token.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
